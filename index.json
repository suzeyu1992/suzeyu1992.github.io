[{"categories":["nas","git","自动化"],"content":"这个过程本来没打算写下来, 最开始以为在网上找个文章安装一下就行, 没想到折腾了好几个小时,为了以后省事整理一下. ","date":"2022-10-10","objectID":"/posts/unraid%E5%AE%89%E8%A3%85gitlab%E8%AE%B0%E5%BD%95/:0:0","tags":["nas","git","自动化"],"title":"Unraid安装GitLab记录","uri":"/posts/unraid%E5%AE%89%E8%A3%85gitlab%E8%AE%B0%E5%BD%95/"},{"categories":["nas","git","自动化"],"content":"安装环境和目标功能 Unraid 6.11.1 安装的镜像: gitlab/gitlab-ce 因为nas有公网, 所以希望二级域名能访问仓库, 并且外网时http和ssh都可以拉取推送. ","date":"2022-10-10","objectID":"/posts/unraid%E5%AE%89%E8%A3%85gitlab%E8%AE%B0%E5%BD%95/:0:1","tags":["nas","git","自动化"],"title":"Unraid安装GitLab记录","uri":"/posts/unraid%E5%AE%89%E8%A3%85gitlab%E8%AE%B0%E5%BD%95/"},{"categories":["nas","git","自动化"],"content":"安装开始 ","date":"2022-10-10","objectID":"/posts/unraid%E5%AE%89%E8%A3%85gitlab%E8%AE%B0%E5%BD%95/:0:2","tags":["nas","git","自动化"],"title":"Unraid安装GitLab记录","uri":"/posts/unraid%E5%AE%89%E8%A3%85gitlab%E8%AE%B0%E5%BD%95/"},{"categories":["nas","git","自动化"],"content":"1.安装应用并填写配置信息 应用商店搜索gitlab 安装 GitLab-CE镜像 配置容器的端口转发, 3个可以随意填写.如下: 点击应用安装即可, 这个镜像有点大,需要等一会. ","date":"2022-10-10","objectID":"/posts/unraid%E5%AE%89%E8%A3%85gitlab%E8%AE%B0%E5%BD%95/:0:3","tags":["nas","git","自动化"],"title":"Unraid安装GitLab记录","uri":"/posts/unraid%E5%AE%89%E8%A3%85gitlab%E8%AE%B0%E5%BD%95/"},{"categories":["nas","git","自动化"],"content":"2.更改root初始密码 安装后, 不能注册新用户, 只能使用root账号登陆.所以 容器运行后, 进入到容器控制台, 查看root初始密码 cat /etc/gitlab/initial_root_password 然后 点击WebUI, 或者输入主机ip:5010进入到GitLab首页面 账户名: root 密码: 获取到的初始密码 登陆后, 先把密码改一下, 因为初始密码只存在24小时. 头像 -\u003e Edit Profile -\u003e password 这时仓库的路径是存在问题的. 如下. 可以看到这两个地址的域名显示的是unraid而不是本机ip, 并且9080是容器内端口, 并不是之前在配置时填写的5010外部转发端口. 再次进入容器环境控制台.修改 /etc/gitlab/gitlab.rb 文件, 这里要注意不要修改其他的如xxx.yml文件, 因为很多文件都是自动生成的, 当你容器重启时会全部重置, 这会让你之前的配置都失效. 这个文件夹已经在容器配置时挂载了, 也就是主机里的config文件夹. 因为这个文件特别大, 如果不熟练vi的, 那就在修改文件权限在本地操作. ###### 修改前 #33行左右, 生成http地址时的域名 http://ip:port # external_url 'GENERATED_EXTERNAL_URL' #638行左右, 生成ssh地址时的端口 # gitlab_rails['gitlab_shell_ssh_port'] = 22 #66行左右 生成ssh地址时的域名 # gitlab_rails['gitlab_ssh_host'] = 'ssh.host_example.com' ###### 修改后 external_url 'http://gitlab.xxx.com' gitlab_rails['gitlab_shell_ssh_port'] = 5013 gitlab_rails['gitlab_ssh_host'] = 'ddns.xxx.com' 上面这个需要根据自己情况而定. 我这里这么设置是因为我的nas使用反向代理, xxx.com为一级域名, gitlab.xxx.com为二级域名并且指向的是 公网ip 的5010端口, ddns.xxx.com为二级域名指向的公网ip. 因为GitLab在容器中, 容器又在Nas中, 所以生成的ssh地址必须要有端口号(不然就要修改最外部nas22端口), 所以gitlab_shell_ssh_port也进行了更改. 修改完之后, 回到容器的控制台, 进行重新生成配置和重启,注意(不是容器的重启) 执行下面两条命令 $ gitlab-ctl reconfigure $ gitlab-ctl restart 这个时候应该就出现问题了, 主页无法访问. 通过netstat -ntl命令查看, 之前配置的内部9080端口没有监听活跃, 应该变成了80端口, 此时再次编译gitlab.br文件. 修改nginx[’listen_port’] 的默认值. #1395行左右 # nginx['listen_port'] = nil # 修改如下 nginx['listen_port'] = 9080 再次执行如下命令 $ gitlab-ctl reconfigure $ gitlab-ctl restart 查看一下主页能否访问, 不能就重新启动一下容器. (还有一种情况502, 说明主页可以访问,nginx端口没问题, 但是其他端口可能冲突) 再次进入项目查看: 现在生成的两个地址就是正确可用的, 在终端拉取验证一下. ssh拉取先把自己电脑的公钥添加到GitLab的账号上. 并且把需要外放的端口都在路由器进行转发. 至此, 一个基本的仓库搭建就完成了. ","date":"2022-10-10","objectID":"/posts/unraid%E5%AE%89%E8%A3%85gitlab%E8%AE%B0%E5%BD%95/:0:4","tags":["nas","git","自动化"],"title":"Unraid安装GitLab记录","uri":"/posts/unraid%E5%AE%89%E8%A3%85gitlab%E8%AE%B0%E5%BD%95/"},{"categories":["android","AOSP"],"content":"piexl4（flame）手机android12.1.0驱动下载： https://developers.google.cn/android/drivers#flamesq3a.220705.003.a1 (coral)https://developers.google.cn/android/drivers#coralsq3a.220705.003.a1 Piexl手机对应版本号： https://source.android.google.cn/setup/build/running#selecting-device-buildPixel Pixel 4a刷机参考： https://blog.csdn.net/lzz137/article/details/118526642 去除原生wifi感叹号： https://blog.csdn.net/xuwei131144/article/details/120448818 source build/envsetup.sh make clobber lunch aosp_coral-userdebug 或者 lunch aosp_coral-eng make 刷机 adb reboot fastboot 等待手机进入 fastboot 界面之后 fastboot flashall -w 刷机完成之后，执行 fastboot reboot 长期系统即可 fastboot reboot ","date":"2022-07-28","objectID":"/posts/aosp%E4%B9%8Bpixel4xl%E5%88%B7%E6%9C%BAandroid12/:0:0","tags":["android","AOSP"],"title":"AOSP之Pixel4XL刷机Android12","uri":"/posts/aosp%E4%B9%8Bpixel4xl%E5%88%B7%E6%9C%BAandroid12/"},{"categories":["android","AOSP"],"content":"1.编译准备 安装系统: Ubuntu 22.04 LTS 编译版本: Android 12.1.0 物理机配置: CPU10900K 32GB内存, 1T硬盘, 16G虚拟内存 题外话: 主力机一直都是mac, 但是mac编译真的是崩溃, 况且从2021,6,22起, MacOS已经不被支持了,所以还不如搞个固态安一个Ubuntu比较省心 关于mac系统Docker安装Ubuntu来进行编译, 特别慢,不推荐, 性能都不如10400 unRaid虚拟机跑Ubuntu快. 内存的话官方要求最低16GB, 但是在使用的过程中本身32G物理+2G虚拟内存仍然在不同进度时会报错停止. 后来把虚拟内存扩容到了16G, 在编译时就没再报过内存错误. 峰值使用如下图 硬盘的话, 我认为Android12最低要有200G, 建议500GB, 越多越好, 如果是200G不到可能需要删除一些不需要文件 以android12.1.0和20220705全部代码为例子 指定版本拉取 拉取aosp全部代码 .repo 68GB 200GB sync检出后 150GB(+75GB) 300GB make编译后 415GB 所以如果硬盘就是很小, 并且也没有后续更新拉取代码的需求, 那么在sync同步检出后 .repo文件夹就可以删除. 官方环境要求 ","date":"2022-07-25","objectID":"/posts/aosp%E4%B9%8Bandroid12%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E7%BC%96%E8%AF%91/:1:0","tags":["android","AOSP"],"title":"AOSP之Ubuntu22编译Android12源码","uri":"/posts/aosp%E4%B9%8Bandroid12%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E7%BC%96%E8%AF%91/"},{"categories":["android","AOSP"],"content":"开始 ","date":"2022-07-25","objectID":"/posts/aosp%E4%B9%8Bandroid12%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E7%BC%96%E8%AF%91/:2:0","tags":["android","AOSP"],"title":"AOSP之Ubuntu22编译Android12源码","uri":"/posts/aosp%E4%B9%8Bandroid12%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E7%BC%96%E8%AF%91/"},{"categories":["android","AOSP"],"content":"1.仓库拉取前的准备 1.1.安装Git AOSP是一个由众多Git仓库组合而成的代码库 # 安装Git 并设置使用使用者信息 sudo apt-get install git git config --global user.email \"xxxx@qq.com\" git config --global user.name \"xxxx\" 1.2.安装repo工具 repo是一个python编写来管理众多Git的工具 # 创建python3软连接, 20200101停止了对python2的支持 # ubuntu22.04 默认安装3.10.4 ln /usr/bin/python3 /usr/bin/python # 安装下载工具curl sudo apt-get install curl # 下载repo工具 sudo curl https://storage.googleapis.com/git-repo-downloads/repo \u003e /usr/bin/repo # 修改权限 chmod 777 /usr/bin/repo ","date":"2022-07-25","objectID":"/posts/aosp%E4%B9%8Bandroid12%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E7%BC%96%E8%AF%91/:2:1","tags":["android","AOSP"],"title":"AOSP之Ubuntu22编译Android12源码","uri":"/posts/aosp%E4%B9%8Bandroid12%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E7%BC%96%E8%AF%91/"},{"categories":["android","AOSP"],"content":"2.拉取aosp代码 2.1创建文件夹并进入 文件夹的路径中不要包含中文 2.2方式1: 拉取全部代码 增量包方式 下载AOSP源码:清华大学最新AOSP镜像增量包约200GB 仓库拉取方式 更换镜像源,打开 ~/.bashrc添加export REPO_URL=‘https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/' 进入新建文件夹, repo init -u https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest 2.2方式2: 拉取指定代码 仓库拉取方式-指定拉取的版本号 android版本号和支持设备 更换镜像源,打开 ~/.bashrc添加export REPO_URL=‘https://mirrors.tuna.tsinghua.edu.cn/git/git-repo/' 进入新建文件夹, repo init -u https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest -b android-12.0.0_r11 2.3同步检出 下载后解压到新建的文件夹内, 此时只有一个*.repo*的隐藏文件夹 在更目录下执行 repo sync ","date":"2022-07-25","objectID":"/posts/aosp%E4%B9%8Bandroid12%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E7%BC%96%E8%AF%91/:2:2","tags":["android","AOSP"],"title":"AOSP之Ubuntu22编译Android12源码","uri":"/posts/aosp%E4%B9%8Bandroid12%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E7%BC%96%E8%AF%91/"},{"categories":["android","AOSP"],"content":"3.make编译 3.1编译环境准备 后续如果单编需要使用JDK11, 所以这里直接安装版本11 # 安装jdk sudo apt-get update sudo apt-get install openjdk-11-jdk # 安装依赖包 sudo apt-get install git-core gnupg flex bison gperf build-essential zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev ccache libgl1-mesa-dev libxml2-utils xsltproc unzip libncurses5 3.2开始编译 # 初始化 source build/envsetup.sh # 删除之前的编译产出 make clobber # 选择编译版本(模拟器版本) lunch sdk_phone_x86_64 # 如果是要编译真机等其他版本, 使用lunch进行交互选择 lunch # 开始编译 (-j10 可以指定执行线程, 默认自动分配) make # 编译成功后 执行模拟器 emulator ","date":"2022-07-25","objectID":"/posts/aosp%E4%B9%8Bandroid12%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E7%BC%96%E8%AF%91/:2:3","tags":["android","AOSP"],"title":"AOSP之Ubuntu22编译Android12源码","uri":"/posts/aosp%E4%B9%8Bandroid12%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E7%BC%96%E8%AF%91/"},{"categories":["android","AOSP"],"content":"遇见的问题 sync错误, not found 方法1: 在repo sync检出时, error: in sync: revision master in platform/libcore not found 尝试单独更新一下问题目录: repo sync platform/libcore 方法2: 清除下载失败的文件, 自行增加或者替换要删除的文件路径 删除失败的.git仓库rm rf .repo/projects/libcore.git 删除失败的已经检出的代码 rm rf libcore 重新repo sync make时报错:error while loading shared libraries: libncurses.so.5 详细报错: prebuilts/clang/host/linux-x86/clang-3289846/bin/clang.real: error while loading shared libraries: libncurses.so.5: cannot open shared object file: No such file or directory 处理方案: sudo apt-get install libncurses5 make时报错ninja: build stopped: subcommand failed. 详细报错: FAILED: out/soong/build.ninja out/soong/.bootstrap/bin/soong_build -t -b out/soong -d out/soong/build.ninja.d -o out/soong/build.ninja Android.bp Killed ninja: build stopped: subcommand failed. 10:16:29 soong failed with: exit status 1 处理方案: 本人增大虚拟机内存后无此错误. ","date":"2022-07-25","objectID":"/posts/aosp%E4%B9%8Bandroid12%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E7%BC%96%E8%AF%91/:2:4","tags":["android","AOSP"],"title":"AOSP之Ubuntu22编译Android12源码","uri":"/posts/aosp%E4%B9%8Bandroid12%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E7%BC%96%E8%AF%91/"},{"categories":["android","AOSP"],"content":"参考链接 repo介绍 repo官网介绍 Ubuntu增大虚拟内存 AOSP清华大学镜像说明 源码单编 ","date":"2022-07-25","objectID":"/posts/aosp%E4%B9%8Bandroid12%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E7%BC%96%E8%AF%91/:2:5","tags":["android","AOSP"],"title":"AOSP之Ubuntu22编译Android12源码","uri":"/posts/aosp%E4%B9%8Bandroid12%E6%BA%90%E7%A0%81%E4%B8%8B%E8%BD%BD%E7%BC%96%E8%AF%91/"},{"categories":["自动化","android"],"content":" Jenkins部署Android篇-1.Mac安装Jenkins Jenkins部署Android篇-2.Jenkins使用Github的Webhooks Jenkins部署Android篇-3.构建完整Android自动化流程 Jenkins部署Android篇-4.Pipeline流水线 ","date":"2022-03-14","objectID":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E5%9B%9B%E4%B9%8Bpipeline%E6%B5%81%E6%B0%B4%E7%BA%BF/:0:0","tags":["自动化","android"],"title":"Jenkins部署Android篇4之Pipeline流水线","uri":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E5%9B%9B%E4%B9%8Bpipeline%E6%B5%81%E6%B0%B4%E7%BA%BF/"},{"categories":["自动化","android"],"content":"为什么用流水线 前面三篇基于自由风格的类型Job创建的构建任务. 虽然已经可以实现了从构建, 打包, 上传, 通知. 但是这个步骤却只针对某一个分支(或者多个分支). 也就是无法根据不同分支处理不同逻辑任务. 只能针对分支再创建一个Job任务 而流水线(Pipeline) 让之前页面编辑构建流程, 变成了编写代码去构建. 通过进行一个个任务块编写组成一个大的构建流程. 并且查看构建过程,结果更加直观. 例如下面图片就是, 流水线的构建结果展示: 每个步骤清晰可见. 流水线 有两种方式实现方式: 声明式流水线: 通过在任务界面的添加代码 SCM: 通过仓库根目录的Jenkinsfile文件来执行任务. 稍微整理下, 要做什么样的自动化. master分支: 构建项目-\u003e打包(Release)-\u003e多渠道-\u003e上传蒲公英-\u003e上传FTP服务器归档-\u003e邮件通知(发版) sandbox分支: 构建项目-\u003e打包(Sandbox)-\u003e上传蒲公英-\u003e邮件通知(通知测试人员) dev分支: 构建项目-\u003e打包(Debug)-\u003e上传蒲公英-\u003e邮件通知(通知测试,产品,UI人员) 其他分支: 不处理 master分支: 主要保留线上版本代码 sandbox分支: 进行预上线环境测试和发布包区别就是log可以输出, 其余一样, (主要检测线上服务器是否有异常, 混淆是否存在问题, 只需产品测试) dev分支: 开发环境测试, 提测后需要UI,产品,测试多方审查 其他分支: 开发基于dev检出创建其他分支开发迭代. 以上步骤因公司而异, 那么流程步骤确定了, 就选择实现方式, 这里选择SCM也就是每个分支下的代码仓库都存在一个Jenkinsfile文件来声明自己构建逻辑. 但这样有个问题, 运维如果需要进行构建的修改, 那么可能也需要频繁的操作开发人员代码仓库, 并且有些步骤任务其实是通用的, 每个文件都声明一个方法, 不利于后期更改. 所以这里选择扩展共享库 扩展共享库: 就是把所有的构建任务细节提取到另一仓库, 并封装成一个个任务方法, 而代码仓库只要选择需要的任务进行组序执行即可. 大体流程: 如下 没了… 没啥具体实现 ","date":"2022-03-14","objectID":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E5%9B%9B%E4%B9%8Bpipeline%E6%B5%81%E6%B0%B4%E7%BA%BF/:1:0","tags":["自动化","android"],"title":"Jenkins部署Android篇4之Pipeline流水线","uri":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E5%9B%9B%E4%B9%8Bpipeline%E6%B5%81%E6%B0%B4%E7%BA%BF/"},{"categories":["自动化","android"],"content":"整理Docker安装Jenkin Android所需要的大体步骤 是大体步骤, 详细配置前三篇都有. 安装Blue Ocean镜像 docker run -d -p 11006:8080 // 设置外部访问接口为11006 -p 11007:50000 -v /etc/localtime:/etc/localtime // 设置时区 -e TZ=\"Asia/Shanghai\" -v /var/run/docker.sock:/var/run/docker.sock -v /Users/suzeyu/Documents/workspace/docker/jenkins_mount/jenkins:/var/jenkins_home // 挂载镜像工作目录为本地电脑的Jenkins文件夹 -v /Users/suzeyu/Library/Android:/usr/local/android // 挂载Android SDK -v /Users/suzeyu/.gradle/wrapper/dists:/usr/local/gradle // 挂载Gradle --name jenkinsblue jenkinsci/blueocean // 设置别名并安装 打开Jenkins网页localhost:11006,并重置密码,安装推荐插件, 设置账户 进入到首页, 继续安装其他需要的插件. 如下 插件名称 插件功能 Android Signing android打包签名 Build Name and Description Setter 优化Job的任务名字 Build Timestamp 时间格式化插件 build user vars 优化Job的任务名字 Date Parameter 时间参数 description setter Email Extension 邮件通知 Generic Webhook git钩子 Multibranch Scan Webhook Trigger git钩子 Publish Over FTP 上传其他文件服务器 Upload to pgyer 蒲公英上传apk 系统管理 -\u003e 全局工具配置 JDK环境 内置的openJdk(/opt/java/openjdk), 本地都可以 Git环境 内置的(/usr/bin/git), 本地都可以 Gradle环境 系统管理 -\u003e Manage Credentials(凭据) 这一步主要设置访问Git仓库的凭据, 和设置apk签名文件, 和邮箱通知的凭据 需要两个Git仓库 一个项目代码仓库 一个SCM流水线构建流程仓库 需要一个签名文件 需要一个邮箱 Username with password类型, 创建邮箱凭据 Certificate类型, 创建apk签名文件凭据 Secret text类型, git仓库访问 Username with passwordt类型, git仓库访问(https方式, 也可以添加ssh使用ssh方式操作) 系统管理 –\u003e 全局安全设置 标记格式器选择为:Safe HTML 系统管理 –\u003e 系统配置 修改Jenkins URL 添加系统管理员邮件地址 全局属性中的环境变量添加Android SDK GitHub服务器添加token的Certificate类型凭据(不使用github不需要添加) Global Pipeline Libraries 添加流水线使用的共享仓库 Extended E-mail Notification 设置邮件通知发送者 Publish over FTP 设置上传文件到服务器配置 新建流水线任务 必要的设置: 分支源: 添加代码仓库地址 扫描多分支流水线触发器的Scan by webhook 设置源代码仓库的钩子监听 如果项目代码分支存在Jenkinsfile文件, 那么就会被添加进来, 共享扩展库如果没问题那么就可以构建 ","date":"2022-03-14","objectID":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E5%9B%9B%E4%B9%8Bpipeline%E6%B5%81%E6%B0%B4%E7%BA%BF/:2:0","tags":["自动化","android"],"title":"Jenkins部署Android篇4之Pipeline流水线","uri":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E5%9B%9B%E4%B9%8Bpipeline%E6%B5%81%E6%B0%B4%E7%BA%BF/"},{"categories":["自动化","android"],"content":" Jenkins部署Android篇-1.Mac安装Jenkins Jenkins部署Android篇-2.Jenkins使用Github的Webhooks Jenkins部署Android篇-3.构建完整Android自动化流程 Jenkins部署Android篇-4.Pipeline流水线 前面的章节完成了环境的搭建, 并且利用WebHook监听Github的分支变化. 接下来针对构建过程和结果的完善. ","date":"2022-03-13","objectID":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%89%E4%B9%8B%E6%9E%84%E5%BB%BA%E5%AE%8C%E6%95%B4android%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%81%E7%A8%8B/:0:0","tags":["自动化","android"],"title":"Jenkins部署Android篇3之构建完整Android自动化流程","uri":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%89%E4%B9%8B%E6%9E%84%E5%BB%BA%E5%AE%8C%E6%95%B4android%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%81%E7%A8%8B/"},{"categories":["自动化","android"],"content":"增加构建类型选项 之前构建命令assembleDebug是写死. Jenkins构建也只能构建Debug类型. 而正式开发中可能需要3个或者更多的BuildType类型来控制全局的不同常量.例如 Debug: 测试环境: true, Log开关: true Sandbox: 测试环境: false, Log开关: true Release: 测试环境: false, Log开关: false AutoLogin: 自动登陆账户等.. 新建一个任务. General 添加了一个构建前的选项参数里面设置了三个build环境(Release为默认值) 源码管理 添加Repository URL 设置分支 构建 这里assemble的命令变成了动态. 设置之后就可以应用, 保存.回到新建任务页码可以看到构建的时候出现了选项. 选个Release测试一下, 别忘了在项目代码中app/build.gradle文件中添加对应的buildTypes类型. 测试结果: ","date":"2022-03-13","objectID":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%89%E4%B9%8B%E6%9E%84%E5%BB%BA%E5%AE%8C%E6%95%B4android%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%81%E7%A8%8B/:1:0","tags":["自动化","android"],"title":"Jenkins部署Android篇3之构建完整Android自动化流程","uri":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%89%E4%B9%8B%E6%9E%84%E5%BB%BA%E5%AE%8C%E6%95%B4android%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%81%E7%A8%8B/"},{"categories":["自动化","android"],"content":"添加Android签名 现在Jenkins可以自由的控制部署不同环境的安装包. 但是生成的包都是未签名的. 之前我们都是把signingConfigs {sign {…}} 放在build.gradle文件中, 相关的密码信息也存在项目代码中. 更好的做法应该分离开来. 签名文件和相关信息由自动化管理, 这样更加安全合理. ","date":"2022-03-13","objectID":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%89%E4%B9%8B%E6%9E%84%E5%BB%BA%E5%AE%8C%E6%95%B4android%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%81%E7%A8%8B/:2:0","tags":["自动化","android"],"title":"Jenkins部署Android篇3之构建完整Android自动化流程","uri":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%89%E4%B9%8B%E6%9E%84%E5%BB%BA%E5%AE%8C%E6%95%B4android%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%81%E7%A8%8B/"},{"categories":["自动化","android"],"content":"1.添加Android sign插件 系统管理 -\u003e 插件管理 -\u003e 可选插件 -\u003e 搜索: Android Signing Plugin -\u003e 安装 ","date":"2022-03-13","objectID":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%89%E4%B9%8B%E6%9E%84%E5%BB%BA%E5%AE%8C%E6%95%B4android%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%81%E7%A8%8B/:2:1","tags":["自动化","android"],"title":"Jenkins部署Android篇3之构建完整Android自动化流程","uri":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%89%E4%B9%8B%E6%9E%84%E5%BB%BA%E5%AE%8C%E6%95%B4android%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%81%E7%A8%8B/"},{"categories":["自动化","android"],"content":"2.上传keyStore文件 系统管理 -\u003e Manage Credentials -\u003e 全局凭据 -\u003e 添加凭据 -\u003e 安装 选择Certificate类型 上传jks签名文件 输入签名文件密码 添加描述 确定 ","date":"2022-03-13","objectID":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%89%E4%B9%8B%E6%9E%84%E5%BB%BA%E5%AE%8C%E6%95%B4android%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%81%E7%A8%8B/:2:2","tags":["自动化","android"],"title":"Jenkins部署Android篇3之构建完整Android自动化流程","uri":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%89%E4%B9%8B%E6%9E%84%E5%BB%BA%E5%AE%8C%E6%95%B4android%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%81%E7%A8%8B/"},{"categories":["自动化","android"],"content":"在Job中添加sign插件 回到Job的配置页面. 点击 构建 -\u003e 选择当前区域的增加构建步骤 -\u003e Sign Android APKs keyStore: 如果只有一个凭据就默认选择了. APKs to Sign: 对什么文件进行签名 两个checkBox表示是否用于最终显示 重新构建Job, 查看工作空间, 已经有了签名的apk 可以测试一下apk签名文件结果 下载apk, 解压, 打开META-INF文件夹找到 .RSA 结尾文件. keytool -printcert -file RSA文件的路径 查看签名信息 ","date":"2022-03-13","objectID":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%89%E4%B9%8B%E6%9E%84%E5%BB%BA%E5%AE%8C%E6%95%B4android%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%81%E7%A8%8B/:2:3","tags":["自动化","android"],"title":"Jenkins部署Android篇3之构建完整Android自动化流程","uri":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%89%E4%B9%8B%E6%9E%84%E5%BB%BA%E5%AE%8C%E6%95%B4android%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%81%E7%A8%8B/"},{"categories":["自动化","android"],"content":"动态设置输出apk文件名 对于output后的apk文件名, 一般都会自定义成项目名称+版本号+版本环境+时间.apk, 但这些都是在build.gradle代码写死的. 现在可以通过Jenkins的任务界面随意设置要生成规格格式. 原理: Jenkins任务构建时可以注入并替换gradle.property中的变量, 通过Android项目中的applicationVariants.all{} 预留占位字段达到由 Jenkins 控制输出文件名. 目标: 项目名称 + 版本号 + 版本环境 + 占位.apk 这里版本号, 版本环境, 项目内自动获取. 进入Jenkins的任务的配置, 追加3个参数. 并且在构建-\u003eInvoke Gradle Script-\u003e高级-\u003e勾选:Pass all job parameters as Project properties选项 在项目代码的gradle.properties文件中添加三个字段: APK_NAME = Code IS_JENKINS = false PLACE_HOLDER = '' 在app/build.gradle文件中android{}域中添加自定义apk名称方法 // 定义编译生成的apk名格式 applicationVariants.all { variant -\u003e variant.outputs.each { output -\u003e def newName if ('true' == IS_JENKINS) { println(\"jenkins build ==\u003e $BUILD_TIME\") newName = \"$APK_NAME-v${defaultConfig.versionName}-${variant.buildType.name}-${PLACE_HOLDER}-unsigned.apk\" } else { if ('debug' == variant.buildType.name) { newName = \"$APK_NAME-v${defaultConfig.versionName}-${defaultConfig.versionCode}-debug.apk\" } else { newName = \"$APK_NAME-v${defaultConfig.versionName}-${defaultConfig.versionCode}-${variant.buildType.name}.apk\" } } output.outputFileName newName } } “$APK_NAME-v${defaultConfig.versionName}-${variant.buildType.name}-${PLACE_HOLDER}-unsigned.apk” 如果注入成功,最终名字应该是如上. 如果想追加时间: 可以使用Date Parameter Plugin插件添加 ","date":"2022-03-13","objectID":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%89%E4%B9%8B%E6%9E%84%E5%BB%BA%E5%AE%8C%E6%95%B4android%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%81%E7%A8%8B/:2:4","tags":["自动化","android"],"title":"Jenkins部署Android篇3之构建完整Android自动化流程","uri":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%89%E4%B9%8B%E6%9E%84%E5%BB%BA%E5%AE%8C%E6%95%B4android%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%81%E7%A8%8B/"},{"categories":["自动化","android"],"content":"美化build任务名称(可选) 默认的build任务名称都是#1 #2这种 添加插件: user build vars plugin 获取jenkins用户名及id，引用：${BUILD_USER} Build Timestamp BUILD_TIMESTAMP Build Name and Description Setter 在“构建环境”块中添加“set build name”设置在编译时\"build history\"中显示构建信息 修改Job配置 再次运行项目, 结果如下: ","date":"2022-03-13","objectID":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%89%E4%B9%8B%E6%9E%84%E5%BB%BA%E5%AE%8C%E6%95%B4android%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%81%E7%A8%8B/:2:5","tags":["自动化","android"],"title":"Jenkins部署Android篇3之构建完整Android自动化流程","uri":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%89%E4%B9%8B%E6%9E%84%E5%BB%BA%E5%AE%8C%E6%95%B4android%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%81%E7%A8%8B/"},{"categories":["自动化","android"],"content":"上传蒲公英 上传蒲公英, 生成下载地址, 生成二维码图片, 方便邮件推送给其他人. 安装蒲公英插件Upload to pgyer 回到job的配置页面, 选择构建后操作, 添加Upload to pgyer with apiV2 api_key: 填写蒲公英的api_key scandir: 要上传的apk的目录 file wilcard: 要上传的文件名 当上传之后, 蒲公英提供了一系列参数供我们使用. 如下: 那我们可以给build任务, 继续丰富展示内容. 添加set build description插件description setter plugin 在upload 上传任务之后, 再添加set build description的构建后操作步骤 Description: 保存之后, 进入系统管理 -\u003e 全局安全配置 -\u003e 标记格式器为:SafeHtml 保存, 运行任务. 此时任务历史就变成这样了 ","date":"2022-03-13","objectID":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%89%E4%B9%8B%E6%9E%84%E5%BB%BA%E5%AE%8C%E6%95%B4android%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%81%E7%A8%8B/:2:6","tags":["自动化","android"],"title":"Jenkins部署Android篇3之构建完整Android自动化流程","uri":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%89%E4%B9%8B%E6%9E%84%E5%BB%BA%E5%AE%8C%E6%95%B4android%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%81%E7%A8%8B/"},{"categories":["自动化","android"],"content":"邮箱通知 Editable Email Notification Editable Email Notification 设置邮件通知, 如果没有插件搜索插件Email Extension 这里不用自带的Email通知, 直接下载插件. 因为要通知, 所以肯定需要一个发送者邮件. 这里以163为例子. 首先登陆163邮箱, 开启SMTP 如果是首次开启, 那么就不需要点击新增授权密码, 因为首次开启的时候会给一个Token, 如果已经开启过, 那么点击新增授权密码, 保存Token密码. 回到Jenkins -\u003e 系统管理 -\u003e 系统配置 系统管理员邮箱: 填写邮箱的全路径 SMTP Server: 163邮箱固定为: smtp.163.com SMTP Port: 465 凭据: 点击添加, 创建Username with password类型, 用户名是邮件全路径, 密码为授权的Token. 邮件后缀: 163为 @163.com 然后保存, 回到job配置中, 选择构建后操作, 添加Editable Email Notification 要发送的邮箱, 每个邮箱直接用英文,号隔开 追加一些蒲公英返回的字段, 更多的模板代码可以在网上找到. 应用名称: ${buildName} \u003cbr\u003e 应用版本: ${buildVersion} \u003cbr\u003e 应用大小: ${buildFileSize} \u003cbr\u003e 扫码下载: \u003cbr\u003e \u003ca href=\"${appBuildURL}\"\u003e\u003cimg src=\"${appQRCodeURL}\" width=\"118\" height=\"118\"\u003e\u003c/a\u003e \u003cbr\u003e $DEFAULT_CONTENT 添加一个发送邮件的触发时机, 点击Add Trigger选择Success. 添加发送人Recipient List, 就是当Build成功的时候给list中的邮件发送. 列表中的收件人是这个样子 ","date":"2022-03-13","objectID":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%89%E4%B9%8B%E6%9E%84%E5%BB%BA%E5%AE%8C%E6%95%B4android%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%81%E7%A8%8B/:2:7","tags":["自动化","android"],"title":"Jenkins部署Android篇3之构建完整Android自动化流程","uri":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%89%E4%B9%8B%E6%9E%84%E5%BB%BA%E5%AE%8C%E6%95%B4android%E8%87%AA%E5%8A%A8%E5%8C%96%E6%B5%81%E7%A8%8B/"},{"categories":["自动化","android"],"content":" Jenkins部署Android篇-1.Mac安装Jenkins Jenkins部署Android篇-2.Jenkins使用Github的Webhooks Jenkins部署Android篇-3.构建完整Android自动化流程 Jenkins部署Android篇-4.Pipeline流水线 上一节对Android项目简单的搭建了jenkins环境. 实现了手动拉取仓库代码进行编译, 这一节就是利用WebHook(钩子) 实现当关注的分支有了新的提交自动拉取代码. 真的向自动化部署实现. ","date":"2022-03-12","objectID":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%BA%8C%E4%B9%8Bjenkins%E4%BD%BF%E7%94%A8github%E7%9A%84webhooks/:0:0","tags":["自动化","android"],"title":"Jenkins部署Android篇2之Jenkins使用Github的Webhooks","uri":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%BA%8C%E4%B9%8Bjenkins%E4%BD%BF%E7%94%A8github%E7%9A%84webhooks/"},{"categories":["自动化","android"],"content":"1.确认端口是否正确 如果在系统管理页面出现了反向代理有误, 那么可能是你的前端页面设置和后端配置端口不一致 前端页面设置: 就是访问的页面地址中系统管理的Jenkins Location的Jenkins URL 后台配置: 我这里是Mac通过brew安装,文件路径为: /usr/local/Cellar/jenkins-lts/2.319.3/homebrew.mxcl.jenkins-lts.plist jenkins-lts, 其中/usr/local/Cellar/ 为brew安装的程序保存路径. 其他方式自行查找. 如下: ","date":"2022-03-12","objectID":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%BA%8C%E4%B9%8Bjenkins%E4%BD%BF%E7%94%A8github%E7%9A%84webhooks/:1:0","tags":["自动化","android"],"title":"Jenkins部署Android篇2之Jenkins使用Github的Webhooks","uri":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%BA%8C%E4%B9%8Bjenkins%E4%BD%BF%E7%94%A8github%E7%9A%84webhooks/"},{"categories":["自动化","android"],"content":"2.创建Github钩子指向Jetkins 首先要确保搭建的Jetkins是可以外网访问的, 例如域名+port, 或者IP+port 进入Github的需要绑定项目主页. 选择项目Setting -\u003e Webhooks -\u003e Add webhook 在创建页面, 输入Jetkins的地址+Port+/github-webhook 例如: http://域名:端口/github-webhook/ Content type使用默认的urlencode即可, 如下 ","date":"2022-03-12","objectID":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%BA%8C%E4%B9%8Bjenkins%E4%BD%BF%E7%94%A8github%E7%9A%84webhooks/:2:0","tags":["自动化","android"],"title":"Jenkins部署Android篇2之Jenkins使用Github的Webhooks","uri":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%BA%8C%E4%B9%8Bjenkins%E4%BD%BF%E7%94%A8github%E7%9A%84webhooks/"},{"categories":["自动化","android"],"content":"3.创建一个有对项目操作权限的用户Token GitHub头像处展开列表 -\u003e Setting -\u003e 左侧Developer setting -\u003e personal access token -\u003e 右侧Generate new token 如下 创建Token页面 Note: 名字随便起 Expiration: 创建的token有效期 选择赋予的权限 ","date":"2022-03-12","objectID":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%BA%8C%E4%B9%8Bjenkins%E4%BD%BF%E7%94%A8github%E7%9A%84webhooks/:3:0","tags":["自动化","android"],"title":"Jenkins部署Android篇2之Jenkins使用Github的Webhooks","uri":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%BA%8C%E4%B9%8Bjenkins%E4%BD%BF%E7%94%A8github%E7%9A%84webhooks/"},{"categories":["自动化","android"],"content":"4.配置Jenkins的Git Plugin 新版Jenkins在初始的时候已经默认安装了Git Plugin和相关依赖的Plugin，我们不用在重复进行安装，直接配置即可 进入插件位置: 系统管理 –\u003e 系统设置 –\u003e GitHub –\u003e Add GitHub Sever 相关项目名称 填写: https://api.github.com 创建一个凭据, 选择Secre text类型 Secret字段添写上一步GitHub申请的token Description字段添加一些描述信息 id字段不用填写 选择刚才创建的凭据, 点击连接测试 如果出现验证信息, 那么说明连接成功 应用 保存 ","date":"2022-03-12","objectID":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%BA%8C%E4%B9%8Bjenkins%E4%BD%BF%E7%94%A8github%E7%9A%84webhooks/:4:0","tags":["自动化","android"],"title":"Jenkins部署Android篇2之Jenkins使用Github的Webhooks","uri":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%BA%8C%E4%B9%8Bjenkins%E4%BD%BF%E7%94%A8github%E7%9A%84webhooks/"},{"categories":["自动化","android"],"content":"5.配置任务 继续回到上一节创建的Job. 追加一些设置. 源码管理: 指定分支: 这里确定GitHub远端存在对应分支. 否则后续可能会拉取失败. Repository URL: 如果可以尽量使用SSH连接, HTTPS连接在测试中发现经常error code:128 ","date":"2022-03-12","objectID":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%BA%8C%E4%B9%8Bjenkins%E4%BD%BF%E7%94%A8github%E7%9A%84webhooks/:5:0","tags":["自动化","android"],"title":"Jenkins部署Android篇2之Jenkins使用Github的Webhooks","uri":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%BA%8C%E4%B9%8Bjenkins%E4%BD%BF%E7%94%A8github%E7%9A%84webhooks/"},{"categories":["自动化","android"],"content":"6.测试 对项目进行commit 并push到远程仓库. 这个时候我们进去GitHub项目页面,的WebHook查看钩子推送是否成功. 绿色对钩表示推送并且响应成功, 可以点进去查看历时推送. 然后此时Jenkins收到推送开始自动构建, 如下 ","date":"2022-03-12","objectID":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%BA%8C%E4%B9%8Bjenkins%E4%BD%BF%E7%94%A8github%E7%9A%84webhooks/:6:0","tags":["自动化","android"],"title":"Jenkins部署Android篇2之Jenkins使用Github的Webhooks","uri":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%BA%8C%E4%B9%8Bjenkins%E4%BD%BF%E7%94%A8github%E7%9A%84webhooks/"},{"categories":["自动化","android"],"content":" Jenkins部署Android篇-1.Mac安装Jenkins Jenkins部署Android篇-2.Jenkins使用Github的Webhooks Jenkins部署Android篇-3.构建完整Android自动化流程 Jenkins部署Android篇-4.Pipeline流水线 ","date":"2022-03-11","objectID":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%80%E4%B9%8Bmac%E5%AE%89%E8%A3%85jenkins/:0:0","tags":["自动化","android"],"title":"Jenkins部署Android篇1之Mac安装Jenkins","uri":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%80%E4%B9%8Bmac%E5%AE%89%E8%A3%85jenkins/"},{"categories":["自动化","android"],"content":"安装环境 操作系统: macOS Monterey 12.1 Git: 2.15.0 JDK: 17.0.1 2021-10-19 LTS Gradle: Gradle 7.4 SDK: AndroidStudio指向的Android SDK 准备安装的Jenkins版本为:Jenkins 2.319.3 ","date":"2022-03-11","objectID":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%80%E4%B9%8Bmac%E5%AE%89%E8%A3%85jenkins/:1:0","tags":["自动化","android"],"title":"Jenkins部署Android篇1之Mac安装Jenkins","uri":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%80%E4%B9%8Bmac%E5%AE%89%E8%A3%85jenkins/"},{"categories":["自动化","android"],"content":"开始安装 ","date":"2022-03-11","objectID":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%80%E4%B9%8Bmac%E5%AE%89%E8%A3%85jenkins/:2:0","tags":["自动化","android"],"title":"Jenkins部署Android篇1之Mac安装Jenkins","uri":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%80%E4%B9%8Bmac%E5%AE%89%E8%A3%85jenkins/"},{"categories":["自动化","android"],"content":"1.brew安装jenkins brew install jenkins-lts ","date":"2022-03-11","objectID":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%80%E4%B9%8Bmac%E5%AE%89%E8%A3%85jenkins/:2:1","tags":["自动化","android"],"title":"Jenkins部署Android篇1之Mac安装Jenkins","uri":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%80%E4%B9%8Bmac%E5%AE%89%E8%A3%85jenkins/"},{"categories":["自动化","android"],"content":"2.运行jenkins brew services start jenkins-lts # # 重启 jenkins-lts 服务 # brew services restart jenkins-lts # # 停止 jenkins-lts 服务 # brew services stop jenkins-lts ","date":"2022-03-11","objectID":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%80%E4%B9%8Bmac%E5%AE%89%E8%A3%85jenkins/:2:2","tags":["自动化","android"],"title":"Jenkins部署Android篇1之Mac安装Jenkins","uri":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%80%E4%B9%8Bmac%E5%AE%89%E8%A3%85jenkins/"},{"categories":["自动化","android"],"content":"3.打开 浏览器打开jenkins http://localhost:8080 如果要修改端口: /usr/local/Cellar/jenkins-lts/2.319.3/homebrew.mxcl.jenkins-lts.plist 这是brew安装的路径 注意: 如果要ip或者外网访问, 这个文件这个字段需要这样修改 httpListenAddress=0.0.0.0 ","date":"2022-03-11","objectID":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%80%E4%B9%8Bmac%E5%AE%89%E8%A3%85jenkins/:2:3","tags":["自动化","android"],"title":"Jenkins部署Android篇1之Mac安装Jenkins","uri":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%80%E4%B9%8Bmac%E5%AE%89%E8%A3%85jenkins/"},{"categories":["自动化","android"],"content":"4.重置初始密码 首次进入修改密码.直接命令行获取密码输入,并设置新密码. cat /Users/suzeyu/.jenkins/secrets/initialAdminPassword suzeyu为我的用户名, 这里需要手动替换一下. ","date":"2022-03-11","objectID":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%80%E4%B9%8Bmac%E5%AE%89%E8%A3%85jenkins/:2:4","tags":["自动化","android"],"title":"Jenkins部署Android篇1之Mac安装Jenkins","uri":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%80%E4%B9%8Bmac%E5%AE%89%E8%A3%85jenkins/"},{"categories":["自动化","android"],"content":"5.安装插件 安装基础插件, 新手的话直接安装推荐的插件 ","date":"2022-03-11","objectID":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%80%E4%B9%8Bmac%E5%AE%89%E8%A3%85jenkins/:2:5","tags":["自动化","android"],"title":"Jenkins部署Android篇1之Mac安装Jenkins","uri":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%80%E4%B9%8Bmac%E5%AE%89%E8%A3%85jenkins/"},{"categories":["自动化","android"],"content":"6.配置基础环境 配置 JDK, Git, Gradle路径 别名随便填写, 圈中的路径需要手动添加. 如何获取相关路径? // mac查看jdk命令 $ /usr/libexec/java_home -V // mac查看git命令 $ which git // mac gradle默认根路径-\u003e/Users/suzeyu/.gradle/wrapper/dists/ ","date":"2022-03-11","objectID":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%80%E4%B9%8Bmac%E5%AE%89%E8%A3%85jenkins/:2:6","tags":["自动化","android"],"title":"Jenkins部署Android篇1之Mac安装Jenkins","uri":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%80%E4%B9%8Bmac%E5%AE%89%E8%A3%85jenkins/"},{"categories":["自动化","android"],"content":"7.配置其他编译工具 设置Android编译过程用到的SDK, NDK 这里可以继续添加NDK,Python,cmake等的路径, 为了先搭建成功这里先不添加. ","date":"2022-03-11","objectID":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%80%E4%B9%8Bmac%E5%AE%89%E8%A3%85jenkins/:2:7","tags":["自动化","android"],"title":"Jenkins部署Android篇1之Mac安装Jenkins","uri":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%80%E4%B9%8Bmac%E5%AE%89%E8%A3%85jenkins/"},{"categories":["自动化","android"],"content":"8.创建任务 到这里环境配置完成. 准备创建一个任务. 首页选择新建任务 然后选择确定. ","date":"2022-03-11","objectID":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%80%E4%B9%8Bmac%E5%AE%89%E8%A3%85jenkins/:2:8","tags":["自动化","android"],"title":"Jenkins部署Android篇1之Mac安装Jenkins","uri":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%80%E4%B9%8Bmac%E5%AE%89%E8%A3%85jenkins/"},{"categories":["自动化","android"],"content":"9.配置任务 这里就先配置最基础的. 直接跳到源码管理区域 这里使用的Github仓库, 你要保证这个仓库有android的项目 创建一个账号+密码的凭据. 注意 这个密码是在github生成的一个token, 因为在2021/08/13后为了安全, github不再直接支持账号密码的操作. 需要在github-\u003esetting-\u003eDeveloper setting-\u003ePersonal access tokens-\u003eGenerate new token 具体创建参考别人的详细步骤 指定分支这一栏, 最好再创建一个分支, 然后指定新分支 */dev. 因为github新建仓库有可能初始为main分支, 再后续拉取会失败. 选择构建项目的gradle版本 还是任务的配置界面. 这里为了测试环境搭建是否可用, 先生成debug包. 设置玩之后应用,保存 ","date":"2022-03-11","objectID":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%80%E4%B9%8Bmac%E5%AE%89%E8%A3%85jenkins/:2:9","tags":["自动化","android"],"title":"Jenkins部署Android篇1之Mac安装Jenkins","uri":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%80%E4%B9%8Bmac%E5%AE%89%E8%A3%85jenkins/"},{"categories":["自动化","android"],"content":"10.测试能否成功构建 左下角会显示任务进度, 也可以进入点击进入, 查看log信息. 任务成功后,点击工作空间 最基础的Android构建就完成了. ","date":"2022-03-11","objectID":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%80%E4%B9%8Bmac%E5%AE%89%E8%A3%85jenkins/:2:10","tags":["自动化","android"],"title":"Jenkins部署Android篇1之Mac安装Jenkins","uri":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%80%E4%B9%8Bmac%E5%AE%89%E8%A3%85jenkins/"},{"categories":["自动化","android"],"content":"相关链接 Docker官网 Jenkins官网 Jenkins在Docker Hub下载页面 ","date":"2022-03-11","objectID":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%80%E4%B9%8Bmac%E5%AE%89%E8%A3%85jenkins/:3:0","tags":["自动化","android"],"title":"Jenkins部署Android篇1之Mac安装Jenkins","uri":"/posts/jenkins%E9%83%A8%E7%BD%B2android%E7%AF%87%E4%B8%80%E4%B9%8Bmac%E5%AE%89%E8%A3%85jenkins/"},{"categories":["kotlin"],"content":"泛型 Kotlin中的泛型和Java中的泛型有同有异. 泛型主要有两种定义方式: 定义泛型类 定义泛型方法 例如: // 定义泛型类 class MyClass\u003cT\u003e{ fun method(param: T):T{ return param } } // 定义泛型方法 class MyClass{ fun \u003cT\u003e method(param: T):T{ return param } } 泛型的界限限定 如果想指定泛型只能是数字那么\u003cT : Number\u003e.这样泛型的上界设置就为Number类型. 默认情况下, 所有的泛型都可以指定为可空类型, 因为在不手动设置上界时, 默认都是Any? 泛型的实化 概念: 在Java中的泛型功能是通过类型擦除机制来实现的. 就是泛型的约束只存在编译时期 运行时仍然会按照JDK1.5之前机制运行, JVM是识别不出来我们在代码中指定的泛型类型. 所以像T.class这样语法是无法工作, 因为运行时实际类型已经被擦除. 但是Kotlin提供了内联函数的概念, 内联函数就是会在编译的时候自动替换它调用的地方,这样也就不存在泛型擦除的问题, 因为代码在编译之后会直接使用实际类型来替代内联函数中的泛型声明. 所以泛型实化写法: 函数必须是内联函数 声明泛型的地方必须加上reified关键字, 表示该泛型可以实例化 例如: inline fun \u003creified T\u003e getType() = T::class.java 这行代码实现了java中完全不可能实现的功能: 函数直接返回了当前指定泛型的实际类型. ","date":"2022-03-02","objectID":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%A7%94%E6%89%98infix/:0:1","tags":["kotlin"],"title":"Kotlin基础 泛型,类委托,infix","uri":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%A7%94%E6%89%98infix/"},{"categories":["kotlin"],"content":"类委托和委托属性 委托是一中设计模式, 基本理念: 操作对象自己不会去处理某段逻辑, 而是会把工作委托给另外一个辅助对象去处理. Java中对于委托并没有语言层级的实现, 而C#等语言就对委托进行了原生的支持. Kotlin中也支持委托功能, 并且将委托分为了两种: 类委托和属性委托. 类委托 核心思想就是将一个类的具体实现委托给另一个类. 为什么要委托? 我们想保留一个类的大部分方法, 少部分方法自己重写, 或者加入一些自定义方法, 这就是委托的意义. 但是如果如果要委托的是个接口, 并且接口有很多, 手动实现属实很麻烦, Kotlin中可以通过类委托来解决. 关键字: by 例如: class MySet\u003cT\u003e(val helperSet: HashSet\u003cT\u003e) : Set\u003cT\u003e by helperSet{} by后面接上受委托的辅助对象 属性委托 class MyClass{ var p by Delegate() } 委托属性核心思想是将一个属性字段的具体实现委托给另一个类去完成. 将p属性的具体实现委托给了Delegate类去完成, 当调用p属性时会自动调用Delegate类的getValue(), 赋值时会调用setValue() 因此还需要对Delegate类进行具体实现. class Delegate{ var propValue: Any? = null operator fun getValue(myClass: MyClass, prop: KProperty\u003c*\u003e): Any?{ return propValue } operator fun setValue(myClass: MyClass, prop: KProperty\u003c*\u003e, value: Any?){ propValue = value } } getValue(): 第一个参数声明该Delegate类可以在什么类中使用, 这里的写法表明只能在MyClass中使用. 第二个参数时Kotlin的一个属性操作类, 可用于获取各种属性相关的值. \u003c*\u003e表示你不知道或者不关心泛型的具体类型 setValue(): 前两个与前面都相似, 最后一个参数表示具体要赋值给委托属性的值, 这个参数的类型必须和getValue()返回值保持一致. Kotlin中的懒加载by lazy就是利用了委托 ","date":"2022-03-02","objectID":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%A7%94%E6%89%98infix/:0:2","tags":["kotlin"],"title":"Kotlin基础 泛型,类委托,infix","uri":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%A7%94%E6%89%98infix/"},{"categories":["kotlin"],"content":"infix函数 类似A to B 这种构建键值对的语法. to并非是关键字, 而是Kotlin实现的一个语法糖. infix函数主要是把编程语言函数的调用语法调整了一下. 例如A to B等价于A.to(B). 例如: 包装String#startsWith() infix fun String.beginsWith(prefix: String) = startsWith(prefix) 给String类添加一个扩展函数, 判断字符串是否以参数字符串开头. 使用infix后就可以如下调用: val bol = \"Hello World\" beginsWith \"Hello\" infix 有两个限制: infix 函数不能定义成顶层函数, 它必须是某个类的成员函数, 可以使用扩展函数的方式将它定义到某个类当中 infix 函数必须接收且只能接收一个参数, 至于参数类型是没有限制的. ","date":"2022-03-02","objectID":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%A7%94%E6%89%98infix/:0:3","tags":["kotlin"],"title":"Kotlin基础 泛型,类委托,infix","uri":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%A7%94%E6%89%98infix/"},{"categories":["kotlin"],"content":"高阶函数 一般函数接收的参数有Lambda表达式就可以称为具有函数式编程风格的API, 如果想要定义自己的函数式API, 就需要借助高阶函数. 定义: 如果一个函数接收另一个函数作为参数, 或者返回值类型是另一个函数, 那么就称该函数为高阶函数. 用途: 高阶函数允许让函数类型的参数来决定函数的执行逻辑. 函数类型: 编程语言中有整型, 布尔型等字段类型, 而Kotlin中又增加了函数类型的概念, 如果将这个函数类型添加到一个函数的声明或者返回值声明, 那么这就是一个高阶函数 函数类型语法规则: (String, Int) -\u003e Unit -\u003e 的左边用来声明该函数接收什么参数, 多个参数之间使用逗号隔开, 如果不接收参数那么就是空括号; 右边用来声明该函数的返回值, 没有就是Unit相当于Java中的void. fun example(func: (String, Int) -\u003e Unit){ func(\"Hello\", 111) } 在函数的传参中, 可以函数名字传入方法名(), 也可以使用 ::方法名 . :: 这种写法, 是一种函数引用方式的写法, 表示函数作为参数传递到函数中. // 高阶函数定义 fun example(func: (Int, Int) -\u003e Int): Int { return func(1, 2); } // 高阶函数调用 Lambda表达式 example({ int1, int2 -\u003e int1 + int2 }) // 简化1: 当参数列表最后一个参数为Lambda表达式, 可以移到括号的后面 example(){ int1, int2 -\u003e int1 + int2 } // 简化2: 当参数列表为空时, 可以省略空括号 example{ int1, int2 -\u003e int1 + int2 } 系统apply的实现. 当连续调用同一个对象的多个方法时, apply可以让代码变得更简洁. 以StringBuilder为例 // 定义一个StringBuild扩展函数 fun StringBuilder.build(block: StringBuilder.() -\u003e Unit){ block } // StringBuilder.()表示这个函数类型定义在StringBuilder中, 并且在实现体内会持有上下文对象 // 调用 StringBuilder().build { append(\"Hi\") append(\"Hello\") append(\"world\") } ","date":"2022-03-02","objectID":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E5%92%8C%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/:0:1","tags":["kotlin"],"title":"Kotlin基础 高阶函数和内联函数","uri":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E5%92%8C%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"},{"categories":["kotlin"],"content":"内联函数 Kotlin的代码最终还是要编译成Java的字节码, 但Java中没有高阶函数的概念, 但是通过Kotlin的编译器将高阶函数的语法转换成了Java支持的语法. 比方你定义的函数类型接收两个参数. 那么Kolin转换的时候会把这个函数类型转换成一个Function接口, 这个接口有一个待实现的invoke() 接口并把定义的两个参数传入了进去. 那么问题就出现了, Lambda表达式在调用的时候被底层转化成了匿名内部类的实现, 而匿名内部类每次的新建都会造成额外的开销. 所以为了解决这个为题出现了内联函数的概念. 内联函数使用很简单, 只要在定义的高阶函数前面加上inline 关键字修饰即可. 其实就是编译器将内联函数中的代码在编译的时候自动替换到调用的地方. 先将在调用处的Lambda表达式中的代码,替换到高阶函数定义的实现体内. 这样高阶函数就变成了普通的函数, 没有了函数类型. 再将内联函数中的代码全部替换到调用处 noinline 如果一个函数存在多个函数类型的参数时, 想要某一个函数类型不使用内联函数可以如下: inline fun methodName(block: ()-\u003eUnit, noinline bloack2: () -\u003e Unit){} 内联函数虽然可以解决匿名内部类的问题, 但是由于代码在编译期间的替换, 所以没有真正的参数属性. 非内联的函数类型参数可以自由的传递给其他任何函数, 因为他就是一个真实的参数, 而内联函数类型参数只允许传递给另外一个内联函数, 这就是最大的局限性. 内联函数和非内联函数还有一个区别是, 内联函数所引用的Lambda表达式是可以使用return关键字进行函数返回. 而非内联函数只能进行局部返回. crossinline inline fun runRunnable( block: ()-\u003eUnit){ Runnable{ block() } } // 报错: Can't inline 'block' here: it may contain non-local returns. Add 'crossinline' modifier to parameter declaration 'block' 报错是因为Runnable对象创建的Lambda表达式会在编译的时候转换成匿名内部类的实现方式, 也就是在匿名内部类中调用了传入的函数类型参数. 内联函数所引用的Lambda表达式允许使用return, 但是由于上述代码在匿名内部类中调用了函数类型参数, 此时是不可能进行外层调用函数返回的, 最多只能对匿名内部类中函数返回. 所以出现了上述错误. 这个时候使用crossinline就能解决这个错误提示 inline fun runRunnable(crossinline block: ()-\u003eUnit){...} crossinline就像一个契约, 他能用于保证在内联函数的Lambda表达式中一定不会使用return关键字, 这样就不存在冲突. 声明了交叉函数后, 就不能在调用runRunnable() 函数时的Lambda表达式中使用return关键字, 但是任然可以使用return@runRunnable写法进行局部返回. ","date":"2022-03-02","objectID":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E5%92%8C%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/:0:2","tags":["kotlin"],"title":"Kotlin基础 高阶函数和内联函数","uri":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E5%92%8C%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0/"},{"categories":["kotlin"],"content":"延迟初始化 由于Kotlin中严格判空机制. 对于一些全局变量声明为 ? 可空类型, 先赋值null. 然后再合适的时机再进行创建赋值, 这个时候又需要判断非空. 由于这些零碎的步骤, lateinit关键字就为此而生. 延迟初始化lateinit , 它可以让编译器再晚些时候进行赋值, 而不需要在声明的时候就必需赋值为null private lateinit var adapter: RecyclerAdapter 因为你明确使用了延迟加载, 在后续调用你必需能保证已经在所有调用前完成了赋值. 否则会出现UninitializedPropertyAccessException异常 为了避免重复的赋值, Kotlin提供了判断是否初始化的判断. ::Filed.isInitialized ","date":"2022-03-02","objectID":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E5%AF%86%E5%B0%81%E7%B1%BB%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/:0:1","tags":["kotlin"],"title":"Kotlin基础 密封类,扩展函数,运算符重载","uri":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E5%AF%86%E5%B0%81%E7%B1%BB%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"},{"categories":["kotlin"],"content":"密封类 当使用when处理分支情况时, 如果传入的是一个状态接口, 通常要处理成功, 失败, 还有一个其他情况. 而其他情况其实根本不会存在. 这个时候可以使用密封类. Kotlin编译器会自动检查密封类有哪些子类, 并强制要求你的每一个子类所对应的条件全部处理. 密封类的关键字sealed class. 修饰类名 场景: RecyclerView#onBindViewHolder() 中处理多个类型的ViewHolder时, 使用密封类可以去除无必要的else语句, 让代码更规范. ","date":"2022-03-02","objectID":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E5%AF%86%E5%B0%81%E7%B1%BB%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/:0:2","tags":["kotlin"],"title":"Kotlin基础 密封类,扩展函数,运算符重载","uri":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E5%AF%86%E5%B0%81%E7%B1%BB%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"},{"categories":["kotlin"],"content":"扩展函数 扩展函数表示即使在不修改某个类的源码的情况下, 仍然可以打开这个类,向这个类添加新的函数. 在Java中, 项目中有许多的自建的Utils. 比如需要一个判断一个字符串是否是手机号时. 通常我们要创建一个StringUtils类然后添加判断方法. 其实这个判断手机号的方法应该属于String类中. 但是由于String类是Final类型, 不能复写继承. 而扩展函数却解决了这个问题. fun String.isPhone(): boolean{ // ... } 代码表示向String类中添加一个isPhone() 的函数. 后续使用时 字符串.isPhone() 即可 \"13888887777\".isPhone() ","date":"2022-03-02","objectID":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E5%AF%86%E5%B0%81%E7%B1%BB%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/:0:3","tags":["kotlin"],"title":"Kotlin基础 密封类,扩展函数,运算符重载","uri":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E5%AF%86%E5%B0%81%E7%B1%BB%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"},{"categories":["kotlin"],"content":"运算符重载 Java中有许多的内置运算符关键字 +,-,/, % 等, 而Kotlin允许将所有的运算符甚至其他的关键字进行重载, 从而扩展这些运算符合关键字的用法. 比方每个图书对象都有书名和价格的属性. 那么就可以使用运算法重载, 让两个图书对象+, 得出书的总价. 运算符重载使用的是operator关键字, 只要在指定的函数前面加上即可. 而指定的函数如下: 语法糖表达式 实际调用函数 a + b a.plus(b) a - b a.minus(b) a * b a.times(b) a / b a.div(b) a % b a.rem(b) a– a.dec() a++ a.inc() +a a.unaryPlus() -a a.unaryMinus() !a a.not() a == b a.equals(b) a \u003e b (\u003c, \u003e=, \u003c=) a.compareTo(b) a..b a.rangeTo(b) a[b] a.get(b) a[b] = c a.set(b,c) a in b b.contains(a) class Book(val name: String, val price: Float){ // 重载+运算 operator fun plus(book: Book): Float{ return price + book.price; } } fun main(args: Array\u003cString\u003e){ val book1 = Book(\"西游记\", 100.0f) val book2 = Book(\"水浒传\", 90.0f) println(book1 + book2) // println: 190.0 } Kotlin中**String#contains()**就进行了重载, if(\"Hi, Jack\".contains(\"Jack\")){} // 使用语法糖 if(\"Jack\" in \"Hi, Jack\"){} ","date":"2022-03-02","objectID":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E5%AF%86%E5%B0%81%E7%B1%BB%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/:0:4","tags":["kotlin"],"title":"Kotlin基础 密封类,扩展函数,运算符重载","uri":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E5%AF%86%E5%B0%81%E7%B1%BB%E6%89%A9%E5%B1%95%E5%87%BD%E6%95%B0%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD/"},{"categories":["kotlin"],"content":"标准函数 Kotlin的标准函数定义在Standard.kt文件中的函数. 任何Kotlin代码都能调用标准函数 ","date":"2022-02-15","objectID":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E6%A0%87%E5%87%86%E5%87%BD%E6%95%B0%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/:1:0","tags":["kotlin"],"title":"Kotlin基础 标准函数和静态方法","uri":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E6%A0%87%E5%87%86%E5%87%BD%E6%95%B0%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/"},{"categories":["kotlin"],"content":"let标准函数 可以用来配合**?.**进行辅助判空处理 // 使用?.代替if的判断语句, 并使用let让lambda函数体内存在list的上下文it list?.let { it.add(\"1\") it.add(\"2\") } ","date":"2022-02-15","objectID":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E6%A0%87%E5%87%86%E5%87%BD%E6%95%B0%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/:1:1","tags":["kotlin"],"title":"Kotlin基础 标准函数和静态方法","uri":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E6%A0%87%E5%87%86%E5%87%BD%E6%95%B0%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/"},{"categories":["kotlin"],"content":"with标准函数 场景: 在java中使用StringBuilder时, 在拼接经常出现sb.xxx sb.xxx这样的语句. 此函数可以简化StringBuild对象的频繁敲打. with函数接收两个参数, 第一个参数为任意类型; 第二个参数Lambda表达式, 并在表达式中提供第一个参数的上下文. val sb = StringBuilder() val studentStr = with(sb) { append(\"开始输入成绩\") // sb.append()省略了sb. 以下如是 for (student in list) { append(student.name) } append(\"输入结束.\") toString() // 最后一行作为返回值 } ","date":"2022-02-15","objectID":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E6%A0%87%E5%87%86%E5%87%BD%E6%95%B0%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/:1:2","tags":["kotlin"],"title":"Kotlin基础 标准函数和静态方法","uri":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E6%A0%87%E5%87%86%E5%87%BD%E6%95%B0%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/"},{"categories":["kotlin"],"content":"run标准函数 与with相似, with是直接调用的, 而run是任意对象调用的. 并且参数只有一个Lambda函数体 val sb = StringBuilder() val studentStr =sb.run { append(\"开始输入成绩\") for (student in list) { append(student.name) } append(\"输入结束.\") toString() } ","date":"2022-02-15","objectID":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E6%A0%87%E5%87%86%E5%87%BD%E6%95%B0%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/:1:3","tags":["kotlin"],"title":"Kotlin基础 标准函数和静态方法","uri":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E6%A0%87%E5%87%86%E5%87%BD%E6%95%B0%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/"},{"categories":["kotlin"],"content":"apply标准函数 与run一样, 不过apply返回值只能返回调用者本身. 适用类型Android创建Intent进行一系列传参. ","date":"2022-02-15","objectID":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E6%A0%87%E5%87%86%E5%87%BD%E6%95%B0%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/:1:4","tags":["kotlin"],"title":"Kotlin基础 标准函数和静态方法","uri":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E6%A0%87%E5%87%86%E5%87%BD%E6%95%B0%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/"},{"categories":["kotlin"],"content":"静态方法 Kotlin中弱化了静态方法这个概念, 因为Kotlin提供了比静态方法更好用得特性-单例类. 使用Object关键字声明类为单例, 充当Java中的工具类, 由于语法糖的关系, 在调用时同样是类名.函数() 如果只想一个普通类中的某一个方法实现静态方法的调用方式, 可以使用 companion object class util{ // 伴生类 companion object{ fuc strWrap(){} } } companion object 关键字会在util类中创建一个伴生类, strWrap()就是这个伴生类的实例方法, Kotlin会保证Util中只有一个伴生类. 所以可以类名.函数()调用 以上都是真正意义上的静态方法, 只是模拟了静态方法的调用方式, 如果必须要实现. Kotlin两种方式: 注解和顶层方法 注解实现 当我们给单例类或者companion object中的方法加上了**@JvmStatic**注解, 那么Kotlin就会将这些方法编译成静态方法. class util{ companion object{ @JvmStatic fuc strWrap(){} } } 顶层方法实现 顶层方法是指没有定义在任何类中的方法. Kotlin会将所有的顶层方法全部编译成静态方法. 创建一个File类型的Kotlin文件. 声明函数. 然后再任何Kotlin中直接函数名调用. 但是如果在Java中调用, 会找不到, 因为Java中没有顶层函数的概念, 所有的方法都必须在类中. 在我们创建名字.kt时, Kotlin会自动创建一个名字kt的Java类. 刚才声明的方式就在其中, 所有就可以通过名字Kt.函数() 来调用 ","date":"2022-02-15","objectID":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E6%A0%87%E5%87%86%E5%87%BD%E6%95%B0%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/:2:0","tags":["kotlin"],"title":"Kotlin基础 标准函数和静态方法","uri":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E6%A0%87%E5%87%86%E5%87%BD%E6%95%B0%E5%92%8C%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95/"},{"categories":["kotlin"],"content":" 2011年JetBrains发布了Kotlin第一个版本; 2016年Kotlin发布了1.0正式版; 2017年Google宣布Kotlin成为Android一级开发语言. ","date":"2022-02-15","objectID":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E8%AF%AD%E6%B3%95/:0:0","tags":["kotlin"],"title":"Kotlin基础-语法","uri":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E8%AF%AD%E6%B3%95/"},{"categories":["kotlin"],"content":"基础知识 ","date":"2022-02-15","objectID":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E8%AF%AD%E6%B3%95/:1:0","tags":["kotlin"],"title":"Kotlin基础-语法","uri":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E8%AF%AD%E6%B3%95/"},{"categories":["kotlin"],"content":"变量(varaibale) val(value)用来声明一个不可变的变量, 对应Java中的Final. var(variable)用来声明一个可变的变量, 对应Java中的非Final. // 完整的变量声明例子 val a: Int = 10 // Kotlin具有类型推导机制, 可以简化 val a = 10 Kotlin取消了Java的基本数据类型, 全部使用对象数据类型. ","date":"2022-02-15","objectID":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E8%AF%AD%E6%B3%95/:1:1","tags":["kotlin"],"title":"Kotlin基础-语法","uri":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E8%AF%AD%E6%B3%95/"},{"categories":["kotlin"],"content":"函数(function) Java中多数称为方法(method). 声明方法需要fun关键字. // 函数的创建语法. fun 函数名称(参数1: 参数类型, 参数2: 参数类型): 返回值 { return 返回值 } // 示例 完整版 fun largerNumber(num1: Int, num2: Int): Int { return max(num1, num2) } // Kotlin语法糖 // 当函数体只有一行代码时, 可以省略函数体{}, 将唯一一行代码 // 定义到函数声明的尾部, 并用=连接 fun largerNumber(num1: Int, num2: Int) : Int = max(num2, num1) // 由于推导机制, 返回值声明可以省略. fun largerNumber(num1: Int, num2: Int) = max(num2, num1) // 函数支持默认值, 上面函数可以添加默认 fun largerNumber(num1: Int = 1, num2: Int = 2) = max(num2, num1) ","date":"2022-02-15","objectID":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E8%AF%AD%E6%B3%95/:1:2","tags":["kotlin"],"title":"Kotlin基础-语法","uri":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E8%AF%AD%E6%B3%95/"},{"categories":["kotlin"],"content":"逻辑控制语句 if条件语句 Kotlin的条件语句有两种: if, when if语句和Java中的if几乎一模一样. 但Kotlin的if支持返回值, 就是每个条件的最后一行代码作为返回值. when语句类似Java中的switch. 但不仅局限与Java的只能整型, 短整型,字符串 // when语法结构 when(变量){ 匹配值 -\u003e {执行逻辑} 匹配值 -\u003e {执行逻辑} } // 示例 when(name){ \"张三\" -\u003e {\"20岁\"} \"李四\" -\u003e {\"21岁\"} \"王五\" -\u003e {\"22岁\"} } // 简化, 由于和if一样, 函数体最后一句最为返回值, 并且函数体只有一行代码 // 可以省略{} when(name){ \"张三\" -\u003e \"20岁\" \"李四\" -\u003e \"21岁\" \"王五\" -\u003e \"22岁\" } 循环语句 while 与Java没有区别 for 舍弃了Java中的for-i循环, 对Java中的for-each进行增强, 并变成了for-in循环 区间概念: 正是由于没有了for-i的变量控制条件,才出现了区间概念 // 创建一个0到100的区间 var range = 0..100 // 以上代码意思是. 一个0到100的区间, 并且两端都是闭区间, 也就是包含0和100.等价于数学中的 // [0,100] // for-in 升序 for (i in 1..100){ println(i) } // 每次循环自增2 for (i in 1..100 step){ println(i) } ","date":"2022-02-15","objectID":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E8%AF%AD%E6%B3%95/:1:3","tags":["kotlin"],"title":"Kotlin基础-语法","uri":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E8%AF%AD%E6%B3%95/"},{"categories":["kotlin"],"content":"类和对象 Class 类, 同Java File 通常用于编写Kotlin的顶层函数和扩展函数 Interface 接口, 同Java Enum class 枚举类 Object 数据类 // 创建一个class类 class Person{ } // 获取Person示例, 不需要new var person = Person() 继承与构造函数 在Kotlin中任何一个非抽象类默认都是不可被继承的, 相当于Java中的String类添加了final关键字一样. 就如Effective java中提到的, 如果一个类不是为了专门继承而设计的, 就应该主动加上final. 而Kotlin把默认实现修改到final模式 那么如果要想一个类被继承, 使用open来修饰类. open class Person{} // Kotiln中使用 : 来代替Java中的extends class Student : Person(){} Kotlin中有两种构造函数: 主构造函数, 次构造函数 一个类只能有一个主构造函数, 但是可以很多个次构造函数. 一个类默认有一个不带参的主构造函数 一个类如果仅有一个次构造函数, 那么此类是没有主构造函数 // 主构造函数 // 每个类默认有一个不带参数的主构造函数 // 主构造函数特点是没有函数体, 只需在类名后显式的指明参数即可 // 如果需要编写构造逻辑, 使用Kotlin提供的init结构体 open class Person(age: Int, name:String){ init { // 构造逻辑 } } // 次构造函数 // 当一个类既有主构造也有次构造, 那么所有的次构造都要调用主构造函数. open class Person(age: Int, name: String) { constructor() : this(11, \"\") { } constructor(age: Int, name: String, sex: Int) : this(age, name) { } } 接口 同样使用**:**来实现接口继承, 并且被继承的类不需要追加括号, 因为接口没有构造函数. 允许对接口中定义的函数进行默认是实现. 这一特性在Java JDK1.8之后也同样支持. 函数可见性修饰符 修饰符 Java Kotlin Public 所有类可见 所有类可见(默认) private 当前类可见 当前类可见 protected 本类,子类,同一包路径可见 当前类,子类可见 default 同一包路径下的可见 无 internal 无 同一模块中的类可见 数据类型与单例类 // 数据类实现 data关键字 // 不再像Java一样需要实现equals(), hashCode(), toString()等方法 data class schoolRool(val name:String, val id:Int) // 单例类 object关键字 object Singleton{ } ","date":"2022-02-15","objectID":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E8%AF%AD%E6%B3%95/:1:4","tags":["kotlin"],"title":"Kotlin基础-语法","uri":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E8%AF%AD%E6%B3%95/"},{"categories":["kotlin"],"content":"集合 使用内置函数listOf简化初始化集合的写法 val list = listOf(\"张三\", \"李四\", \"王五\") 遍历集合 for(person in list){....} listOf() 函数创建的是不可变集合, 即只读不能修改删除. mutableListOf() 函数与之对应, 可变集合. setOf() mutableSetOf() Map Kotlin提供了一中类似数组下标的语法结构提供读写. val map = mutableMapOf(\"张三\" to 1, \"李四\" to 2) map[\"王五\"] = 3 // 赋值 val age = map[\"李四\"] // 取值 常用的一些函数式API // 遍历集合元素, 并在函数体进行转换 list.map{ it.toUpperCase } // 过滤集合, 进行筛选 list.filter{ it.lenght \u003e= 5} // 判断集合中是否至少存在一个元素满足条件 list.any { it.length \u003e= 5 } // 判断集合所有元素是否满足条件 list.all { it.length \u003e= 5 } ","date":"2022-02-15","objectID":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E8%AF%AD%E6%B3%95/:1:5","tags":["kotlin"],"title":"Kotlin基础-语法","uri":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E8%AF%AD%E6%B3%95/"},{"categories":["kotlin"],"content":"Lambda 就是一小段可以作为参数传递的代码. 语法结构 {参数名1: 参数类型, 参数名2: 参数类型 -\u003e 函数体} 推导简化过程 // 原始 val list = listOf(\"apple\", \"pear\", \"banana\") val lambda = { name: String -\u003e name.length } // lambda语句, 最后为单句省略了花括号 val maxLength = list.maxOf (lambda) // 不需要定义lambda变量, 直接传入 val maxLength = list.maxOf({ name: String -\u003e name.length }) // 当Lambda参数是函数的最后一个参数时,可以移到函数括号外面 val maxLength = list.maxOf(){ name: String -\u003e name.length } // 当Lambda参数是函数的唯一参数时, 可以去掉函数的括号 val maxLength = list.maxOf{ name: String -\u003e name.length } // 由于推导机制, Lambda的参数类型声明可以去掉 val maxLength = list.maxOf{ name -\u003e name.length } // 当Lambda表达式只有一个参数时, 不必声明参数, 使用it关键字代替 val maxLength = list.maxOf{ it.length } 空指针 Kotlin默认所有的参数和变量都不可为空, 也就是说Kotlin将空指针异常的检查提前到了编译时期. 如果一个变量可空, 使用\"?“关键字id Int? 判空辅助工具 person?.eat() 如果person为空就不调用eat()函数. id?.lenght ?: 0 如果?:前为空就返回0, 否则不处理 ? : 逻辑 !! 非空断言 字符串内嵌表达式 \"hi, ${person.name} \" 当表达式中仅有一个变量的时候, 可以将两边的大括号省略. ","date":"2022-02-15","objectID":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E8%AF%AD%E6%B3%95/:1:6","tags":["kotlin"],"title":"Kotlin基础-语法","uri":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E8%AF%AD%E6%B3%95/"},{"categories":["kotlin"],"content":"关键字 is 相当于Java中的instanceof, 判断对象类型. == 判断字符串或对象是否相等. 不再需要equals()专门判断字符串 .. 区间声明(升序), 两端都是闭区间, 也就是两端数字都包含, 等价于数学中*[0,100]* until 区间声明(升序), 左闭右开区间, 包头不包尾,等价数学*[0,100)* downTo 区间声明(降序), 两端都是闭区间, 包头包尾, 等价数学*[100,0]* step 配合区间使用, 常规下区间是i++, i–,效果. 使用step 2, 实现循环中条件i=i+2的循环效果 class 声明类 open 修改类为可以被继承 : 类的继承关系指向 constructor 次构造函数声明 data 数据类型声明. object 单例类声明 ?. 判空辅助工具 不空就调用 ?: 判空辅助工具 不空就返回 !! 非空断言 ","date":"2022-02-15","objectID":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E8%AF%AD%E6%B3%95/:1:7","tags":["kotlin"],"title":"Kotlin基础-语法","uri":"/posts/kotlin%E5%9F%BA%E7%A1%80-%E8%AF%AD%E6%B3%95/"},{"categories":[],"content":"文件操作 ","date":"2022-02-11","objectID":"/posts/android%E9%80%82%E9%85%8D-%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/:1:0","tags":[],"title":"Android适配 文件存储","uri":"/posts/android%E9%80%82%E9%85%8D-%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/"},{"categories":[],"content":"Android 10 (Q-29) Scoped Storage 分区存储 限制了应用在外部存储可以肆意创建的能力. 改善公共目录的简洁干净. 文件位置 所需权限 访问方法 卸载时是否移除文件 应用目录下 无 getExternalFilesDir() 是 媒体集合(照片,视频,音频) READ_EXTERNAL_STORAGE(仅当访问其他应用创建的文件时才需要) MediaStore 否 下载内容(文档和电子书籍) 无 存储访问框架(SAF) 否 使用SAF可以访问表格中的任意位置, 而无需请求权限. 包名下的路径可以通过真是路径创建修改. 媒体集合, 下载内容等路径只能通过Uri访问 getCacheDir() -\u003e /data/user/0/包名/cache getFilesDir() -\u003e /data/user/0/包名/files getExternalCacheDir() -\u003e /storage/emulated/0/Android/data/包名/cache getExternalFilesDir(Sting type) -\u003e /storage/emulated/0/Android/data/包名/files/xxx/ getExternalMediaDirs() –\u003e /storage/emulated/0/Android/media/包名/ Environment.getExternalStorageDirectory() -\u003e /storage/emulated/0 Environment.getDownloadCacheDirectory() -\u003e /data/cache ….(以上仅为pixle Android 10输出路径) 适配 强制使用旧存储模式(Legacy View) (无太大意义, 因为android 11强制性新模式) 如果你能保证只在Android 10设备运行, 并想临时解决存储问题, 可以在清单文件中添加android:requestLegacyExternalStorage=“true” 需要迁移数据 应用的升级安装,还是会用旧模式, 只有首次安装, 或者卸载安装才会启用新模式. 所以可以通过一下代码在升级后判断, 把一些用户数据移动到特定目录下. // 使用Environment.isExternalStorageLegacy()来检查APP的运行模式 if (Build.VERSION.SDK_INT = Build.VERSION_CODES.Q \u0026\u0026 !Environment.isExternalStorageLegacy()) { } 首次或者强制卸载安装 对于**Environment.getExternalStorageDirectory()存储的文件迁移到getExternalFilesDir()或者getExternalCacheDir()**下 也可以使用MediaStore将文件按照图片, 视频, 音频进行分类存储. // 将图片保存到公共目录下 public static Uri createImageUri(Context context) { ContentValues values = new ContentValues(); values.put(MediaStore.Images.Media.DESCRIPTION, \"This is an image\"); values.put(MediaStore.Images.Media.DISPLAY_NAME, \"Image.png\"); values.put(MediaStore.Images.Media.MIME_TYPE, \"image/png\"); values.put(MediaStore.Images.Media.TITLE, \"Image.png\"); values.put(MediaStore.Images.Media.RELATIVE_PATH, \"Pictures/test\"); return context.getContentResolver().insert(MediaStore.Images.Media.EXTERNAL_CONTENT_URI, values); } 向公共目录添加具有严格的限制, 已pixel android 10为例 MIME_TYPE, RELATIVE_PATH, EXTERNAL_CONTENT_URI 3个字段应该严格的对应. 例如: 场景1: **insert()**插入 MediaStore.Images.Media.EXTERNAL_CONTENT_URI MIME_TYPE 对应 image/png RELATIVE_PATH 对应 Download/test 前两行代码表明要插入的一个图片类型到Image媒体库. 但是传入的相对路径头部为Download目录.此时就会抛出异常. java.lang.IllegalArgumentException: Primary directory Download not allowed for content://media/external/images/media; allowed directories are [DCIM, Pictures] 场景2: **insert()**插入 MediaStore.Images.Media.EXTERNAL_CONTENT_URI MIME_TYPE 对应 text/plain RELATIVE_PATH 对应 Pictures/test 这处故意传错MimeType, 同时也抛出了异常 MIME type text/plain cannot be inserted into content://media/external/images/media; expected MIME type under image/* 总结: 当我们Media向公共目录创建时. 首先确定要传递到什么类型的媒体表中. 如: MediaStore.Images.Media.EXTERNAL_CONTENT_URI, MediaStore.Downloads.EXTERNAL_CONTENT_URI等 然后传入具体的MimeType子类型. 如text/plain, image/png, audio/wav等 指定RELATIVE_PATH相对路径. 如果不创建子目录可以直接传入空串. 但是如果想创建子目录**/xxxx/childDir**/ 这个时候. 如果是图片类型那么xxx的值只能为Pictures****DCIM; 如果放入的是下载文件夹那么xxx只能是Download. MediaStore.Images : 图片，存储在 DCIM/ 和 Pictures/ 目录中 MediaStore.Video ：视频，存储在 DCIM/、Movies/ 和 Pictures/ 目录中 MediaStore.Audio ：音频，存储在 Alarms/、Audiobooks/、Music/ Notifications/、Podcasts/ 和 Ringtones/ 目录中 媒体数据库所在位置：data/data/com.android.providers.media ","date":"2022-02-11","objectID":"/posts/android%E9%80%82%E9%85%8D-%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/:1:1","tags":[],"title":"Android适配 文件存储","uri":"/posts/android%E9%80%82%E9%85%8D-%E6%96%87%E4%BB%B6%E5%AD%98%E5%82%A8/"},{"categories":null,"content":" 定制原因: 黑苹果升级系统 -\u003e BigSur 11.3.1 背部USB部分失效. ","date":"2021-05-08","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C-%E5%8D%8E%E7%A1%95m12e-usb%E5%AE%9A%E5%88%B6/:0:0","tags":["黑苹果"],"title":"黑苹果 华硕M12E USB定制","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C-%E5%8D%8E%E7%A1%95m12e-usb%E5%AE%9A%E5%88%B6/"},{"categories":null,"content":"使用环境 主板 华硕 M12E 系统版本 macOS Big Sur 11.3.1 (20E241) 必要工具 OpenCore Configurator(下文简称OCC) Hackintool ","date":"2021-05-08","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C-%E5%8D%8E%E7%A1%95m12e-usb%E5%AE%9A%E5%88%B6/:1:0","tags":["黑苹果"],"title":"黑苹果 华硕M12E USB定制","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C-%E5%8D%8E%E7%A1%95m12e-usb%E5%AE%9A%E5%88%B6/"},{"categories":null,"content":"修改步骤 使用 OCC 挂在EFI, 并打开config.plist文件, 在Kernel——内核设置中删除或者禁用USBInjectAll.kext, 并不勾选XhciPortLimt, 然后并添加定制好的USBPorts.kext文件, 保存设置, 重启电脑.(参考下图) 如果同样是M12E主板, 并且不需要前置面板的USB可直接下载USBPosrts.kext文件替换. ","date":"2021-05-08","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C-%E5%8D%8E%E7%A1%95m12e-usb%E5%AE%9A%E5%88%B6/:2:0","tags":["黑苹果"],"title":"黑苹果 华硕M12E USB定制","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C-%E5%8D%8E%E7%A1%95m12e-usb%E5%AE%9A%E5%88%B6/"},{"categories":null,"content":"延展笔记 ","date":"2021-05-08","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C-%E5%8D%8E%E7%A1%95m12e-usb%E5%AE%9A%E5%88%B6/:3:0","tags":["黑苹果"],"title":"黑苹果 华硕M12E USB定制","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C-%E5%8D%8E%E7%A1%95m12e-usb%E5%AE%9A%E5%88%B6/"},{"categories":null,"content":"为什么要定制USB Mac系统本身限制了USB的端口数量为15个, 同样网络上也有解除限制的补丁, 但不一定会一直稳定, 比如这次升级了系统之后, USB端口一半无效. 据说睡眠异常可能也与此有关(我这里没有) 有些人可能会发现为什么背部只有4 5个USB, 怎么还超过了限制. 因为这些端口还包括蓝牙, 前置面板, 主板内置USB针脚, 主板内置LED灯控等, 并且更主要的是一个USB3.0的端口实际上会占位两个端口一个USB3.0和一个USB2.0. 如下图. USB3.0 在另一侧多了一排针脚, 如果通过AIDA, Hackintool等可以查看全部USB端口工具， 在插入一个USB3.0的设备, 如果仅插入一半时连接的是USB2.0!速度为480mb/S, 插到底就是连接了USB3.0这是偶然发现的, 也说明了USB3.0多出来的针脚位于插槽的后部. ","date":"2021-05-08","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C-%E5%8D%8E%E7%A1%95m12e-usb%E5%AE%9A%E5%88%B6/:3:1","tags":["黑苹果"],"title":"黑苹果 华硕M12E USB定制","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C-%E5%8D%8E%E7%A1%95m12e-usb%E5%AE%9A%E5%88%B6/"},{"categories":null,"content":"华硕M12E USB失效解决过程 升级完系统之后, 直接毁了一半多的端口, 而剩下的好使的例如左上角两个, 左下角一个20Gb/s, 因为不在MacOS的15端口限制的管辖范围下, 所以没有任何影响, 下文通过工具查看会知道为什么不被控制. 利用Hackintool删除无用端口 由于目前部分端口已经失灵, 无法得知哪些端口是多余的, 并不能按照网络上的教程定做usb快速生效, 如下. 已经可以看到显示的端口数量已经将近30. 那么只好进入Windows系统中使用 AIDA64来查看端口分布情况. 如下. 通过AIDA64了解到, 主板总共又三条USB主线, 而定制USB只需要关心Intel(R) USB3.1主线即可. 因为Hackintool中USB只显示了 XHC类型的. 而Intel(R) USB3.1主线也有26的数量. 那么通过USB2.0 3.0的设备来测试. usb序号 所属总线 是否需要定制 Hackintool名称 1 ASMedia usb3.1 否(可用) 无 2 ASMedia usb3.1 否(可用) 无 3 Intel(R) USB3.1 否(BIOS专用) HS10 4 Intel(R) USB3.1 否(usb2.0接口) HS09 5 Intel(R) USB3.1 是 HS07, SS07 (Hub四口) 6 Intel(R) USB3.1 是 HS07, SS07 (Hub四口) 7 Intel(R) USB3.1 是 HS07, SS07 (Hub四口) 8 Intel(R) USB3.1 是 HS07, SS07 (Hub四口) 9 Intel(R) USB3.1 是 HS04, SS04 10 Intel(R) USB3.1 是 HS03, SS03 11 ASMedia usb3.1 否(可用) 无 12 Intel(R) USB3.1 是 HS05, SS05 保留主板内置 保留主板内置 蓝牙 Intel(R) USB3.1 是 HS14 主板USB针脚 Intel(R) USB3.1 是 HS08 未知已占用 Intel(R) USB3.1 是 HS06,SS06 因为需要在mac下控制冷头和风扇灯, 所以保留了内置usb的针脚HS08, 蓝牙必须保留, 未知已占用显示了已经被使用,所有不要删除. 由于前置面板的针脚线都没有插, 这里就不包括前面板的usb对应. 内置华硕led那个也可以删除. USR1**USR2不知道是啥, 删了没问题目前. 定制之后如下: HS04手上没有TYPE-C口的2.0设备, 所以没有点亮条目. ","date":"2021-05-08","objectID":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C-%E5%8D%8E%E7%A1%95m12e-usb%E5%AE%9A%E5%88%B6/:3:2","tags":["黑苹果"],"title":"黑苹果 华硕M12E USB定制","uri":"/posts/%E9%BB%91%E8%8B%B9%E6%9E%9C-%E5%8D%8E%E7%A1%95m12e-usb%E5%AE%9A%E5%88%B6/"},{"categories":null,"content":"使用 官方ble使用文档中文 官方ble使用文档英文 基于android 5.x系统新api的ble连接 问题 BluetoothGatt status 133的解决方案 深入 android的经典蓝牙与低功耗蓝牙的区别 如果想了解更多蓝牙底层,下面两个系列讲的很详细 http://blog.csdn.net/tsy20100200/article/details/47726645 http://www.wowotech.net/sort/bluetooth ","date":"2017-02-14","objectID":"/posts/android%E4%B9%8Bble%E5%BC%80%E5%8F%91%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/:0:0","tags":["android"],"title":"Android之蓝牙4.0BLE开发资料整理","uri":"/posts/android%E4%B9%8Bble%E5%BC%80%E5%8F%91%E8%B5%84%E6%96%99%E6%95%B4%E7%90%86/"},{"categories":null,"content":"第一个系统进程init Android设备的启动需要经过Boot Loader, Linux Kernel和Android系统服务三个核心阶段. 默认情况都有其对应的启动动画. 究其本质的话. Android系统并不算一个严格意义上的操作系统. 因为其实际上是运行在Linux内核之上的一系列的服务进程. 而正是因为这些进程才维持了设备的正常工作的关键. 而它们的祖先进程就是init 作为第一个启动的进程, 那么init的PID也就是0. 其通过对init.rc脚本来构建系统的初始化形态. 在这个脚本里面会陆续的启动Android的系统服务. ","date":"2017-02-09","objectID":"/posts/android%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/:1:0","tags":["android"],"title":"Android系统的启动流程","uri":"/posts/android%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"},{"categories":null,"content":"系统关键服务的启动简析 作为系统的第一个进程. 那么init就承担着启动其他系统服务的职责. 其中最主要的就是ServiceManager, Zygote, SystemServer ","date":"2017-02-09","objectID":"/posts/android%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/:2:0","tags":["android"],"title":"Android系统的启动流程","uri":"/posts/android%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"},{"categories":null,"content":"ServiceManager ServiceManager是Binder机制中的管理者. 保存着整个系统的所有Binder服务端(例如ActivityManagerService,WindowManagerService等), 并且管理着Binder服务端的名字和句柄. SM是在Init.rc里描述并由init进程启动的, 并且SM是一个Linux的程序. SM所属的class是core, 其他同类的系统进程包括ueventd,console,adbd等. 根据core的特性, 这些进程会同时被启动或停止. 另外由于被critical选项被标注, 说明其是系统的关键进程也就是说如果进程不幸地在4分钟内异常退出超过4次, 则设备将重启并进入还原模式. 当ServiceManager每次重启时, 其他关键进程如zygote, media, SurfaceFlinger等也会被重启. ","date":"2017-02-09","objectID":"/posts/android%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/:2:1","tags":["android"],"title":"Android系统的启动流程","uri":"/posts/android%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"},{"categories":null,"content":"Zygote zygote根据其字面意思受精卵可以大概猜出这是会衍生出新的生命的功能模块. 而Android中大多数应用程序和系统进程都是通过zygote来生成的. zygote不仅预装载各种系统类, 还有一个工作就是启动SystemServer, 这是大部分Android系统服务的所在地. ","date":"2017-02-09","objectID":"/posts/android%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/:2:2","tags":["android"],"title":"Android系统的启动流程","uri":"/posts/android%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"},{"categories":null,"content":"SystemServer SystemServer是Android进入Launcher前的最后准备. 它提供了众多由java语言编写的系统服务. ZygoteInit通过Zygote.forkSystemServer来生成一个新进程, 用于承载各系统服务. Zygote内部有Native层函数来进一步响应, 最终调用底层系统的fork接口来实际产生一个进程. 之后SystemServer中的三个重要的static函数会被执行. 分别是: main: 主函数 init1: 这个native函数主要完成本地层Service的启动(SurfaceFlinger, AudioFlinger等). 完成会回调init2 init2: 这是Java层各Service被启动的地方(例如AMS,WMS等). ","date":"2017-02-09","objectID":"/posts/android%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/:2:3","tags":["android"],"title":"Android系统的启动流程","uri":"/posts/android%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"},{"categories":null,"content":" 说一说你对Binder的理解… ","date":"2017-02-08","objectID":"/posts/%E9%9D%A2%E8%AF%95%E4%B9%8Bbinder%E7%9A%84%E8%AE%A4%E7%9F%A5/:0:0","tags":["android"],"title":"面试之Binder的认知","uri":"/posts/%E9%9D%A2%E8%AF%95%E4%B9%8Bbinder%E7%9A%84%E8%AE%A4%E7%9F%A5/"},{"categories":null,"content":"Binder为何存在 在日常代码编写中. 我们总是会理所应当的对函数进行调用, 对变量进行访问. 之所以能顺利访问时因为所有的函数和变量都在同一个进程之中. 也就是说因为在一个内存空间中. 虚拟地址的映射规则完全一致. 而如果想访问的是其他进程的函数或者变量, 是不可能直接通过内存地址来直接进行访问的. 既然进程之间不能访问, 那么如果通过间接的方法建立一条通道应该就可以解决了问题. 而Binder就是这样一个东西. Binder是Android中使用最广泛的IPC(Inter Process Communication)进程间通信机制. 例如. 比如访问手机短信,联系人, startActivity()编写项目时我们新建一个界面, 服务,广播,内容提供者. WMS窗口管理所有View的显示删除等等. 几乎可以说Binder相当于人体的心脏可以让血液传输到各个地方提供声明的持续的保障. ","date":"2017-02-08","objectID":"/posts/%E9%9D%A2%E8%AF%95%E4%B9%8Bbinder%E7%9A%84%E8%AE%A4%E7%9F%A5/:1:0","tags":["android"],"title":"面试之Binder的认知","uri":"/posts/%E9%9D%A2%E8%AF%95%E4%B9%8Bbinder%E7%9A%84%E8%AE%A4%E7%9F%A5/"},{"categories":null,"content":"Binder体系结构 由于Google对Binder封装的很好. 以至于我们都不容易发现它的存在. 并且因为Binder机制涉及的东西即多又杂,往往会走错路. 那么通过一个大体的执行流程, 和场景对比. 可以加深对整体的认知. Binder体系有四个组成元素. 和网络中TCP/IP很相似,如下对应关系 Binder体系 TCP/IP Binder驱动 路由器 Service Manager DNS Binder Client 客户端 Binder Server 服务器 比如我们需要访问www.baidu.com.那么四个角色的大体流程是这样的. 客户端输入网址告诉路由器我要查询域名www.baidu.com. 路由器此时不知道域名对应的ip地址所以需要到DNS去查询对应的IP并告知路由器 路由器在接收到返回的IP地址时会相应的返回给客户端 客户端拿到IP地址再对路由器进行IP连接的发送请求. 路由器会连接到对应的服务器并建立连接返回给客户端 这里需要注意DNS其实本质上也是一个服务器, 只不过这个服务器比较特殊. 它可以提供域名与IP的对应关系, 并且其本身的IP地址提前就已经预设好的(客户端是知道DNS的IP). Binder的原型结构如下图: 总结上图那么就是: 进程1(Client)需要访问进程2(Server), 需要借助Binder驱动来把请求传递到进程2中. 而参与通信的进程们需要持有Binder分配的唯一标识, 而这个唯一标识被保存到SM(Servier Manager,后面简称SM)中. 所以如果进程1想通过Binder Driver进行访问要知道进程2的binder标识所以需要先对SM进行查询相当于网络中DNS查询. 通过查询到标识来进行最终的请求. 之前说过DNS也相当于服务器, 只不过比较特殊, 因为对于Client是预先知道其IP地址的. 那么SM作为功能相同的DNS, 其对应的Binder标识. 对于其他Client进程来说同样是预先知道的. 因为Service Manger在Binder通信过程中的Binder标识永远是0. ","date":"2017-02-08","objectID":"/posts/%E9%9D%A2%E8%AF%95%E4%B9%8Bbinder%E7%9A%84%E8%AE%A4%E7%9F%A5/:2:0","tags":["android"],"title":"面试之Binder的认知","uri":"/posts/%E9%9D%A2%E8%AF%95%E4%B9%8Bbinder%E7%9A%84%E8%AE%A4%E7%9F%A5/"},{"categories":null,"content":"组成元素之Binder驱动 关于Binder驱动稍微了解即可. 由于Android系统是基于Linux内核的, 所以Binder驱动也必须是一个标准的Linux驱动. 也就是Binder Driver会将自己注册成一个misc device并向上层提供一个/dev/binder节点. (注意: Binder节点并不对应真实的硬件设备, Binder驱动运行于内核态) 那么为什么把Binder注册成一个misc device类型的驱动? Linux中的字符设备通常要经过alloc_chrdev_region(),cdev_init()等一系列操作才能在内核中注册完成. 而misc类型驱动则比较简单, 只需要调用misc_register()既可以完成. 例如上图进程1要访问Binder Driver时,通常要做如下操作: 打开Binder驱动. 通过Binder.c#binder_open()打开 与Binder驱动建立连接. 通过binder_mmap(). mmap()可以把设备指定的内存块直接映射到应用程序的内存空间. (应用程序通过mmap()获得的虚拟内存地址和Binder中指针指向的虚拟内存地址经过转换其实都指向一个物理地址, 这也是Binder驱动只用了一次复制就可以实现进程间的数据共享的原因) 建立连接之后当然就是操作驱动. Binder并没提供常规文件操作如read(),write()等. 而是用了一个更强大的接口函数binder_ioctl(). ","date":"2017-02-08","objectID":"/posts/%E9%9D%A2%E8%AF%95%E4%B9%8Bbinder%E7%9A%84%E8%AE%A4%E7%9F%A5/:3:0","tags":["android"],"title":"面试之Binder的认知","uri":"/posts/%E9%9D%A2%E8%AF%95%E4%B9%8Bbinder%E7%9A%84%E8%AE%A4%E7%9F%A5/"},{"categories":null,"content":"组成元素之ServiceManager 首先要知道SM的重要性. 当手机开机的时候会注册许多的系统服务来撑起整个手机的运行. 如ActivityManagerService, InputManagerService,WindowManagerService等等. 在之后我们开发的app启动的显示界面, 播放声音, 打开界面等等都是需要先获取系统服务才可以进行后续的操作. 而这些所有的操作都必须要经过SM才可以获取到. SM是一个完成的映射表有了这个表我们可以去找任何一个手机里面的任何一个服务. 既然把SM比作DNS并且SM本身也是一个Binder Server服务端, 只不过这个Binder标识为0(相当于IP地址). 我们在任何地方都可以通过binder id = 0来向Binder驱动获取到SM, 通过SM查询各种系统的服务来得到对应的binder标识(IP)来进行具体的系统服务互动. ","date":"2017-02-08","objectID":"/posts/%E9%9D%A2%E8%AF%95%E4%B9%8Bbinder%E7%9A%84%E8%AE%A4%E7%9F%A5/:4:0","tags":["android"],"title":"面试之Binder的认知","uri":"/posts/%E9%9D%A2%E8%AF%95%E4%B9%8Bbinder%E7%9A%84%E8%AE%A4%E7%9F%A5/"},{"categories":null,"content":"Service Manager的启动 由于SM的重要性,以及前提性. 我们可以大概猜出其应该尽可能在系统启动的最开始就进行加载. 那么Android系统的启动首先加载的就是init.rc. 从这个文件可以得到的信息是: 一旦当SM系统发生异常之后重启, 那么其他的系统服务如zygote,media,surfaceflinger等也会重启. SM用的C/C++编写, 和其他系统服务用Java编写略有不同. ","date":"2017-02-08","objectID":"/posts/%E9%9D%A2%E8%AF%95%E4%B9%8Bbinder%E7%9A%84%E8%AE%A4%E7%9F%A5/:4:1","tags":["android"],"title":"面试之Binder的认知","uri":"/posts/%E9%9D%A2%E8%AF%95%E4%B9%8Bbinder%E7%9A%84%E8%AE%A4%E7%9F%A5/"},{"categories":null,"content":"Service Manager的构建 当SM启动了之后, 首先做了如下的事情: 打开Binder设备, 进行初始化 通过ioctl()命令注册flag为BINDER_SET_CONTEXT_MGR来让自己成为系统的管理者. 并生成了在Binder驱动中对应的Binder Id = 0 然后通过循环开始等待客户端的请求. ","date":"2017-02-08","objectID":"/posts/%E9%9D%A2%E8%AF%95%E4%B9%8Bbinder%E7%9A%84%E8%AE%A4%E7%9F%A5/:4:2","tags":["android"],"title":"面试之Binder的认知","uri":"/posts/%E9%9D%A2%E8%AF%95%E4%B9%8Bbinder%E7%9A%84%E8%AE%A4%E7%9F%A5/"},{"categories":null,"content":"Service Manger的获取 既然这个SM这个服务管家已经构建完毕并且等待着被其他客户端使用. 那么就以SM为服务端. 走一遍client客户端去访问server服务端的流程. 虽然SM是基于native实现的, 但是由于Binder Client和Binder Server都是围绕着Binder驱动展开的, 因而只要能正确使用Binder驱动. 何种语言并不是固定的. 想要访问SM其实主要流程就是如下三步 打开Binder设备, 执行mmap 通过Binder驱动向SM发送请求. (SM的binder handler = 0) 获取最终结果 如果你看过Binder类你可能看到很多的比较别扭的术语asBinder,asInterface, BpBinder, transaction,IBinder等. 不需要死记这些东西, 因为这些都是都是从如何提供Binder Server服务这个问题而衍生的解决方案. 顺着主干线即一点点理解即可. 试想一下如果我们需要设计Client客户端应该怎么做? ProcessState和IPCThreadState 我们需要一个类来专门管理每个应用进程中的Binder操作, 而且关于Binder驱动的一系列命令对上层用户应该是透明的, 这个类对应的就是ProcessState. 并且进程中的每一个线程都应该有与Binder驱动自由沟通的能力, 并且由于Binder的IPC通信是阻塞的, 所以可以保证个别线程在做进程间的通信的时候不会卡死整个应用程序. 所以IPCThreadState就是与Binder驱动进行实际命令的通信的类. proxy 虽然通过ProcessState和IPCThreadState就可以让Client与Binder驱动进行通信了, 但是更好的方法是进行进一步的封装. 代理的出现可以让操作SM更加的简单, 封装成ServiceManagerProxy自后. 就可以提高模块与其他模块的无关性和便利性. 还记得这样的代码片段么 getService(\"window\"); 这样对于上层来说, 只需要接收要获取的服务端字符串名称即可. 既然是代理, 那么ServiceManagerProxy(用户进程)和ServiceManager应该具有相同的功能, 所以就可以向上提取出IServiceManager接口添加接口函数getService(),addService()等共同的函数. 那么IServiceManager接口的实现就需要完成 与Binder建立关系, 由于进程中存在ProcessState和IPCThreadState专门负责与Binder驱动通信(Native层), 而Java层基于上面两个类的实现称为BpBinder. 向Binder发送命令, 获取SM提供的服务 整理成一张图就是如下. 该图描绘了Binder模型中的上层建筑. 但是我们在获取服务的时候是使用的ServiceManager.java这个类, 这个类其实是ServiceManagerProxy的进一步封装. getSystemService(WINDOW_SERVICE); 当在代码中获取服务的时候. 内部首先查询缓存, 是否存在记录, 如果没有则会发送一条查询请求. 在请求过程中如果是第一次使用SM. 那么会调用ServiceManagerNative.asInterface(BinderInternal.getContextObject())获取一个IServiceManger. asInterface函数会将一个Binder对象转换成IServiceManager 整理成两步就是: 查询进程本地是否已经有了IServiceManager 如果没有 那么就新建一个ServiceManagerProxy 既然最后转到了ServiceManagerProxy的getService(String name). 那么内部实现也就很明确了. 通过Parcel打包数据. 利用IBinder#transact()将请求发送出去, 内部就是使用封装好的native层的ProcessState和IPCThreadState来进行与驱动的通信. transact()函数之后, 就可以获取到结果. 同socket相似, 这是一种阻塞的函数调用. 因为涉及进程间通信, 结果并不是马上就能获取到. 所以Binder驱动会先将调用者的线程挂起, 直到有了结果才会把它唤醒. ","date":"2017-02-08","objectID":"/posts/%E9%9D%A2%E8%AF%95%E4%B9%8Bbinder%E7%9A%84%E8%AE%A4%E7%9F%A5/:4:3","tags":["android"],"title":"面试之Binder的认知","uri":"/posts/%E9%9D%A2%E8%AF%95%E4%B9%8Bbinder%E7%9A%84%E8%AE%A4%E7%9F%A5/"},{"categories":null,"content":"IBinder和BpBinder 当进程第一次使用SM时, 会创建ServiceManagerProxy并传入了一个IBinder对象. 通过其transact()函数就可以与binder驱动通信. 那么IBinder的内部实现和功能就是也很简单. 接收Native层的ProcessState中创建的Binder对象并转化中Java层的IBinder对象. IBinder只是一个接口类, native层对应实现类是BpBinder.cpp, Java层则是Binder.java的内部类BinderProxy. ","date":"2017-02-08","objectID":"/posts/%E9%9D%A2%E8%AF%95%E4%B9%8Bbinder%E7%9A%84%E8%AE%A4%E7%9F%A5/:4:4","tags":["android"],"title":"面试之Binder的认知","uri":"/posts/%E9%9D%A2%E8%AF%95%E4%B9%8Bbinder%E7%9A%84%E8%AE%A4%E7%9F%A5/"},{"categories":null,"content":"ProcessState和IPCThreadState ProcessState 主要功能: 保证同一个进程中只有一个ProcessState实例存在, 并且只有在ProcessState对象创建时才打开Binder设备以及做内存映射. 向上层提供IPC服务 与IPCThreadState分工合作, 各司其职. IPCThreadState 当需要时才会创建. 并且是线程中单实例. IPCThreadState负责与Binder驱动进行具体的命令交互. 主要集中在transact()中. 先整理一下到目前为止的调用流程: ServiceManagerProxy#getService() --\u003e BinderProxy#transact() --\u003e BpBinder#transact() --\u003e IPCThreadState#transact() 由于内部很多操作底层并且c代码. 有兴趣的可以查看\u003c深入理解Android内核设计思想中的6.4.5节\u003e. 这里做一个简短流程. 接着上面进入到了IPCThreadState类的transact()函数中. 通过调用 IPCThreadState#waitForResponse() --\u003e IPCThreadState#talkWithDriver() --\u003e Binder.c#binder_ioctl() --\u003e Binder.c#binder_thread_read() 此时调用者也就是client线程就会进入睡眠等待. 直到它发起的服务请求已经回复, 才会被唤醒并接收结果. ","date":"2017-02-08","objectID":"/posts/%E9%9D%A2%E8%AF%95%E4%B9%8Bbinder%E7%9A%84%E8%AE%A4%E7%9F%A5/:4:5","tags":["android"],"title":"面试之Binder的认知","uri":"/posts/%E9%9D%A2%E8%AF%95%E4%B9%8Bbinder%E7%9A%84%E8%AE%A4%E7%9F%A5/"},{"categories":null,"content":"重点元素的简要整理 ServiceManagerProxy 当某个Binder Service启动时, 会把自己的名称name和对应的Binder句柄(唯一标识)保存在SM中. 调用者通常只知道Binder Service的名称, 所以必须先向SM发起查询请求. 而SM同样是一个Binder Service不同的是其Binder句柄==0. 所以任何的Binder Client都可以通过Binder=0创建一个BpBinder, 再通过Binder驱动来获取SM的服务. 由于同时支持Android和C/C++的Binder机制, 所以很多对象都具备了双重的身份, ProcessState和IPCThreadState 大多数程序都IPC的需要, 而进程间通信本身又是非常繁琐的, 因为Android系统特别为程序进程使用Binder机制封装了两个实现类. 一个负责驱动的打开并做mmap()映射. 另一个就是负责具体的驱动交互. binder驱动 Binder驱动通过巧妙的机制让数据传递更加的高效. 只需要一次复制就可以把数据从一个进程复制到另一个进程. Binder中还保存着大量的全局以及进程相关的变量, 用于管理每个进程/线程的状态,内存申请和代办事项等数据信息. 通过这些变量的有效协作, 整个Binder通信得以流动起来. Service Manager SM在Android系统启动之后就运行起来了, 并通过BINDER_SET_CONTEXT_MGR把自己注册成Binder的管理者. 在其进行完初始化之后, 会进入睡眠等待, 直到有Binder Client发起服务请求而被Binder驱动唤醒. SM唤醒后, 程序分为两条主线索. SM端将把调用者的具体请求读取出来并解析数据. 在根据实际情况填写transaction信息, 最后把结果通过BR_REPLY命令返回给Binder驱动 发起getService()请求的Client在等待SM回复的过程会进入休眠, 直到被Binder驱动唤醒. 当被唤醒的时候得到的就是SM的处理结果. 底层把结果填充到reply这个Parcel中, 然后向上层传递最终返回到ServiceManagerProxy, 再利用Parcel.readStrongBinder生成了一个BpBinder, 在经过类型转化为IBinder提供给应用层. 得到了IBinder对于开发层我们就比较熟悉了. IBinder经过asInterface做一次包装. 例如ServiceManger的BpBinder就被包装成了IServiceManager(实际就是ServiceManagerProxy), 这么做是为了让应用程序更好的使用Service Manager提供的服务. 其余的Binder Service也是类似. ","date":"2017-02-08","objectID":"/posts/%E9%9D%A2%E8%AF%95%E4%B9%8Bbinder%E7%9A%84%E8%AE%A4%E7%9F%A5/:4:6","tags":["android"],"title":"面试之Binder的认知","uri":"/posts/%E9%9D%A2%E8%AF%95%E4%B9%8Bbinder%E7%9A%84%E8%AE%A4%E7%9F%A5/"},{"categories":null,"content":"组成元素之Binder Client Binder的最大消费者是Java层的应用程序. 但是从开发人员的角度来看, 似乎并不需要过多的关心就可以安全方便的使用binderService, startActivity, sendBroadcast等一系列接口方法来实现与其他进程的交互. 比如: Activity 通过startActivity可以启动目标进程 Service 任何应用程序都可以通过startService或bindService来启动特定的服务, 而无论后者是否属于跨进程. Broadcast 任何应用程序都可以通过sendBroadcast来发送一个广播, 且无论广播处理者是不是在同一个进程中 … 这里以bindService为例, 来揭示出这些常用方法背后的Binder内部大体流程. 那么绑定一个service成功有哪几个关键点? 应用程序填写Intent. 调用bindService发出请求 收到请求bindService*(还在应用程序空间中)*将于ActivityManagerService(AMS)取得联系. 为了获得AMS的Binder句柄还要先调用ServiceManager.getService()来进行查询获取. 这个时候就已经涉及了进程间通信. 得到了AMS的句柄值后, 程序才能真正的向它发起请求. AMS基于特定的最优匹配策略, 从其内部存储的系统所有服务组件集合中找到与Intent最匹配的一个, 然后向它发送Service绑定请求*(同样进程间通信)*. 如果目标不存在那么AMS会将其先启动起来. 被绑定的服务进程需要响应绑定, 执行具体操作, 并在成功完成后通知AMS然后由后者再回调发起者请求的应用程序*(回调接口ServiceConnection)* ok从bindService()函数作为切入点. Activity的祖先类是Context. 而bindService()是从祖先类继承而来. 而Context本身是一个抽象类. 具体的功能实现是ContextImpl. // 跟踪bindService()函数会发现如下, 出现了ActivityManager int res = ActivityManagerNative.getDefault().bindService( mMainThread.getApplicationThread(), getActivityToken(), service, service.resolveTypeIfNeeded(getContentResolver()), sd, flags, getOpPackageName(), user.getIdentifier()); // 继续查看getDefault()是什么 static public IActivityManager getDefault() { return gDefault.get(); } private static final Singleton\u003cIActivityManager\u003e gDefault = new Singleton\u003cIActivityManager\u003e() { protected IActivityManager create() { // 通过SM获取ActivityManagerService的IBinder对象 IBinder b = ServiceManager.getService(\"activity\"); // 利用IInterface继承特性, 创建一个可用的ActivityManagerProxy, IActivityManager am = asInterface(b); return am; } }; 是否感觉和之前说的很相似? ActivityManagerNative的作用之一就是帮助调用者方便快速地取得一个ActivityManagerProxy. 这个ServiceManagerProxy和ServiceManagerNative作用基本一致. 而其另一个作用就是为AMS的实现提供了便利例如其中的onTransact()函数. 这样只要在AMS中继承ActivityManagerNative就可以将用户业务请求码和自己的内部函数连接起来. 所以可以总结出, ActivityManagerNative(其他服务的Native也是一样)既是面向调用者的, 也是面向服务实现本身的, 只不多Native这个名称比较容易让人迷惑. 其实不管是调用何种服务何种形式. 整个IPC通信都是基于Binder驱动展开的. 以Binder驱动为中心. 可以有一个全局方向看的更加清楚. 当应用程序需要通过ServiceManager来查询某个Binder Server时, 调用的是getService(). 几个关键点是: 之间面向程序的是ServiceManager.java, 它提供了很多静态函数来获取SM提供的服务. 这些静态函数内部通过getIServiceManager来得到ServiceManagerProxy对象. 后者作为SM的本地代理, 将利用IBinder来穿越JNI层调用到对应的BpBinder, 进而使用ProccessState和IPCThreadState的相关接口. 最终经由Binder驱动完成与SM的通信. ","date":"2017-02-08","objectID":"/posts/%E9%9D%A2%E8%AF%95%E4%B9%8Bbinder%E7%9A%84%E8%AE%A4%E7%9F%A5/:5:0","tags":["android"],"title":"面试之Binder的认知","uri":"/posts/%E9%9D%A2%E8%AF%95%E4%B9%8Bbinder%E7%9A%84%E8%AE%A4%E7%9F%A5/"},{"categories":["数据结构"],"content":"栈的定义 栈(stack)是限定仅在表尾进行插入和删除操作的线性表 通常把插入和删除的一端称作为栈顶(top). 另一端就是栈底(bottom), 不含有任何数据元素的栈称作为空栈. 栈又称作为后进先出(Last In First Out)的线性表. 简称LIFO结构. 栈的插入操作, 叫作进栈, 或者也可以叫作压栈,入栈. 栈的删除操作, 叫作出栈, 也可以叫作弹栈 软件被应用的场景: 例如文本Word, Photoshop等软件的撤销操作. 最后操作的先进行恢复. 通常栈的插入和删除操作. 用push和pop进行表示. 可以理解为压入和弹出 ","date":"2017-01-06","objectID":"/posts/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/:1:0","tags":["数据结构"],"title":"栈与队列","uri":"/posts/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"},{"categories":["数据结构"],"content":"栈的顺序存储结构 由于是线性表的一种特例. 那么同样可以使用数组来实现顺序存储结构. 通常数组的0下标作为栈底. 代码实现时需要有一个标记来记录栈顶的位置. 如果栈为一个空栈那么标记top通常等于-1. 当push入栈一个元素时, 判断top是否是栈的可容纳的最大值, 如果可以插入, 那么对top自增, 并对top的下标位值进行数据的写入. 当pop出栈反之. ","date":"2017-01-06","objectID":"/posts/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/:1:1","tags":["数据结构"],"title":"栈与队列","uri":"/posts/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"},{"categories":["数据结构"],"content":"栈的链式存储结构 同样由于栈是线性表的一种特例. 那么对于链式可以使用线性表的链式方式来是实现. 因为栈的插入和删除操作, 只能在栈顶进行. 那么就可以把栈顶放在单链表的头部. 对于链栈基本上不存在栈满的情况, 除非内存已经没有可以使用的空间, 如果真的这样, 那么计算机此时会面临着死机崩溃的情况,而不是链栈是否溢出的问题. 对于空栈来说, 只要链表头指针指向空即可. 进栈操作 由于是链表结构那么就不会如顺序存储结构那样通过一个标记位来对数组进行对应的下标的添加. 因为栈顶为单链表的头部. 那么如果出现了新的入栈push操作那么: 把原栈顶的元素对象挂载到新入栈的元素对象的next上. 完成链的串联. 把原栈的top指向修改为新入栈的元素对象上. 出栈操作 同样相反的操作. 修改指向栈顶元素的指针, 栈底方向移动一位. 把栈顶元素的next指向原第二栈顶位的元素置为null. ","date":"2017-01-06","objectID":"/posts/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/:1:2","tags":["数据结构"],"title":"栈与队列","uri":"/posts/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"},{"categories":["数据结构"],"content":"栈的应用-四则表达式 栈的应用最明显的就是递归. 还有一个有趣的就是四则运算表示式求值 如果要写出一个可以运算包括加减乘除括号的小功能怎么实现? 例如9 + (3 - 1) * 3 + 10 / 2. 由于优先级乘除优于加减. 括号内部要先进行计算. 这使得普通的方法实现比较麻烦. 如果利用栈的特性. 其实会很简单. 首先你要了解一个概念后缀表达式. 对于9 + (3 - 1) * 3 + 10 / 2这种我们生活中常用的是中缀表达式这是对于我们人类方便计算的. 而后缀表达式是针对计算机计算而来的. 后缀表达式: 是一种不需要括号表达法, 称为逆波兰(Reverse Polish Notation, RPN)表示. 由于所有的符号都是在要运算数字的后面出现.称为后缀 针对问题9 + (3 - 1) * 3 + 10 / 2来进行计算. 后缀表达式为9 3 1 - 3 * + 10 2 / + 计算机计算后缀表达式的规则: 从左到右遍历表达式的每个数字和符号, 遇到是数字就进栈, 遇到是符号, 就将处于栈顶两个数字出栈, 进行运算 运算结果进栈, 一直到最终获得结果. 如下图: 整个过程充分利用了栈后进先出的特性来处理. 用文字描述一下过程: 遇到数字直接进栈, 所以栈中的情况为139. 形成了步骤1 遇到-号. 栈顶的两个元素1, 3依次出栈进行3 - 1 = 2的运算, 并把运算结果2压入栈, 然后继续后缀表达式是数字3压入栈. 形成了步骤2 遇到*号. 栈顶3,2出栈计算, 结果6压回栈内. 此时形成步骤3 遇到+号. 栈顶6,9出栈计算, 结果15压回栈内. 接下来表达式是两个数字10, 2直接压入栈内. 此时形成步骤4 遇到/号, 栈顶2,10出栈计算, 结果5压回栈内,此时为步骤5 遇到+号, 栈顶5,15出栈计算, 结果20压回栈内, 此时步骤6. 由于表达式计算完毕. 栈内的唯一一个元素就是计算结果. 后缀表达式的转换 既然知道了计算机可以直接运行后缀表达式那么, 就来了解日常的标准四则运算表达式或者是中缀表达式是如何进行转换为后缀表达式 规则: 从左到右遍历中缀表达式的每个数字和符号, 如是数字就输出, 即成为后缀表达式的一部分; 若是符号, 则判断其与栈顶符号的优先级, 是右括号或优先级不高于栈顶符号(乘除优先为加减)则栈顶元素依次出栈并输出, 并将当前符号进栈, 一直到最终输出后缀表达式位置. 还是上一个表达式的例子 9 + (3 - 1) * 3 + 10 / 2 中缀 9 3 1 - 3 * + 10 2 / +后缀 如图: 图片转换比较难懂的是图3-\u003e图4和图5-\u003e图6 图3 -\u003e 图4 由于遇到了中缀表达式中的右括号)所以此时需要匹配此前的左括号(, 所以栈顶依次出栈并输出直到左括号(出栈为止. 由于左括号上方只存在-所以输出-号. 图5 -\u003e 图6 遇到了+号, 此时栈顶为*. 根据规则, 比栈顶元素优先级低(没有比+更低的优先级), 所以栈内元素全部出栈, 这时输出为9 3 1 - 3 * +. 此时中缀的+号才被压入了栈内. ","date":"2017-01-06","objectID":"/posts/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/:1:3","tags":["数据结构"],"title":"栈与队列","uri":"/posts/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"},{"categories":["数据结构"],"content":"队列的定义 队列(queue)是只允许在一端进行插入操作, 而在另一端进行删除操作的线性表 队列是一种先进先出(First In First Out)的线性表, 简称FIFO. 允许插入一端称为队尾, 允许删除一端称为队头 队列的实际场景: 多人连接客服, 先拨打的最队前头排列, 会被先处理; 键盘进行各种输入,并显示到记事本软件等. ","date":"2017-01-06","objectID":"/posts/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/:2:0","tags":["数据结构"],"title":"栈与队列","uri":"/posts/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"},{"categories":["数据结构"],"content":"队列的顺序存储结构 队列作为一种特殊的线性表, 也同样存在顺序和链式的结构. 由于队列顺序存储结构在队头(数组下标0)出队的时候, 会造成数组角标0的空缺, 那么就需要对所有的队列进行向前的位移. 存在着很大的无用的性能消耗. 所以出现了循环队列的概念. 循环队列 所谓循环队列就是在队列的顺序存储结构基础上. 通过两个指针分别对应队头和队尾. 当出现队头出栈的时候并需要在进行整体元素的前进操作, 只需要修改指针移向下一个元素. 队尾也是如此. 但是这里会有一个问题需要处理: 那就是当队头指针front, 队尾指针rear. 当队空或者队满时这两个指针都是相等的. 解决: 设置一个标志位flag, 当front == rear时, 通过flag是否为0来判断队是满还是空 也可以, 当队空时就是front == rear, 始终让数组的大小比队列的大小多一个空闲单元. 这样当队满时, 数组中就只有一个空闲单元. 这是我们就认为队列已满. 由于rear可能出现在front的前或者后. 那么通常(rear + 1) % QueueSize == front时就可认为队列已满. 所以队列要实现顺序存储的时候, 如果不使用顺序队列, 算法的时间性能是不高的. 但循环队列又面临着数组可能会溢出的问题, 这点要记住. ","date":"2017-01-06","objectID":"/posts/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/:2:1","tags":["数据结构"],"title":"栈与队列","uri":"/posts/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"},{"categories":["数据结构"],"content":"队列的链式存储结构 队列的链式存储结构, 其实就是线性表的单链表, 只不过它只能尾进头出, 简称链队列. 结构 一个头结点变量用于引用链头元素结构. 链头元素结构包括数据和链的下一个元素的指向. 以此串成链. 入队操作 入队操作就是在链表尾部插入节点 把尾节点挂载原始链尾元素的next下一个元素指向上. 出对操作 出队操作就是把头结点变量的指向改为 原链头元素结构的next的指向. 让头结点变量指向修改为原链头的下一个节点. 并断开出队链节点的next的指向. 清除链连接的关系. ","date":"2017-01-06","objectID":"/posts/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/:2:2","tags":["数据结构"],"title":"栈与队列","uri":"/posts/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"},{"categories":["数据结构"],"content":"比较 对于循环队列与链队列的比较, 从两方面进行考虑: 时间: 他们的操作都是常数时间, 即O(1), 不过循环队列是事先申请好空间, 使用期间不释放, 而对于链队列, 每次申请和释放节点也会存在一些时间开销, 如果入队出队频繁,则两者还是有细微差别的. 空间: 循环队列必须有一个固定的长度, 所以就有了存储元素个数和空间浪费的问题. 而链队列不会存在这个问题, 尽管需要一个指针域, 会产生一些空间的开销, 但也可以接受, 所以链队列更加灵活. 简要: 在可以确定队列长度最大值的情况下, 建议使用循环队列, 如果无法估计队列长度那么使用链队列. ","date":"2017-01-06","objectID":"/posts/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/:3:0","tags":["数据结构"],"title":"栈与队列","uri":"/posts/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"},{"categories":["数据结构"],"content":"首先看一下线性表都包括哪些结构: ","date":"2017-01-04","objectID":"/posts/%E7%BA%BF%E6%80%A7%E8%A1%A8/:0:0","tags":["数据结构"],"title":"线性表","uri":"/posts/%E7%BA%BF%E6%80%A7%E8%A1%A8/"},{"categories":["数据结构"],"content":"线性表的定义 零个或多个数据元素的有限序列. 序列: 说明了元素之间是有顺序的. 有限: 泛指元素的个数为有限. 因为计算机中处理的对象都是有限的, 无限数列只存在数学的概念中. 线性表的元素个数为\u003e=0. 当元素的个数为0. 这个表称之为空表. ","date":"2017-01-04","objectID":"/posts/%E7%BA%BF%E6%80%A7%E8%A1%A8/:1:0","tags":["数据结构"],"title":"线性表","uri":"/posts/%E7%BA%BF%E6%80%A7%E8%A1%A8/"},{"categories":["数据结构"],"content":"线性表的特性 一个线性表应该具备哪些基本的功能呢? 置空 查找 插入 删除 长度 这是大体一个线性集合应该具有的抽象功能. 当然根据顺序结构,链表结构的不同. 具体实现的能力也是不同的. ","date":"2017-01-04","objectID":"/posts/%E7%BA%BF%E6%80%A7%E8%A1%A8/:2:0","tags":["数据结构"],"title":"线性表","uri":"/posts/%E7%BA%BF%E6%80%A7%E8%A1%A8/"},{"categories":["数据结构"],"content":"顺序存储结构 线性表的顺序存储结构, 就是用一段地址连续的存储单元依次存储线性表的数据元素. 如java中的ArrayList 例如ArrayList如果实现. 由于存储的元素都是相同类型的. 那么就可以使用一维数组来实现顺序存储结构. 既然使用了数组. 那么在最开始的时候需要先开辟内存空间. 也就是说需要先指定一个数组大小. 作为线性表的可存储的最大长度. 这也是顺序存储结构的劣势. ","date":"2017-01-04","objectID":"/posts/%E7%BA%BF%E6%80%A7%E8%A1%A8/:3:0","tags":["数据结构"],"title":"线性表","uri":"/posts/%E7%BA%BF%E6%80%A7%E8%A1%A8/"},{"categories":["数据结构"],"content":"插入删除特点 插入 可以看到为了. 插入到位置2. 原来的2,3,4,5都要进行位置的移动. 如果这个排队只能进行5个人. 那么前面的插入会把第五个人踢出去. 那么这个时候第五个人肯定不干. 也就是对应着开发中的角标越界. 需要注意. 删除 同样删除元素, 会造成被删除元素位置的为空. 那么就需要后续的元素进行向前的补齐. 也就同样无关元素的位置移动. ","date":"2017-01-04","objectID":"/posts/%E7%BA%BF%E6%80%A7%E8%A1%A8/:3:1","tags":["数据结构"],"title":"线性表","uri":"/posts/%E7%BA%BF%E6%80%A7%E8%A1%A8/"},{"categories":["数据结构"],"content":"优缺点 优点: 无须为表中表中元素之间的逻辑关系而增加额外的存储空间 可以快速的存取表中任意位置的元素. 时间复杂度O(1) 缺点 插入和删除操作需要移动大量的元素. 时间复杂度O(n) 当线性表长度变化较大时, 难以确定存储空间的容量 可能会造成存储空间的碎片存在 ","date":"2017-01-04","objectID":"/posts/%E7%BA%BF%E6%80%A7%E8%A1%A8/:3:2","tags":["数据结构"],"title":"线性表","uri":"/posts/%E7%BA%BF%E6%80%A7%E8%A1%A8/"},{"categories":["数据结构"],"content":"链式存储结构 顺序结构的特点: 是连续的开辟了一段内存空间. 先分配后操作的特点. 让顺序结构变得有了局限性不是那么灵活. 而链式存储结构就是解决了这一问题的顺序结构. 看下图: 可以看出. 每个元素并不一定在内存中相邻的. 而是随意分配. 能实现这种效果是因为每个节点不仅存储了元素的信息, 还保存了下一个元素的内存地址 . 这样无论下一个节点在哪里. 都可以通过地址来进行操作. 而不是简单的如顺序存储结构只能想下一个地址位去查找. 一般链式存储结构中的头结点和尾节点比较特殊. 如果是单向链表尾节点的下一个元素位置一般为null或者空. 如果是双向链表那么头结点的上一个节点为空, 尾节点下一个元素为空. 所以我们只要知道了头结点那么就可以查找整个链式存储结构 ","date":"2017-01-04","objectID":"/posts/%E7%BA%BF%E6%80%A7%E8%A1%A8/:4:0","tags":["数据结构"],"title":"线性表","uri":"/posts/%E7%BA%BF%E6%80%A7%E8%A1%A8/"},{"categories":["数据结构"],"content":"插入删除特点 插入和删除是线性表的优势. 如下图: 同样是插入到2的位置. 这回只需要断开1~2之间的关系. 重新连接1,2,新元素的关系即可. 而其他元素不需要进行变换. 对于插入或删除数据越频繁操作, 单链表的效率优势就越明显. 因为插入和删除的操作由于只是单纯的修改位置指向. 所以时间复杂度仅仅是 O(1) ","date":"2017-01-04","objectID":"/posts/%E7%BA%BF%E6%80%A7%E8%A1%A8/:4:1","tags":["数据结构"],"title":"线性表","uri":"/posts/%E7%BA%BF%E6%80%A7%E8%A1%A8/"},{"categories":["数据结构"],"content":"静态链表 主要是针对一些如Basic, Fortran等早期的高级语言. 由于没有了指针的概念. 有人就想出了用数组代替指针, 用来描述单链表. 活用链表的插入删除的高效性. 过程: 让数组的元素都是由两个数据域组成, data和cursor. 数据域data用来存放数据元素; 而cursor相当于单链表中的next指针, 存放该元素的后继在数组中的下标. 这就叫做静态链表或者游标实现法 ","date":"2017-01-04","objectID":"/posts/%E7%BA%BF%E6%80%A7%E8%A1%A8/:4:2","tags":["数据结构"],"title":"线性表","uri":"/posts/%E7%BA%BF%E6%80%A7%E8%A1%A8/"},{"categories":["数据结构"],"content":"循环链表 将单链表中尾节点的指针端由空指针改为指向头结点. 使整个链表成为一个环. 这种头尾相接的单链表称为单循环链表简称单链表. ","date":"2017-01-04","objectID":"/posts/%E7%BA%BF%E6%80%A7%E8%A1%A8/:4:3","tags":["数据结构"],"title":"线性表","uri":"/posts/%E7%BA%BF%E6%80%A7%E8%A1%A8/"},{"categories":["数据结构"],"content":"双向链表 单向链表有个问题. 就是当你在某一节点的时候. 你是无法直接删除该节点. 因为当前节点不知道上一个节点只是知道下一个节点. 所以这样会造成线性表的断裂. 双向链表是在单链表的每个节点中, 再设置一个指向其前驱节点的指针域. ","date":"2017-01-04","objectID":"/posts/%E7%BA%BF%E6%80%A7%E8%A1%A8/:4:4","tags":["数据结构"],"title":"线性表","uri":"/posts/%E7%BA%BF%E6%80%A7%E8%A1%A8/"},{"categories":["数据结构"],"content":"单链表与顺序存储优缺点 存储方面: 顺序存储结构用一段连续的存储单元依次存储线性表的数据元素 单链表采用链式存储结构, 用一组任意的存储单元存放线性表元素 时间性能: 查找 顺序存储结构O(1) 单链表O(n) 插入删除 顺序存储结构需要平均移动表长一半的元素, 时间为O(n) 单链表在找出某个位置的指针后, 插入和删除仅为O(1) 空间方面: 顺序存储需要预分配存储空间, 分大了浪费, 分小了容易发生空指针. 单链表不需要分配. 只要需要就可以分配. 并且元素个数也不受限制. ","date":"2017-01-04","objectID":"/posts/%E7%BA%BF%E6%80%A7%E8%A1%A8/:5:0","tags":["数据结构"],"title":"线性表","uri":"/posts/%E7%BA%BF%E6%80%A7%E8%A1%A8/"},{"categories":["数据结构"],"content":"算法定义 算法是解决特定问题求解步骤的描述, 在计算机中表现为指令的有限序列, 并且每条指令表示一个或多个操作. 算法是针对一种或者是一类问题的解决方案. ","date":"2017-01-01","objectID":"/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%86%E8%A7%A3/:1:0","tags":["数据结构"],"title":"算法的了解","uri":"/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%86%E8%A7%A3/"},{"categories":["数据结构"],"content":"算法的特性 算法具有5个基本特性: 输入, 输出, 有穷性, 确定性和可行性. ","date":"2017-01-01","objectID":"/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%86%E8%A7%A3/:2:0","tags":["数据结构"],"title":"算法的了解","uri":"/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%86%E8%A7%A3/"},{"categories":["数据结构"],"content":"输入输出 算法具有0或者多个输入. 对于个别场景, 比如打印输出字符串. 可能会不需要任何的输入参数. 算法至少1个或者多个输出. 算法一定要有输出, 否则算法也就没有计算的意义. 输出的形式可以是打印输出或者是返回1个以上的值 ","date":"2017-01-01","objectID":"/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%86%E8%A7%A3/:2:1","tags":["数据结构"],"title":"算法的了解","uri":"/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%86%E8%A7%A3/"},{"categories":["数据结构"],"content":"有穷性 就是算法应该可以有限时间内可以执行完毕. 有限时间: 一个算法如果计算需要几天,几月那就有点扯蛋了. 基本这不是我们需要的算法. 执行完毕: 可以正常的执行结束. 而不会出现死循环的问题. ","date":"2017-01-01","objectID":"/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%86%E8%A7%A3/:2:2","tags":["数据结构"],"title":"算法的了解","uri":"/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%86%E8%A7%A3/"},{"categories":["数据结构"],"content":"确定性 算法的每一步骤都具有确定的含义, 不会出现二义性. 比如说. 某种条件下只会有一条执行的代码线路. 而不会因为随机性而导致相同的输入结果而出现了不同的输出结果. ","date":"2017-01-01","objectID":"/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%86%E8%A7%A3/:2:3","tags":["数据结构"],"title":"算法的了解","uri":"/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%86%E8%A7%A3/"},{"categories":["数据结构"],"content":"可行性 算法的每一步必须是可行的. 也就是说, 每一步都能够通过执行有限的次数来完成. ","date":"2017-01-01","objectID":"/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%86%E8%A7%A3/:2:4","tags":["数据结构"],"title":"算法的了解","uri":"/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%86%E8%A7%A3/"},{"categories":["数据结构"],"content":"算法的设计 正确性: 算法至少可以保证结果的准确性. 可读性: 算法的另一个目的是为了便于阅读, 理解和交流. 为了日后不是非常难于调试和修改要尽可能让代码可以逻辑清晰. 不要写出只能自己和机器才能看懂的代码. 健壮性: 能对一些非法的输入进行容错的处理. 边界问题的处理. 时间效率高和存储量低: 这是算法不断演进的根本因素. ","date":"2017-01-01","objectID":"/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%86%E8%A7%A3/:3:0","tags":["数据结构"],"title":"算法的了解","uri":"/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%86%E8%A7%A3/"},{"categories":["数据结构"],"content":"算法效率的度量方法 ","date":"2017-01-01","objectID":"/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%86%E8%A7%A3/:4:0","tags":["数据结构"],"title":"算法的了解","uri":"/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%86%E8%A7%A3/"},{"categories":["数据结构"],"content":"事后统计法 这是方法的前置条件是. 算法已经存在. 通过设计好的程序和数据, 利用计算机计时器对不同算法编制的程序的运行时间进行比较. 通过执行时间来决定算法的好坏. 缺陷: 需要设计出算法, 但不一定这个算法就有用, 可能花费时间写出的算法只因测试一遍就放弃代码. 时间的消耗依赖计算机的硬件, 和软件等因素. 测试数据一般都是一点盖面的测试. 一般是不使用此统计法 ","date":"2017-01-01","objectID":"/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%86%E8%A7%A3/:4:1","tags":["数据结构"],"title":"算法的了解","uri":"/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%86%E8%A7%A3/"},{"categories":["数据结构"],"content":"事前分析估算 比如: 一个高级语言编写的程序的运算时间取决于如下因素: 算法采用的策略, 方法 编译产生的代码质量 问题的输入规模 机器执行指令的速度 其中2和4分别是由软件和硬件来决定的. 所以剩下的两种就是关键因素. 可以认为代码需要进行计算的次数. 如下:两个代码片段. 场景: 对1~100进行所有数累加求和. private int normal_calculate(int count){ int sum = 0; // 执行 1 次 for(int i=0; i\u003ccount ; i++){ // 执行 count+1 sum += i; // 执行 count } return sum; // 执行 1 次 } private int optimize_calculate(int count){ int sum = 0; // 执行 1 次 sum = ( 1 + count ) * count/2; // 执行 1 次 return sum; // 执行 1 次 } 可以看出第一种是每个数进行累加的语句执行次数总共是2 * count + 3次 而第二种通过高斯定律只需要执行3次即可. ","date":"2017-01-01","objectID":"/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%86%E8%A7%A3/:4:2","tags":["数据结构"],"title":"算法的了解","uri":"/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%86%E8%A7%A3/"},{"categories":["数据结构"],"content":"时间复杂度 通常比较两个算法的好坏是通过对比时间复杂度来区分. 通常用大写O()来体现算法时间复杂度的记法. 称之为大O记法 例如最常见的O(1)常数阶, O(n)线性阶, O(n^2)平方阶 ","date":"2017-01-01","objectID":"/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%86%E8%A7%A3/:5:0","tags":["数据结构"],"title":"算法的了解","uri":"/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%86%E8%A7%A3/"},{"categories":["数据结构"],"content":"推导大O阶的方法 推导规律: 用常数1来取代运行时间中的所有加法常数 在修改后的运行次函数中, 只保留最高阶项 如果最高阶项存在且不是1, 则去除与这个项相乘的常数 常数阶 例如上面代码块2中的. 运行次数函数是f(count) = 3. 那么根据第一要点. 要把常数3改为1. 在保留最高阶项是发现没有最高阶项. 所以算法的时间复杂度就是O(1) 常数不论是多少, 都记做为O(1). 不要出现其他的数字. 而分支无论真假, 都不会随着n的变大而变大所以其时间复杂度不变. 线性阶 通常情况下循环结构的运行情况是分析时间复杂度的大部分的场景. 例如上面代码块1 中的总执行次数是 f(count) = 2*count + 3 那么根据推导规律其时间复杂度就是O(n)也可以是O(count). 对数阶 例如求一个数能被2整除多少次(不包括0). 那么就相当于求这个数的2^X = n得到x = log2 n 所以时间复杂度就是O(logn) 平方阶 一个n * n乘法表. 的双循环次数是1 + 2 + ... + (n-2) + (n-1) + (n) = n * (n + 1) / 2 = n^2 / 2 + n/2 根据推导规律第2和3条. 就会变成了O(n^2)的时间复杂度. ","date":"2017-01-01","objectID":"/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%86%E8%A7%A3/:5:1","tags":["数据结构"],"title":"算法的了解","uri":"/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%86%E8%A7%A3/"},{"categories":["数据结构"],"content":"常见的事件复杂度 常见的时间复杂度所耗费的时间从小到大依次是: O(1) \u003c O(log n) \u003c O(n) \u003c O(n*log n) \u003c O(n^2) \u003c O(n^3) \u003c O(2^n) \u003c O(n!) \u003c O(n^n) 以上的有很多是不太符合实际情况的算法时间的. 因为例如 2^n, n^3, n!. n只要是稍微大一点的数. 最终结果都会多几个量级的增加. 这么费时间的算法, 显示生活中也不会采用的. ","date":"2017-01-01","objectID":"/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%86%E8%A7%A3/:5:2","tags":["数据结构"],"title":"算法的了解","uri":"/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%86%E8%A7%A3/"},{"categories":["数据结构"],"content":"情况的采用 在我们对一组无序数字进行排序的时候. 总会出现所谓最好, 最坏, 正常(平均)的场景. 比如恰好这组数字是排序好的一组结果. 此时是最好情况. 一次查看就结束. 比如恰好这组数字每一个数字都需要进行比较直到最后一个数字. 此时就是最坏情况. 剩下的的就是中间范围的结果了. 我们可以认为其是平均值(最好+最坏 的一半) 因为最坏情况是一种保证, 那就是运行的时间不会再坏. 所以通常情况下都是以最坏时间当做其运行时间. ","date":"2017-01-01","objectID":"/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%86%E8%A7%A3/:6:0","tags":["数据结构"],"title":"算法的了解","uri":"/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%86%E8%A7%A3/"},{"categories":["数据结构"],"content":"算法空间复杂度 有时候不一定需要非要追求极致的时间算法. 巧妙的使用空间换时间的概念. 往往会让事情变得更简单. 例如: 写一个函数, 可以判断传入的参数是否是100以内的质数. 如果通过规律循环比对完成一个算法. 那么每次的数字都是需要计算的. 那么如果. 用一个内部的数组. 这个数组的大小就是0~100. 然后如果对应的下标是质数那么数组就存放1. 否则就是0. 这样每次传入的参数只需要作为数组下标去取值直接判断即可. 当然. 根据具体场景不同. 到底是否使用空间换时间的方法需要商酌. 空间的浪费是否真的有必要. 数据的保存是否很占用空间. 能带来的好处是否高于空间浪费的弊端等… ","date":"2017-01-01","objectID":"/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%86%E8%A7%A3/:7:0","tags":["数据结构"],"title":"算法的了解","uri":"/posts/%E7%AE%97%E6%B3%95%E7%9A%84%E4%BA%86%E8%A7%A3/"},{"categories":null,"content":" 硬件是软件的基石. 所有的软件功能最终都是由硬件来实现的. 计算机体系结构作为一门学科, 是软件和硬件的抽象体, 也是所有开发者都应该了解的. ","date":"2016-12-30","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/:0:0","tags":["操作系统"],"title":"操作系统简介","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/"},{"categories":null,"content":"计算机体系结构 ","date":"2016-12-30","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/:1:0","tags":["操作系统"],"title":"操作系统简介","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/"},{"categories":null,"content":"冯’诺依曼结构 冯诺依曼是20世纪公认的最伟大的科学家之一. 冯诺依曼结构又被称为冯诺依曼模型或者普林斯顿结构. 起源于其本人在1945年发表的一篇关于EDVAC(电子离散变量自动计算机)的论文. 在其中. 提出了两个对计算机领域产生深远影响的观点. 采用二进制, 抛弃十进制: 根据电子元件的工作特点, 冯诺依曼提出了使用二进制的设想. 他认为这件极大的简化计算机设备的逻辑线路. 后来的事实也证实了它的这一推断. 程序存储(stored-program): 除了二进制, 还建议计算机能实现程序存储和程序控制. 具体而言, 程序指令和数据都存放在同一内存储器中, 因此他们的宽度是一样的. 不过程序与数据共享同一总线在一定程度也制约了冯诺依曼机器的瓶颈. 冯诺依曼结构包含了运算器, 控制器, 输入输出设备等元素 ","date":"2016-12-30","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/:1:1","tags":["操作系统"],"title":"操作系统简介","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/"},{"categories":null,"content":"哈佛结构 哈佛结构并不是作为冯诺依曼结构的对立面出现的, 相反的, 他们都是属于stored-program类型体系. 区别就在于前者的指令与数据并不保存在同一个存储器中. 即哈佛结构是对冯诺依曼结构的改进和完善. 这也就意味着: 指令与数据可以有不同的数据宽度 执行速度更快 由于取指令和数据无法同步进行, 冯诺依曼结构的执行速率并不占优势. 而采用哈佛结构的计算机由于指令和数据的单独存储, 可以在执行操作的同时预读下一条指令, 所以在一定程度上可以提高其吞吐量. 哈佛结构的缺点在于架构复杂且需要两个存储器, 因而通常会被运用在对速度有特殊需求且成本预算相对较高的场合. 例如ARM9, ARM11等 无论是何种结构, 他们所包含的基本元素都是不变的. 即: CPU(中央处理器) 内存储器 输入设备 输出设备 其中输入和输出设备一般统称为I/O设备. ","date":"2016-12-30","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/:1:2","tags":["操作系统"],"title":"操作系统简介","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/"},{"categories":null,"content":"什么是操作系统 计算机操作系统是负责管理系统硬件, 并为上层应用提供稳定编程接口和人机交互界面的软件集合. 如果从共性的角度来看待操作系统. 操作系统对硬件的要求: Android系统面对的是手机, 平板这些嵌入式领域, 以ARM芯片为主; 而Windows系列则是应用PC市场. 所以操作系统必须针对软件来开发的. 同款系统安装在不同型号机器上: 如windows系统可以安装到不同的品牌机器上. 由此可以看出. 操作系统是针对某些硬件架构的, 如ARM, X86等 操作系统提供可用的人机交互界面: 例如手机的短信, 拨号. 电脑的浏览器. 文件管理器等. 支持程序的编写和安装 通过这些特性可以看出. 操作系统有两个大职责: 面向下层: 管理硬件, 比如CPU, 内存,Flash,IO等 面向上层: 不仅提供人机交互界面. 还可以为第三方程序的研发提供便捷, 可靠, 高效的API(Application Programming Interface). 这样上层应用的设计实现就可以不需要直接面向硬件, 从而大大缩短了应用开发的时间 . 由于Android基于Linux Kernel. 而操作系统的难点进程和内存管理,硬件驱动的支持等, 这是Linux的强项. 并且内核本身也是开源项目. ","date":"2016-12-30","objectID":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/:2:0","tags":["操作系统"],"title":"操作系统简介","uri":"/posts/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/"},{"categories":null,"content":"介绍 vi编辑器是Unix系统最初的编辑器. 它使用控制台图形模式来模拟文本编辑窗口, 允许查看文件中的行, 在文件中移动, 插入, 编辑和替换文本. 尽管可能是世界上最复杂的编辑器, 但其用用的大量特性使其成为Unix管理员多远来的支柱性工具. 在GNU项目将vi编辑器移植到开源世界时, 他们就决定对其做一些改变. 由于它不再是以前Unix中那个原始的vi编辑器, 所以开发人员对其进行了重命名vi improved, 或 vim ","date":"2016-12-27","objectID":"/posts/vim%E5%B8%B8%E7%94%A8%E7%AC%94%E8%AE%B0/:1:0","tags":["vim"],"title":"vim常用笔记","uri":"/posts/vim%E5%B8%B8%E7%94%A8%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"vim基础 vim编辑器在内存缓冲区中处理数据. 只要键入vim命令和要编辑的文件的名字就可以启动vim编辑器. 例如 # 新建一个 Hello.java $ vim Hello.java 如果在启动 vim时未指定文件名, 或者这个文件不存在, vim会开辟一段新的缓冲区域来编辑. 如果在命令行下指定了一个已有文件的名字. 那么vim会将文件的整个内容都读到一块缓冲区域来准备编辑. vim编辑器会检测会话终端的类型, 并用全屏模式将整个控制台窗口作为编辑器区域. 最初的vim编辑窗口显示了文件的内容, 并在窗口的底部显示了一条消息行. 如果文件内容并未占据整个屏幕, vim会在非文件内容行放置一个波浪线. 如下图 底部显示了文件的状态, 以及所编辑的文件的信息. 如果是新建的文件那么会出现[New File] Vim编辑器有两种操作模式 普通模式 插入模式 通过vim进入的时候就是普通模式 在普通模式中, vim编辑器会将按键解释成命令. 在插入模式下, vim会将你在当前光标位置输入的每个键都插入到缓冲区. 在普通模式下通过i键就可以进入插入模式. 要退回到普通模式只需要按esc键 光标的控制 在普通模式中, 可以通过方向键来移动光标. 同样如果方向键都没有, 你也可以通过字母键来控制. 如下 h: 左移一个字符 j: 下移一行 k: 上移一行 l: 右移一个字符 当然不可能只能一行一行的移动. 下面就提高移动速度的命令 PageDown(Ctrl + F): 下翻一屏 PageUp(Ctrl + B): 上翻一屏 G: 移动到缓冲区的最后一行 num G: 移动到缓冲区中的第 num 行 gg: 移动到缓冲区的第一行 命令行模式 在普通模式下有一个特别的功能就是命令行模式. 命令行模式提供了一个交互式命令行, 可以输入额外的命令来控制vim的行为. 要进入到命令行模式, 在普通模式下按冒号键. 光标会移动到消息行, 然后出现冒号, 等待输入命令. 在命令行模式下有几个命令可以将缓冲区的数据保存到文件中并对出vim q: 如果未修改缓冲区数据, 退出. q!: 取消所有对缓冲区数据的修改并退出. w filename: 将文件保存到另一个文件中 wq: 将缓冲区数据保存到文件中并退出. 缺点命令较多, 但是只要了解了一些基本的vim命令, 无论什么环境, 你都能快速在命令行下直接修改文件. 一旦使用了敲入命令, 在命令行下将数据和编辑命令一起输入就跟第二天性一样的自然, 而需要使用鼠标就显得比较多余了. ","date":"2016-12-27","objectID":"/posts/vim%E5%B8%B8%E7%94%A8%E7%AC%94%E8%AE%B0/:2:0","tags":["vim"],"title":"vim常用笔记","uri":"/posts/vim%E5%B8%B8%E7%94%A8%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"编辑数据 在普通模式下, vim提供了一些命令来编辑缓冲区的数据. 命令 描述 x 删除当前光标所在位置的字符 dd 删除当前光标所在行 dw 删除当前光标所在位置的单词 d$ 删除当前光标所在位置到行尾的内容 J 删除当前光标所在行行位的换行符(拼接行) u 撤销前一个编辑命令 a 在当前光标后追加数据 A 在当前光标所在行行尾追加数据 r char 用char替换当前光标所在位置的单个字符 R text 用text覆盖当前光标所在位置的数据, 直到按下esc键 有些编辑命令允许使用数据修饰符来指定重复该命令多少次. 例如: 2x : 删除从光标位置开始的两个字符 5dd: 删除从光标当前行为为起始行下面的5行 ","date":"2016-12-27","objectID":"/posts/vim%E5%B8%B8%E7%94%A8%E7%AC%94%E8%AE%B0/:3:0","tags":["vim"],"title":"vim常用笔记","uri":"/posts/vim%E5%B8%B8%E7%94%A8%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"复制和粘贴 剪切和粘贴相对容易一些. 在前面说过删除数据的命令, 但vim在删除数据时, 实际上会将数据保存在单独的一个寄存器中. 可以使用p命令取回数据. 例如: dd命令删除了一行文本, 然后移动光标到其他行, 使用p命令. 就会将之前删除的文本插入到当前的光标所在行之后. 可以将它和任何删除文本命令一起搭配使用. 复制文本稍微复杂一点. vim中的复制命令是y代表yank. 可以在y后面使用和d命令相同的第二个字符(yw表示复制一个单词, y$表示复制到行尾). 在复制文本后, 把光标移动到想要复制的位置, 输入p命令. 复制的文本就会出现在该位置. 复制的复杂之处在于, 由于不会影响到你复制的文本, 无法知道到底要发生什么. 也就无法得知具体到底复制了什么内容. 知道将它粘贴到可以看到的地方才会了解到具体复制的内容.但vim还有另外一个功能来解决这个问题. 可视模式会在你移动光标时高亮显示文本. 可以用可视模式选取要复制的文本. 要进入可视模式, 应移动光标到要开始复制的位置, 并按下v键. 这时就会光标所在位置已经被高亮显示. 下一步, 移动光标来覆盖你想要复制的文本(也可以向下移动几行来复制更多). 在移动光标时, vim会高亮显示复制区域的文本, 在覆盖了要复制的文本后, 通过y键来激活复制命令. 现在寄存器已经有了要复制的文本, 移动光标到你要放置的位置, 使用p命令来粘贴. ","date":"2016-12-27","objectID":"/posts/vim%E5%B8%B8%E7%94%A8%E7%AC%94%E8%AE%B0/:4:0","tags":["vim"],"title":"vim常用笔记","uri":"/posts/vim%E5%B8%B8%E7%94%A8%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"查找和替换 可以使用vim查找命令来轻松查找缓冲区的数据. 要输入一个查找字符串, 就按下斜线/. 光标会报道消息行, 然后vim会显示出斜线. 在输入你要查找的文本后, 就按下回车键. vim编辑器会采用以下三种回应的一种. 如果要查找的文本出现在光标当前位置之后, 则光标会跳到该文本出现的第一个位置. 如果要查找的恩本未出现在光标当前位置之后出现, 则光标会绕过文件末尾, 出现在该文本所在的第一个位置(并用一条消息指明) 输出一条消息, 说明在文件中没有找到查找的文本. 要继续查找同一个单词, 按下斜线键, 然后按回车键. 或者使用n键, 表示下一个(next). 替换命令允许你快速用另一个单词来替换文本的某个单词. 必须进入命令模式才能使用替换命令. 替换命令的格式是: :s/old/new vim编辑器会调到old第一次出现的地方, 并用new来替换. 可以对替换命令做一些修改多处文本. :s/old/new/g : 一行命令替换所有old :n,ms/old/new : 替换行号n和m之间所有old :%s/old/new/g : 替换整个文件中的old :%s/old/new/gc : 替换整个文件中的所有old, 但在每次出现时提示. 对一个命令行文本编辑器而言, vim包含了不少高级功能. 讲过的也只是一小部分. ","date":"2016-12-27","objectID":"/posts/vim%E5%B8%B8%E7%94%A8%E7%AC%94%E8%AE%B0/:5:0","tags":["vim"],"title":"vim常用笔记","uri":"/posts/vim%E5%B8%B8%E7%94%A8%E7%AC%94%E8%AE%B0/"},{"categories":null,"content":"文件系统 ","date":"2016-12-26","objectID":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/:1:0","tags":["shell"],"title":"shell常用小手册","uri":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"遍历目录 格式: cd destination # 绝对文件路径 $ cd /usr/bin # 相对文件路径 进入当前目录下的doc文件夹 $ cd doc # 进入当前文件夹的同级目录pics $ cd ../pics ","date":"2016-12-26","objectID":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/:1:1","tags":["shell"],"title":"shell常用小手册","uri":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"查看当前目录路径 $ pwd ","date":"2016-12-26","objectID":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/:1:2","tags":["shell"],"title":"shell常用小手册","uri":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"文件基本操作操作 # 显示当前目录下的文件和目录, 按字母排序, 展示顺序为按列 $ ls # 如果想让文件夹变得更容易区分, -F参数可让显示文件夹后面追加一个 / $ ls -F # 如果查看包括隐藏文件, .开头的文件. 可使用 -a 参数 $ ls -a # 默认ls只会显示指定目录下一个层级所有文件. 如果要显示指定目录下的所有所有子层级 $ ls -R ","date":"2016-12-26","objectID":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/:1:3","tags":["shell"],"title":"shell常用小手册","uri":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"文件的长列表 如果需要查看更多的信息, 比如文件类型,文件权限,属组或属主,大小等 $ ls -l # 一个连贯的展示习惯, 就是将参数组合, 例如展示隐藏 长列表的显示结果 $ ls -la ","date":"2016-12-26","objectID":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/:1:4","tags":["shell"],"title":"shell常用小手册","uri":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"过滤输出信息 例如如果你只想想查找目录下的test.java文件的相关信息. 不想显示出其他信息干扰到你. 你可以这样 # 只显示过滤要求的文件相关信息 $ ls -l test.java # 可以使用通配符 ? , 代表一个任意字符 $ ls -l tes?.java # 可以使用通配符 * , 代表0或者多个任意字符 $ ls -l tet* 上面的后两种使用星号或者问号被称为文件扩展匹配, 就是使用通配符进行模糊匹配的过程. 还有一些其他的通配符. 还是以test.java为例 # 指定某个位置的的区间, [a-z], abc...xyz都可以 $ ls -l tes[a-z].java ","date":"2016-12-26","objectID":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/:1:5","tags":["shell"],"title":"shell常用小手册","uri":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"文件创建 创建一个空文件touch命令 # 创建一个名字为 Hello.java 的文件 $ touch Hello.java # 当文件已经存在时, touch命令不会清空原有数据, 但是会更改文件的修改时间 $ test ll *.js -rw-r--r-- 1 suzeyu staff 107B 10 26 16:36 test.js $ test touch test.js $ test ll *.js -rw-r--r-- 1 suzeyu staff 107B 12 26 16:51 test.js # 如果只想改变 访问时间 那么通过 -a 参数 $ touch -a Hello.java ","date":"2016-12-26","objectID":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/:1:6","tags":["shell"],"title":"shell常用小手册","uri":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"复制文件 cp source destination # 文件 -\u003e 文件的拷贝 $ cp test.cpp test_1.cpp # 如果目标文件文件已经存在可能会直接覆盖, 所以 -i 会让操作更加安全,警告提示 $ cp -i test.cpp test_1.cpp # 文件 -\u003e /users/suzeyu 目录下 $ cp test.cpp /users/suzeyu/ #注意最后的 / , 如果没有就代表users目录下suzeyu文件 # /users/suzeyu/orgin.txt文件 -\u003e 当前目录下, 利用 . 可以代表当前目录 $ cp /users/suzeyu/orgin.txt . # 当前目录下的olds文件夹 -\u003e 目录下的命为news的新文件夹 $ cp -R olds/ news # -R 可以递归遍历olds文件夹, 并创建新的news # 也可以使用通配符. 把所有的java文件复制出去 $ cp *.java javaDir/ ","date":"2016-12-26","objectID":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/:1:7","tags":["shell"],"title":"shell常用小手册","uri":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"链接文件 链接是目录中指向文件真实位置的占位符. 符号链接: 一个真实的文件. 指向存放在虚拟目录结构中的一个文件. 硬链接: 会创建独立的虚拟文件, 包含原始文件的信息及位置. 但他们根本而言是一个文件 # 符号链接 # 为一个文件创建符号链接 使用 ln 命令和 -s 选项 $ ln -s filename linkname # 通过 ls -l *name, 查看文件信息, 会发现linkname -\u003e filename. 这两个文件是完全不同的文件, # 也可以通过文件唯一 inode 编码来证实 $ ls -i *name # 硬链接 # ln 命令, 不过不需要-s 选项 $ ln filename hardname ","date":"2016-12-26","objectID":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/:1:8","tags":["shell"],"title":"shell常用小手册","uri":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"重命名文件 重命名也被称为移动(moving) , 主要是mv命令 # 修改文件 test.java 名为 new_test.java $ mv test.java new_test.java # mv不会改变文件唯一inode编码和时间戳. # 也可以移动文件到某个文件夹 $ mv test.java /Users/suzeyu/Desktop/ # 同样可以在移动的时候, 添加 -i 参数, 同cp一样. 当覆盖已有文件时会警告提示 # 或者移动整个目录及其内容 $ mv oldDirs newDirs ","date":"2016-12-26","objectID":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/:1:9","tags":["shell"],"title":"shell常用小手册","uri":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"删除文件 rm 删除也称为移除removing. 但要注意, 一旦删除了可以无法找回的. 所以删除前一定要确认好信息 # 删除文件 Hello.txt $ rm Hello.txt # 添加确认信息删除, 上面的会直接删除掉文件, 而如果加入了 -i 会有警告提示 $ rm -i Hello.txt # 同样可以使用通配符进行批量删除, 例如当前目录的java文件 $ rm *.java # 如果想删除整个文件夹, 那么需要配合使用 -R 进行递归遍历删除. $ rm -R dirsName # 如果有多个警告提示, 想强制关掉, 可以添加 -f 参数 # rm 中的 -r -R 效果是一样 ","date":"2016-12-26","objectID":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/:1:10","tags":["shell"],"title":"shell常用小手册","uri":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"创建目录 # 创建一个目录 $ mkdir name # 如果需要批量的创建目录. 那么需要 -p 选项的配合 $ mkdir -p parentDir/subDir/sunDir ","date":"2016-12-26","objectID":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/:1:11","tags":["shell"],"title":"shell常用小手册","uri":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"删除目录 # 删除一个目录 $ rmdir name # 默认 rmdir 只能删除空目录. 可以使用 rm 来递归删除, $ rm -r name ","date":"2016-12-26","objectID":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/:1:12","tags":["shell"],"title":"shell常用小手册","uri":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"查看文件类型 file能够探测文件内部, 并决定文件时什么类型 # 查看文件的类型 $ file name # 可以区分文本类型, 图片, 目录, 符号链接文件, 脚本, 可执行二进制等. ","date":"2016-12-26","objectID":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/:1:13","tags":["shell"],"title":"shell常用小手册","uri":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"查看整个文件 cat, more, less这是很便捷的工具 # 你想查看一个Hello.java的类的内容 $ cat Hello.java # 也可以让显示的内容加上行号, 这也很简单 $ cat -n Hello.java # 或许你的类里面充斥着各种空白行, 而你不需要空白行添加行号. 那么 -b 可以解决 $ cat -b Hello.java 这里有一个问题, 如果打开的文本很大, 那么直接使用cat会加载全部的内容. 或许我们需要进行控制, 那么more命令分页工具现在就可以登场了. # 分页显示 $ more Hello.java 这回在显示一屏的内容之后停止下来. 你可以通过上下方向键控制. 也可以通过空格进行翻页. q键可推出预览模式. less命令工具, 这是一个比more更高级一些的根据. 功能和使用很相似. ","date":"2016-12-26","objectID":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/:1:14","tags":["shell"],"title":"shell常用小手册","uri":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"查看部分文件 如果只关心头部和尾部的内容. 那么tail和head命令. 可以很好的解决这种场景 tail尾部查看 # 查看文件的尾部 $ tail Hello.java # 默认 tail 显示文件的最后10行 , 通过 -n 参数来修改所显示的行数 $ tail -n 5 Hello.java head头部查看 # 查看头部内容 , 默认显示前10行 $ head Hello.java # 指定显示多少行的参数设置 $ head -20 Hello.java ","date":"2016-12-26","objectID":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/:1:15","tags":["shell"],"title":"shell常用小手册","uri":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"检测程序 ","date":"2016-12-26","objectID":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/:2:0","tags":["shell"],"title":"shell常用小手册","uri":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"进程查看 ps 默认显示运行在当前控制台下属于当前用户的进程 # -e 参数可以显示所有运行在系统上的进程 # -f 参数则扩展了输出 # -l 会产生一个长格式的输出 关于-f的扩展出的选项的字段含义 UID 启动这些进程的用户 PID 进程的进程ID PPID 父进程的进程号 C 进程生命周期中的系统时间 STIME 进程启动时的系统时间 TTY 进程启动时的终端设备 TIME 运行进程需要的累积CPU时间 CMD 启动程序名称 关于-l参数字段的含义 F 内核分配给进程的系统标记 S 进程的状态(O运行; S休眠; R可运行正在等待运行; Z僵化; 进程已结束但父进程不在; T停止) PRI 进程的优先级, 数字越大优先级越低 NI 谦让度值用来参与决定优先级 ADDR 进程的内存地址 SZ 加入进程被换出, 所需要交换空间的大致大小 WCHAN 进程休眠的内核函数地址 # 查看实时进程监测 $ top ","date":"2016-12-26","objectID":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/:2:1","tags":["shell"],"title":"shell常用小手册","uri":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"磁盘空间 ","date":"2016-12-26","objectID":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/:3:0","tags":["shell"],"title":"shell常用小手册","uri":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"mount 用来挂载媒体的命令叫做mount. 默认情况下, mount命令会输出当前系统上挂载的设备列表 # 显示当前系统上挂载的设备列表 $ mount 一般输入会是如下 /dev/disk1 on / (hfs, local, journaled) 提供了四部分信息, 从前到后 1. 媒体的设备文件名 2. 媒体挂载到虚拟目录的挂载点 3. 文件的系统类型 hfs 4. 已挂载媒体的访问状态 如果需要手动挂载, 需要root权限 $ mount -t type device directory | | | | | | | | | $ mount -t ntfs /dev/sdb1 /media/disk 卸载设备umount 形式: umount [ directory | device ] ","date":"2016-12-26","objectID":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/:3:1","tags":["shell"],"title":"shell常用小手册","uri":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"df命令 df可以快速的知道某个设备上还有多少磁盘空间, 方便查看所有已经挂载的磁盘情况 # 配合 -h 可以把输出按照用户易读的形式表示. 如M, G $ df -h ","date":"2016-12-26","objectID":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/:3:2","tags":["shell"],"title":"shell常用小手册","uri":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"du命令 df可以很容易发现那个磁盘的存储空间快没了. du就是接下来要处理问题的工具, 它可以显示某个特定目录下的磁盘使用情况. 这一方法可用来快速判断系统上某个目录下是不是有超大文件. # 常规使用, 显示当前目录下所有的文件, 目录, 和子目录的使用情况 # 会以磁盘块为单位显示占有空间 $ du # 一般需要配合几个参数进行使用 -c 显示所有已列出文件的总大小 -h 以用户易读的方式显示占有大小, 如K, M, G ","date":"2016-12-26","objectID":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/:3:3","tags":["shell"],"title":"shell常用小手册","uri":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"数据的排序 sort命令按照会话指定的默认语言的排序规则对文本文件中的数据进行排序 例如: 如果你要排序的是数字, 那么需要通过-n让sort命令不要把数字当成字符处理. 这样对于100 \u003e 2的情况就可以避免 # 让sort命令识别数字, 而不是把每一个数字当成字符处理 $ sort -n fileName # 如果需要排序的按照月份, 并且排序的值是Jan, Feb, Mar等三字符的月份, 那么使用-M $ sort -M fileName 不仅仅如此, 例如如果我们有这么一个键值表: 如果想进行年龄的排序, 那么使用-k和-t参数进行年龄字段的排序. -t: 可以指定字段分隔符 -k: 指定排序的字段 例如上面这个图, 分割字段就是:, 根据排序的条件是第二个字段 那么如果想查看目录下所有文件的占用排序, 就可以 # 从大到小排序 $ du -s * | sort -nr ","date":"2016-12-26","objectID":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/:3:4","tags":["shell"],"title":"shell常用小手册","uri":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"搜索数据 在大文件查找一条数据, 通过grep命令就可直接查找 grep会在输入或者指定的文件中查找包含匹配指定模式的字符的行 # 查找文件中的张三的行 $ test grep 张三 age.txt 张三:40 # 查找文件中的 : 的行 $ test grep : age.txt 张三:40 李四:20 王五:18 赵六:79 # 反向搜索, 除张三之外的人的行 $ test grep -v 张三 age.txt 李四:20 王五:18 赵六:79 # 显示匹配的行号, -n $ test grep -vn 张三 age.txt 2:李四:20 3:王五:18 4:赵六:79 # 如果只想知道含有多少行, 满足条件 -c $ test grep -c 张三 age.txt 1 # 如果要指定多个模式, 通过 -e 参数 $ test grep -e 张三 -e 王五 age.txt 张三:40 王五:18 # 默认,grep用基本的Unix风格的正则表达式来匹配模式 # 搜索行中有8或者9的行 $ test grep [89] age.txt 王五:18 赵六:79 grep是一个基础的搜索工具, 衍生版本也是存在的 egrep: 是grep的衍生, 支持POSIX扩展正则表达式. 含有更多可以用来指定匹配的模式的字符 fgrep: 则是另外一个版本, 支持将匹配模式指定为用换行符分隔的一系列的固定长度的字符串. 这样就可以把这列字符串放到一个文件中. ","date":"2016-12-26","objectID":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/:3:5","tags":["shell"],"title":"shell常用小手册","uri":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"压缩数据 压缩数据主要针对一个文件 工具 文件扩展名 描述 bzip2 .bz2 采用Burrows-Wheeler块排序文本压缩算法和霍夫曼编码 compress .Z 最早的Unix文件压缩工具, 基本没人用 gzip .gz GNU压缩工具, 用Lempel-Ziv编码 zip .zip Window上PKZIP工具的Unix实现 gzip软件包含以下工具: gzip: 用来压缩文件 gzcat: 用来查看压缩过的文本文件的内容 gunzip: 用来解压文件 用法和bzip2一样 ","date":"2016-12-26","objectID":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/:4:0","tags":["shell"],"title":"shell常用小手册","uri":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"归档数据 在Unix和Linux上最广泛使用的归档工具是tar命令 tar命令的基本格式 tar function [options] object1 object2 ... function参数可选 功能 长名称 描述 -A –concatenate 将一个已有tar归档文件追加到另一个已有tar归档文件 -c –create 创建一个新的tar归档文件 -d –diff 检查归档文件和文件系统的不同之处 –delete 从已有tar归档文件中删除 -r –append 追加文件到已有tar归档文件末尾 -t –list 列出已有tar归档文件的内容 -u –update 将比tar归档文件中已有的同名文件,新的文件追加到该tar归档文件中 -x –extract 从已有tar归档文件中提取文件 option常用选项 选项 描述 -C dir 切换到指定目录 -f file 输出结果到文件或设备file -j 将输出重定向给bzip2命令来压缩内容 -p 保留所有文件权限 -v 在处理文件时显示文件 -z 将输出重定向给gzip命令来压缩内容 列举常用的方式 # 创建归档, 把test/ test2/两个文件夹的内容进行归档 $ tar -cvf test.tar test/ test2/ # 列出tar文件的内容, 但不提取 $ tar -tf test.tar # 解压提取归档的内容 $ tar -xvf test.tar ","date":"2016-12-26","objectID":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/:5:0","tags":["shell"],"title":"shell常用小手册","uri":"/posts/shell%E5%B8%B8%E7%94%A8%E5%B0%8F%E6%89%8B%E5%86%8C/"},{"categories":null,"content":" 整理Android群英传和网上出现的比较完整AS的快捷小技巧. mac版已测, win大部分测试. 最后有一个整理的完整快捷键表格. win也好mac也好, 如果快捷被修改还是错误, 都可以通过提供的Keymap中的关键字来进行重设. 图中gif如果看不清, 放大页面即可. 转载标明出处: 作者GitHub 博客地址 ","date":"2016-12-17","objectID":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/:0:0","tags":["android"],"title":"Android Studio 常用手册","uri":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"常用小操作 ","date":"2016-12-17","objectID":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/:1:0","tags":["android"],"title":"Android Studio 常用手册","uri":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"单词选择 一般IDE通过option + 方向键左右(win为ctrl + 左右方向键)对光标进行单词的跳动, 但是由于我们使用驼峰式命名较多, 默认的会导致由多个单词组成的驼峰式的首尾跳转. 还好AS可以对这种风格进行设定. 默认效果 修改后的效果 修改步骤 打开偏好设置如图片设置 虽然单词跳着爽了, 但是当你想复制这个变量名双击的时候. 只会复制变量名中的某一个单词. 而不是像以前会复制空格分割两边的完整字符串. 反正我是用了不到一天有些不舒服就切换回原来的风格了. 但是option + 左右方向键这个小技巧用熟了, 比特意用鼠标点,或者光标一下下移动到目标位置会高效很多. ","date":"2016-12-17","objectID":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/:1:1","tags":["android"],"title":"Android Studio 常用手册","uri":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"显示最近操作, 修改的文件 例如: 我打开了main_activity.xml布局文件, 然后关闭页面. 这个时候Command + E, 就会如下显示之前的操作文件. 那么如果要查看之前修改过的文件, Command + Shift + E即可. 可以配合Control + Tab进行快速界面的切换. 快捷键 最近操作 Command + E (mac) ctrl + E (win) 最近修改 Command + Shift + E (mac) ctrl + shift + E (win) ","date":"2016-12-17","objectID":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/:1:2","tags":["android"],"title":"Android Studio 常用手册","uri":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"文件查找 search Everywhere 项目中的全局查找功能文件功能 查找类文件 command + o (mac) ctrl + n (win) 默认只是在项目代码中查找类文件, 如果需要查找sdk或者类库中的相关类. 再按一次快捷键, 或者勾选下图选项搜索全局类文件 查找文件 这个级别比上面那个更广. 包括所有文件, 如xml等. command + shift + o (mac) ctrl + shift + n (win) 如上如果需要搜索类库或者源码, 请在按一次快捷键, 或者勾选查找类给出图中的选项. ","date":"2016-12-17","objectID":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/:1:3","tags":["android"],"title":"Android Studio 常用手册","uri":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"操作记录 在浏览代码结构的时候, 很多时候总是会跟进许多类里面, 如果想回到之前浏览调转点. 那么这个快捷键你就必须要记住. Command + Option + Left\\Right 或者 command + [, command + ] (mac) ctrl + alt + Left\\Right(win) ","date":"2016-12-17","objectID":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/:1:4","tags":["android"],"title":"Android Studio 常用手册","uri":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"移动行 这个不用太多介绍, 就是整行的上下移动. Option + shift + 方向键上\\方向键下 (mac) alt + shift + 方向键上\\方向键下 (win) ","date":"2016-12-17","objectID":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/:1:5","tags":["android"],"title":"Android Studio 常用手册","uri":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"查找方法调用处 场景: 查找一个方法在何处被调用, 或者一个ID在哪里被引用. 选中这个方法右键, 选择Find Usages即可. 快捷键: option + F7 (mac) alt + F7 (win) ","date":"2016-12-17","objectID":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/:1:6","tags":["android"],"title":"Android Studio 常用手册","uri":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"方法的跟进 方法总是伴随着调转, 我们也总是会对方法的内部查看细节. 常用的办法是按住Command 并点击方法名的方式. 也可以在光标所在处直接通过Command + B进行方法内部跟进. Command + B (mac) ctrl + alt + B (win) ","date":"2016-12-17","objectID":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/:1:7","tags":["android"],"title":"Android Studio 常用手册","uri":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"显示方法的参数 当我们使用一个方法的时候, 会在刚开始的时候显示出所有的参数. 但是过一会可能就不存在了. 这个时候如果你想知道下一个参数是什么类型, 或者看一下所有参数. 快捷键: command + P (mac) ctrl + P (win) 如果你还想查看一下方法的文档, 不用跟进源码, 直接F1键即可显示出文档. ","date":"2016-12-17","objectID":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/:1:8","tags":["android"],"title":"Android Studio 常用手册","uri":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"行的快速操作 快速删除行, 其实使用剪切功能就可以Command + X 快速复制行, 使用command + Dmac, ctrl + Dwin ","date":"2016-12-17","objectID":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/:1:9","tags":["android"],"title":"Android Studio 常用手册","uri":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"多行操作 可能有时候我们会声明做一系列相关的变量为float类型, 但是真实的需要的是int类型. 这个时候就可以进行多重选择进行整体修改. 如下图: 按住option(win为alt)键, 然后鼠标进行区域的选择. 然后进行对应修改即可. 你可能认为上面的必须要连续的才可以. 那么如果可以设置多个光标点是否就可以满足你的问题了? 看下图: option + shift + 鼠标点击 (mac) alt + shift + 鼠标点击(win) 即可添加一个编辑光标. 最后如果不需要那么就esc即可关闭多余光标. ","date":"2016-12-17","objectID":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/:1:10","tags":["android"],"title":"Android Studio 常用手册","uri":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"快速补全完成 创建一个对象. 或者findViewById()有时总需要移动鼠标或者光标到末尾进行分号的补全. 这些都可以快捷键搞定. 当你用习惯之后, 会非常的方便好用. command + shift + enter(mac) ctrl + shift + enter(win) 实现的功能 方法体大括号的添加 行尾分号的添加 自动格式化改行操作等 ","date":"2016-12-17","objectID":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/:1:11","tags":["android"],"title":"Android Studio 常用手册","uri":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"代码提示 任何地方都可以调出的代码提示. control + option + /(不是默认, mac默认为control + space). 这里要说的是. 代码提示之后一般都会回车键确定. 当按回车键的时候. 会保留光标之后的内容. 当有的时候我们并不需要. 这个时候你就可以使用table键进行选择. 它会将后面的输入内容删掉. win的快捷方式ctrl + 空格(win同样大部分和输入法冲突, 请手动在AS设置里面keymap项查找 completion basic手动修改快捷键) 快速生成变量 比如在方法体中logi直接快速生成一个log日志输出的模板, 但是TAG这个常量还没有声明. 这个时候用光标移动到TAG上. 使用快捷键提示即可快速生成. option + enter(mac) alt + enter(win) ","date":"2016-12-17","objectID":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/:1:12","tags":["android"],"title":"Android Studio 常用手册","uri":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"变量的快速操作 上图使用了两次快捷键, 第一次: 跳转到变量的声明处 command + B (mac) ctrl + b (win) 第二次: 跳转到变量类型的定义处 command + shift + B (mac) ctrl + shift + b (win) ","date":"2016-12-17","objectID":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/:1:13","tags":["android"],"title":"Android Studio 常用手册","uri":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"代码折叠 对代码块进行折叠和展开. command + 加号\\减号(mac) ctrl + 加号\\减号 (win) ","date":"2016-12-17","objectID":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/:1:14","tags":["android"],"title":"Android Studio 常用手册","uri":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"预览方法定义 如果只想大体了解方法的定义, 而不需要进行方法所在源码类的跳转显示. 可以通过Command + Y (win快捷键为ctrl + shift + I)来进行预览 ","date":"2016-12-17","objectID":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/:1:15","tags":["android"],"title":"Android Studio 常用手册","uri":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"粘贴板管理 对于复制粘贴. 我们习惯只是单次的c+v, 那么如果你想查看之前被覆盖了的复制过的内容. AS同样有复制粘贴板来管理. 展示最近几次的复制内容. command + shift + v (mac) ctrl + shift + v (win) ","date":"2016-12-17","objectID":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/:1:16","tags":["android"],"title":"Android Studio 常用手册","uri":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"拆分窗口 只需要在标签页上右键. 选择split vertical\\horizontal. ","date":"2016-12-17","objectID":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/:1:17","tags":["android"],"title":"Android Studio 常用手册","uri":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"变量命名风格 对于成员变量应该m开头. 对于静态成员通常是s开头. 可以这样设置这个风格. 这样在输入一个变量的名字时, 就可以自动补全m或者s. 同时在Extra代码的时候, 生成的代码都可以自动根据这个规则重构. ","date":"2016-12-17","objectID":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/:1:18","tags":["android"],"title":"Android Studio 常用手册","uri":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"查看大纲 当一个类很大的时候. 可以通过command + F12(win为ctrl + F12) 打开大纲界面. 展示全部的方法和成员变量列表. 并且支持模糊搜索. 来进行筛选显示. 可以快速的找到要搜索的方法集. ","date":"2016-12-17","objectID":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/:1:19","tags":["android"],"title":"Android Studio 常用手册","uri":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"书签 在浏览大型代码, 或者调试时. 有时可能会需要记住一些关键的代码或者方法. 这个时候就可以使用书签. 来记录此关键代码. 只需要在点击需要标记的行, 并按F3就会在左侧出现一个小对勾. 这就说明已经打上了一个书签. 同时在Favorites标签中, 也可以找到对应的Bookmarks 可以通过快捷键command + F3 (win为shift + F11)快速调出书签面板, 进行后续的操作. ","date":"2016-12-17","objectID":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/:1:20","tags":["android"],"title":"Android Studio 常用手册","uri":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"快速重构 ","date":"2016-12-17","objectID":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/:2:0","tags":["android"],"title":"Android Studio 常用手册","uri":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"重构入口 当一个代码片段准备重构的时候. 可以使用control + T (win为ctrl + alt + shift + T)打开重构入口. 或者右键单击选择Refactor显示重构界面. 这里有很多方便的功能. 提成方法等等. ","date":"2016-12-17","objectID":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/:2:1","tags":["android"],"title":"Android Studio 常用手册","uri":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"surround With 当对一个段代码进行, 条件包裹, 捕捉异常, 循环, Runnable等. 可以直接使用快捷的方式, 而不需要手动生成条件在进行代码块的复制-粘贴 快捷键 command + option + T(mac) ctrl + alt + T(win) ","date":"2016-12-17","objectID":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/:2:2","tags":["android"],"title":"Android Studio 常用手册","uri":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"Extract 你可以经常使用它,提取出一个方法. 不仅仅如此, 你还可以对xml中的多个控件相同的属性进行抽取为style 是不是很爽? 这是其一, 对于xml不仅可以抽取Style, 还可以抽取布局Layout 而代码中, 可以提取各种变量, 参数, 长廊. ","date":"2016-12-17","objectID":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/:2:3","tags":["android"],"title":"Android Studio 常用手册","uri":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"代码模板 AS中已经内置了很多代码模板, 你可以很嗖嗖嗖的就完成之前倒背如流的代码. 如下一小部分 通过快捷键可调出这些代码模板 command + J(mac) ctrl + J(win) ","date":"2016-12-17","objectID":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/:3:0","tags":["android"],"title":"Android Studio 常用手册","uri":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"代码分析 Google提供了很多代码分析工具, 这些工具都集中在顶部菜单栏的Analyze中. ","date":"2016-12-17","objectID":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/:4:0","tags":["android"],"title":"Android Studio 常用手册","uri":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"Inspect Code \u0026 Code cleanup Inspect Code可以让IDE分析整个工程. 类似于Lint分析, 并会给出大致修改意见等 Code cleanup功能可以进行自动的代码修复. ","date":"2016-12-17","objectID":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/:4:1","tags":["android"],"title":"Android Studio 常用手册","uri":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"Dependencies 通过Analyze中的几个Dependencies选项. 可以快速分析项目的依赖. ","date":"2016-12-17","objectID":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/:4:2","tags":["android"],"title":"Android Studio 常用手册","uri":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"方法调用栈 对于某些方法来说, 查看它被调用的地方和调用的顺序是非常重要的. 可通过control + option + H快速查找方法调用栈. ","date":"2016-12-17","objectID":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/:4:3","tags":["android"],"title":"Android Studio 常用手册","uri":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"断点调试 ","date":"2016-12-17","objectID":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/:5:0","tags":["android"],"title":"Android Studio 常用手册","uri":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"快速断点 条件断点. 主要用在循环体内. 一个循环10次的for. 只想在第8次进入断点. 和普通断点相似, 一样先声明一个断点. 然后在普通断点上单击鼠标右键. 在弹出的菜单填写断点条件即可. 如下: 上面图中Enable可以控制启用, 还是停用一个断点. 临时断点. 如果需要一个只执行一次的断点. 执行完之后断点自动取消. 那么可以通过快捷点将当前行作为临时断点. command + option + shift + F8 ctrl + alt + shift + F8 为了篇幅不是很长, 调试的部分贴一个讲解很详细的帖子 Android Studio代码调试大全 ","date":"2016-12-17","objectID":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/:5:1","tags":["android"],"title":"Android Studio 常用手册","uri":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/"},{"categories":null,"content":"快捷键查找表 功能描述 keymap对应名字 Mac Win/Linux 提示错误解决方案 Show Intention Actions option + enter alt + enter AS配置界面 Preferences command + , control+alt+S 工程项目配置界面 Project Structure command + ; Control＋Alt+Shift+S 快速构成代码 Code Generate command + N alt + insert 代码提示 Completion/Basic control + space(mac会冲突, 手动修改) ctrl + 空格(win同样大部分和输入法冲突, 手动修改) 选择视图 select in any view option + F1 alt + F1 添加书签标识 Toggle Bookmark option + F3 ctrl + F11 向下移动一行 Move Line Down option + shift + Down alt + shift + Down 向上移动一行 Move Line Up option + shift + Up alt + shift + Up 注释代码 Comment with Line Comment command + / ctrl + / 用代码模板包裹代码 surround with Live Template command + option + J ctrl + alt + J 格式化代码 Reformat Code command + option + L ctrl + alt + L Copy Reference Copy Reference command + option + shift + C ctrl + alt + shift + C if/try等包裹代码 Surround With.. command + option + T ctrl + alt + T 查看声明 Declaration command + B ctrl + B 快捷向下复制行 Duplicate Line or Block command + D ctrl + D 删除行 Delete Line command + delete ctrl + Y 快捷最近打开 Recent Files command + E ctrl + E 查找 Edit/Find/Find command + F ctrl + F 文件方法结构 File Structure command + F12 ctrl + F12 显示书签 Show Bookmarks command + F3 shift + F11 代码高亮向下查找 Move To Next Occurrence command + G F3 代码高亮向上查找 Move To Previous Occurrence command + shift + G shift + F3 按照模板生成代码 Insert Live Template command + J ctrl + J 定位到行 Navigate/Line command + L ctrl + G 快速到行首/尾 Move Caret to Line Start/End command + Left/Right ctrl + Left/Right 代码折叠/展开 Collapse/Expand command + 减号/加号 ctrl + 减号/加号 查找类 Navigate/Class command + O ctrl + N 多行注释 **Code/Comment ** command + option + / ctrl + alt + / 格式化代码 Reformat Code command + option + L ctrl + alt + L 提示参数类型 Parameter Info command + P ctrl + P 查找替换 Replace command + R ctrl + R 查找命令 Find Action command + shift + A ctrl + shift + A 拷贝文件路径 Copy Paths command + shift + C ctrl + shift + C 移动代码块 Move Statement Up/Down command + shift + down/up ctrl + shift + down/up 代码补全 Complete Current Statement command + shift + enter ctrl + shift + enter 全路径查找 Find in Path command + shift + F ctrl + shift + F 代码高亮 Highlight Usages in File command + shift + F7 alt + J 窗口内所有代码折叠/展开 Collapse/Expand All command + shift + 减号/加号 ctrl + shift + 减号/加号 查找文件 Navigate/File command + shift + O ctrl + shift + N 全路径中替换 Replace in Path command + shift + R ctrl + shift + R 大小写转换 Toggle Case command + shift + U ctrl + shift + U 显示粘贴版历史 Paste from History command + shift + V ctrl + shift + V 快速查找定义 command + space ctrl + shift + I 粘贴 Paste command + V ctrl + V 复制 Copy command + C ctrl + C 去除无效包引用 Optimize Imports control + option + O ctrl + alt + O 显示类关系继承体系 Type Hierarchy control + H ctrl + H 快速覆写方法 override Methods control + O ctrl + O 查找调用的位置 Call hierarchy control + option + H ctrl + alt + H 添加书签 Toggle Bookmark F3 F11 扩大缩小选中范围 Extend Selection/Shrink Selection option + UP/Down ctrl + W + shift + W 跳转到父类 Super method command + U ctrl + U 关闭当前tab标签 Editor Tabs / Close command + W ctrl + shift + a 关闭除编辑窗口的其余窗口 Hide All Tool Windows command + shift + F12 ctrl + shift + F12 预览方法定义 Quick Definition command + Y ctrl + shift + I 返回光标最后编辑位置 Last Edit Location command + shift + delete control + shift + Backspace 调到代码块首部/尾部 Move Caret To Code Block Option + Command + [ 或者 ] Control+[ 或者 ] 重命名 Rename shift + F6 shift + F6 抽取方法 Extract Method command + option + M control+alt+M 抽取变量 Extract Variable command + option + V control+alt+V 抽取字段 Extract Field command + option + F control+alt+F 抽取常量 Extract Constant command + option + C control+alt+C 抽取参数 Extract Parameter command + option + P control+alt+P 重构入口 Refactor This control + T ctrl + alt + shift + T 转载标明出处: 作者GitHub 博客地址 ","date":"2016-12-17","objectID":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/:6:0","tags":["android"],"title":"Android Studio 常用手册","uri":"/posts/android-studio-%E5%B8%B8%E7%94%A8%E6%89%8B%E5%86%8C/"},{"categories":null,"content":" 一年快要过去了, 你的目标实现了么? 不管实现没有, 先来个小目标吧.比如造一个轮子? 说点题外话. Coding中我们总是经历着这么几个过程. 学会使用: 不管是API也好, 开源库也好. 总是在最开始的学会去用. 了解实现原理: 可能会因为一些不兼容, 代码的异常状态的处理不够完美等需要查看实现并修改, 或者因为你有一个好奇心向窥探一下内部实现.. 这时我们开始试着去阅读, 试着去理解. 是否可以自己写一个更好的?: 这个时候你可能已经熟悉了一个模块需要如何去写. 如何构造出一个别人没有或者扩展了新功能的一个小Demo. 终极目标: 写出了一个功能效果更酷的Demo, 但是这个是否是就变成了一个好的开源库? 不, 一个好的开源库不仅功能强大实用, 并且还有一个不容忽视的特点可扩展. 这一个比较好的状态. 可以扩展, 通过对出现的问题不断完善, 慢慢的就会演变成一个强大的库 是否造轮子, 每个人看法都不一样, 我认为造轮子最起码的好处如下两点, 当然你得有时间!!! 对知识的全面理解的最好实践, 会一个知识点, 需要写一个小Demo巩固, 小Demo放在项目中又会面临实际场景中可能没有想到的问题. 所以尽量不要只做到浅尝辄止. 如果不错, 或许可以帮助别人, 能帮到别人, 这应该会让自己在学习知识巩固知识的喜悦上更开心. 当然, 对于苦逼的码农来说, 不停的bug不停的需求. 这是比较蛋疼的. 没有时间可能会阻碍到自己去学习进步. 看过第一弹的应该看到我列出了三个阶段. 结果差不多是自己挖个坑自己跳了进去. 还好大体目标还是完成了. 好了, 开始说SImageView控件把. ","date":"2016-12-14","objectID":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B62/:0:0","tags":["android","自定义View"],"title":"年终福利-一个实用方便的图片控件SImageView(第二弹)","uri":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B62/"},{"categories":null,"content":"控件介绍 这是一个简单到sImageView.setImageUrls(\"http://img3.cache.netease.com/ent/2009/4/17/20090417104402666a4.jpg\");设置一个网址即可显示图片的控件 相对ImageView功能的扩展的控件, 但是没有继承ImageView直接继承的View. 比如QQ群组头像,微信群组头像, 设置描边, 设置圆角矩形头像,圆形头像等. 几个参数搞定. 对于多个图片的排列和图片的具体显示进行了接口分离. 可以自定义实现任何排列效果和显示效果. 网络图片的下载会原图缓存磁盘, 并根据控件的大小加载到到内存并使用显示. 项目地址 ","date":"2016-12-14","objectID":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B62/:1:0","tags":["android","自定义View"],"title":"年终福利-一个实用方便的图片控件SImageView(第二弹)","uri":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B62/"},{"categories":null,"content":"效果展示 图片可能比较大, 如果不出现, 刷新页面试试或者多等一会. 可以实现的样式 ","date":"2016-12-14","objectID":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B62/:2:0","tags":["android","自定义View"],"title":"年终福利-一个实用方便的图片控件SImageView(第二弹)","uri":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B62/"},{"categories":null,"content":"使用说明 ","date":"2016-12-14","objectID":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B62/:3:0","tags":["android","自定义View"],"title":"年终福利-一个实用方便的图片控件SImageView(第二弹)","uri":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B62/"},{"categories":null,"content":"引用方式 rootDir/app/build.gradle文件 dependencies { // ... compile 'com.szysky.customize:simageview:2.2'; } ","date":"2016-12-14","objectID":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B62/:3:1","tags":["android","自定义View"],"title":"年终福利-一个实用方便的图片控件SImageView(第二弹)","uri":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B62/"},{"categories":null,"content":"xml声明方式 \u003cLinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"\u003e \u003c!--简单的配置, 默认为圆形图像,无描边--\u003e \u003ccom.szysky.customize.siv.SImageView xmlns:app=\"http://schemas.android.com/apk/res-auto\" app:img=\"@mipmap/icon_test\" android:layout_width=\"200dp\" android:layout_height=\"200dp\" /\u003e \u003c!--稍微完全的配置范例, 下面会有属性的详细说明--\u003e \u003ccom.szysky.customize.siv.SImageView android:id=\"@+id/siv_main\" android:layout_width=\"match_parent\" android:layout_height=\"200dp\" android:background=\"@color/colorAccent\" app:displayType=\"rect\" app:border_color=\"@color/colorPrimary\" app:border_width=\"1dp\" app:img=\"@mipmap/ic_1\" app:scaleType=\"fix_XY\"/\u003e \u003c/LinearLayout\u003e 属性说明 displayType 设置控件中的图片要以什么类型显示. 可选值如下: circle: 圆形图片. (控件的默认值) rect: 矩形图片. round_rect: 圆角矩形图片. oval: 椭圆形图片 five_pointed_star: 五角星形图片 border_color\" 图片描边颜色. 只有当border_width\u003e0的时候才有效. 默认是黑色. border_width 图片描边的宽度. 默认值为0, 不显示描边. img 前景图片, 以上所有的效果, 都是对前景图片进行操作处理. scaleType 类似于ImageView的图片缩放选择. 只有当displayType=\"rect\"是矩形, 并且border_width=0dp条件下才有效果. 其余场景无意义.可选值如下: center_inside : 保持图片的完整性缩放, 可能会留白, 图片比例不变 center_crop : 保持控件全部被图片填充. 图片部分可能丢失, 图片比例不变. fix_XY : 保持图片的完整性并且控件被全部填充. 图片不会丢失, 不会留白. 图片比例会改变. ","date":"2016-12-14","objectID":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B62/:3:2","tags":["android","自定义View"],"title":"年终福利-一个实用方便的图片控件SImageView(第二弹)","uri":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B62/"},{"categories":null,"content":"代码设置形式 最简单暴力的设置方式 // 查找控件 SImageView sImageView = (SImageView) findViewById(R.id.siv_main); // 直接设置一个图片URL即可, 根据控件大小进行内存缓存, 保存原图到本地磁盘缓存 sImageView.setImageUrls(\"http://img3.cache.netease.com/ent/2009/4/17/20090417104402666a4.jpg\"); 关于群组头像 // 如果你想实现QQ群组效果, 很简单因为默认是圆形类型显示, 不需要多余设置 // 直接传入多个URL, 最多支持5张. 例如 sImageView.setImageUrls( \"http://img3.cache.netease.com/ent/2009/4/17/20090417104402666a4.jpg\", \"http://img3.cache.netease.com/ent/2009/4/17/20090417104402666a4.jpg\", \"http://img3.cache.netease.com/ent/2009/4/17/20090417104402666a4.jpg\", \"http://img3.cache.netease.com/ent/2009/4/17/20090417104402666a4.jpg\", \"http://img3.cache.netease.com/ent/2009/4/17/20090417104402666a4.jpg\"); // 需要微信的样式, 那么改一下 布局管理器 , 并设置显示图片类型为 矩形, // 最多支持9张. 如下 sImageView.setDisplayShape(SImageView.TYPE_RECT) .setLayoutManager(new WeChatLayoutManager(getApplicationContext())) .setImageUrls( \"http://img3.cache.netease.com/ent/2009/4/17/20090417104402666a4.jpg\", \"http://img3.cache.netease.com/ent/2009/4/17/20090417104402666a4.jpg\", \"http://img3.cache.netease.com/ent/2009/4/17/20090417104402666a4.jpg\", \"http://img3.cache.netease.com/ent/2009/4/17/20090417104402666a4.jpg\", \"http://img3.cache.netease.com/ent/2009/4/17/20090417104402666a4.jpg\"); 以下是常用方法 SImageView sImageView = (SImageView) itemView.findViewById(R.id.siv); // 设置描边颜色 sImageView.setBorderColor(Color.GREEN); // 设置描边宽度 单位dp值 sImageView.setBorderWidth(1); // 设置图片显示类型 // 可设置类型: SImageView.TYPE_CIRCLE(默认), SImageView.TYPE_OVAL, // SImageView.TYPE_RECT, SImageView.TYPE_ROUND_RECT, // SImageView.TYPE_FIVE_POINTED_STAR sImageView.setDisplayShape(SImageView.TYPE_ROUND_RECT); // 设置图片的缩放类型, 只有显示类型为矩形, 并且描边宽度为0. 才有效果. 区别在xml中有说明 // 可选类型3种:SCALE_TYPE_CENTER_INSIDE(默认), // SCALE_TYPE_FIX_XY ,SCALE_TYPE_CENTER_CROP mSImageView.setScaleType(SImageView.SCALE_TYPE_CENTER_INSIDE); // 设置微信群组样式显示. (可以自定义measure测量排列规则)替换measure测量策略如下: // 默认为qq群组的测量策略. 只要设置图片时传入多张图片的集合即可. sImageView.setLayoutManager(new WeChatLayoutManager(context)); // 不仅可以设置url数组, 还支持其他设置图片方式 sImageView.setImages(List\u003cBitmap\u003e); // 接收一个bitmap集合, 实现qq群组或者微信群组效果 sImageView.setIdRes(id); // 接收图片资源id sImageView.setDrawable(Drawable); // 接收一个Drawable对象 sImageView.setBitmap(Bitmap); // 接收一个图片的bitmap ","date":"2016-12-14","objectID":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B62/:3:3","tags":["android","自定义View"],"title":"年终福利-一个实用方便的图片控件SImageView(第二弹)","uri":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B62/"},{"categories":null,"content":"加载中的图片和加载失败的图片设置 对于网络下载图片. 会有下载失败和下载中的图片显示. 默认图片加载类ImageLoad类中会内置两张系统两个对应图片来显示. ImageLoad类中的加载中和加载失败图片会作用于全局的SImageView控件. 也可以给SImageView控件实例设置. 如果控件设置了. 那么优先级会比全局ImageLoad中的图片使用优先. 如果控件没有, 那么就使用全局. 代码设置如下: // 设置当前控件的场景图片, 优先级高于全局 sImageView.setErrPicResID(R.mipmap.ic_launcher) // 设置加载错误图片 .setLoadingResID(R.mipmap.icon_test) // 设置加载中图片 .setImageUrls(\"http://xxx.jpg\"); // 图片故意填写一个错误 // 对于图片网址满足条件 判断正则为: \"https?://.*?.(jpg|png|bmp|jpeg|gif)\" //如果不满足, 那么会认为是一个错误地址, 可动态配置, 后面说明 // 设置全局控件场景图片, (有默认图片可以不设置) ImageLoader.getInstance(getApplicationContext()).setLoadErrResId(R.mipmap.icon_test); ImageLoader.getInstance(getApplicationContext()).setLoadingResId(R.mipmap.ic_launcher); ","date":"2016-12-14","objectID":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B62/:3:4","tags":["android","自定义View"],"title":"年终福利-一个实用方便的图片控件SImageView(第二弹)","uri":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B62/"},{"categories":null,"content":"控件其他的方法 方法名称 参数说明 方法作用 setCloseNormalOnePicLoad() 布尔值 设置true可以强制关闭一张图片时候的默认单张图片处理规则, 而由测量接口,绘制显示接口处理. setOvalRatio() float类型, 椭圆的宽高比值(必须大于0) 在单张图片并且椭圆类型显示时, 设置椭圆的显示的宽高比例 setRectRoundRadius() float类型, 设置范围0~2,默认1 在单张图片并且圆角矩形类型显示时, 设置圆角的弧度大小 setDrawStrategy() 可参考下面的扩展实现, 用来设置自定义图片实现策略 setLayoutManager() 可参考下面的扩展实现, 用来设置自定义或替换 图片的排列分布规则 对应的getter()方法省略. ","date":"2016-12-14","objectID":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B62/:3:5","tags":["android","自定义View"],"title":"年终福利-一个实用方便的图片控件SImageView(第二弹)","uri":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B62/"},{"categories":null,"content":"设置图片网址匹配 上面提到过默认过滤图片链接的正则判断为\"https?://.*?.(jpg|png|bmp|jpeg|gif)\" 如果需要实现其他的地址规则. 可重定义过滤策略 ImageLoader.getInstance(getApplicationContext()).setPicUrlRegex(\"RegexStr\"); // 如果设置自定义正则之后需要恢复, 那么直接设置空串即可 ImageLoader.getInstance(getApplicationContext()).setPicUrlRegex(\"\"); ","date":"2016-12-14","objectID":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B62/:3:6","tags":["android","自定义View"],"title":"年终福利-一个实用方便的图片控件SImageView(第二弹)","uri":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B62/"},{"categories":null,"content":"输出log开关 默认类库log是不输出的, 如果需要打开如下: LogUtil.GlobalLogPrint = true; // 输出类库相关log信息 ","date":"2016-12-14","objectID":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B62/:3:7","tags":["android","自定义View"],"title":"年终福利-一个实用方便的图片控件SImageView(第二弹)","uri":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B62/"},{"categories":null,"content":"扩展实现 控件实现了measure测量布局和draw具体绘图实现的功能分离. 你可以任意实现排列规则, 和具体的绘图显示的规则. ","date":"2016-12-14","objectID":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B62/:4:0","tags":["android","自定义View"],"title":"年终福利-一个实用方便的图片控件SImageView(第二弹)","uri":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B62/"},{"categories":null,"content":"自定义measure测量布局 布局测量接口ILayoutManager. 相当于RecyclerView设置布局管理器. 或者View#onMeasure()的作用. 目前内置了2种布局来实现多张图片的排列. QQLayoutManager: 控件默认排列规则, 效果类似于qq群组头像,最大支持5张图片 WeChatLayoutManager: 效果类似于微信群组头像, 最大支持9张图片 通过setLayoutManager(ILayoutManager)来进行测量规则的具体实现类. 默认情况下, 如果控件只设置了一张图片是不会走测量的流程. 如果需要一张图片时也需要不规则的排布. 那么通过SImageView#setCloseNormalOnePicLoad(true). 强制关闭. 自定义实现: 实现ILayoutManager接口并在calculate()实现具体的排列效果. 并返回一个子图片的位置信息集合. 接口如下. 可参考已经实现的两个类. public interface ILayoutManager { /** * 布局measure排列计算方法, 具体规则由子类实现 * * @param viewWidth 控件的宽 * @param viewHeight 控件的高 * @param viewNum 控件图片的数量 * @return 返回一个信息集合, 提供 {@link com.szysky.customize.siv.effect.IDrawingStrategy#algorithm(Canvas, int, int, Bitmap, SImageView.ConfigInfo)}使用 */ ArrayList\u003cLayoutInfoGroup\u003e calculate(int viewWidth, int viewHeight, int viewNum); /** * 封装控件内部单个元素显示的布局信息 */ class LayoutInfoGroup implements Cloneable{ /** * 组合头像时, 每个单独元素可分配的最大宽高 */ public int innerWidth; public int innerHeight; /** * 每个单独元素,左上点和右下点. 可规划区域 */ public Point leftTopPoint = new Point(); public Point rightBottomPoint = new Point(); @Override protected Object clone() throws CloneNotSupportedException { LayoutInfoGroup clone = (LayoutInfoGroup) super.clone(); clone.leftTopPoint.set(leftTopPoint.x, leftTopPoint.y); clone.rightBottomPoint.set(rightBottomPoint.x, rightBottomPoint.y); return clone; } } } ","date":"2016-12-14","objectID":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B62/:4:1","tags":["android","自定义View"],"title":"年终福利-一个实用方便的图片控件SImageView(第二弹)","uri":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B62/"},{"categories":null,"content":"自定义的图片显示 控件内置了两种图片显示. 例如: 椭圆, 圆角矩形, 描边, 五角星等. 相当于View#onDraw()和Adapter#getView()作用. 具体显示分离. 绘制显示接口IDrawingStrategy 内置实现: NormalOnePicStrategy: 当控件设置单张图片时, 默认都是正中间(矩形除外, 保留了ImageView三种常用的缩放). 所以无需进行测量步骤. 直接通过配置的形状属性等进行相对应的配置实现效果. ConcreteDrawingStrategy: 当控件图片为多张的时被触发. 接收ILayoutManager#calculate()测量布局返回的子图片的信息集合, 进行具体的绘制工作. 可通过SImageView#setCloseNormalOnePicLoad(true)强制关闭控件单张图片执行NormalOnePicStrategy的逻辑. 全权由测量布局,绘制显示两个逻辑实现所有图片数量的处理. 通过setDrawStrategy(IDrawingStrategy)来进行图片绘制显示的具体策略类. 自定义绘制策略类. 实现IDrawingStrategy接口并实现对应方法, 方法里面有图片对应的画布,和需要显示的宽高信息等. 接口如下: public interface IDrawingStrategy { /** * 根据提供的画布, 和可绘制的位置实现具体效果 * * @param canvas {@link SImageView#onDraw(Canvas)} 中的画布 * @param childTotal 图片的总个数 * @param curChild 当前图片是第几张图片 * @param opeBitmap 需要操作的图片 * @param info 每个内部元素应该摆放的位置信息类 */ void algorithm(Canvas canvas, int childTotal, int curChild, Bitmap opeBitmap, SImageView.ConfigInfo info); } ","date":"2016-12-14","objectID":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B62/:4:2","tags":["android","自定义View"],"title":"年终福利-一个实用方便的图片控件SImageView(第二弹)","uri":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B62/"},{"categories":null,"content":"缓存策略自定义 这部分写的自己不是很满意, 写着写着就有点耦合了, 最后精力不够… 好吧这是借口. 反正也能将就自定义, 用默认的就行…. [捂脸] ","date":"2016-12-14","objectID":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B62/:4:3","tags":["android","自定义View"],"title":"年终福利-一个实用方便的图片控件SImageView(第二弹)","uri":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B62/"},{"categories":null,"content":"建议 尽量使控件作为头像控件显示, 如果大小低于100dp, 内部稍微做了一些特别处理. 性能可以好一些. 由于内置样式较多, 导致了cpu密集处理. 和一些对象的开销. 如果项目性能要求较高那么可通过自定义绘图策略注入控件来优化. 这样项目中常用的效果就可以得到性能提升. 类库需要写外部存储的权限, 对于新版本的动态权限, 一定要先进行权限判断, 再对ImageLoad进行初始化(控件的网络图片设置). 否则可能导致, 磁盘缓存无效只有内存缓存. 如果发现什么问题, 请提issue. 作者会抽时间去修补 ^*^. 如果看着还不错. 那么star一下吧. 项目地址 end ","date":"2016-12-14","objectID":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B62/:5:0","tags":["android","自定义View"],"title":"年终福利-一个实用方便的图片控件SImageView(第二弹)","uri":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B62/"},{"categories":null,"content":" 一年快要过去了, 你的目标实现了么? 不管实现没有, 先来个小目标吧.比如造一个轮子? 说点题外话. Coding中我们总是经历着这么几个过程. 学会使用: 不管是API也好, 开源库也好. 总是在最开始的学会去用. 了解实现原理: 可能会因为一些不兼容, 代码的异常状态的处理不够完美等需要查看实现并修改, 或者因为你有一个好奇心向窥探一下内部实现.. 这时我们开始试着去阅读, 试着去理解. 是否可以自己写一个更好的?: 这个时候你可能已经熟悉了一个模块需要如何去写. 如何构造出一个别人没有或者扩展了新功能的一个小Demo. 终极目标: 写出了一个功能效果更酷的Demo, 但是这个是否是就变成了一个好的开源库? 不, 一个好的开源库不仅功能强大实用, 并且还有一个不容忽视的特点可扩展. 这一个比较好的状态. 可以扩展, 通过对出现的问题不断完善, 慢慢的就会演变成一个强大的库 是否造轮子, 每个人看法都不一样, 我认为造轮子最起码的好处如下两点, 当然你得有时间!!! 对知识的全面理解的最好实践, 会一个知识点, 需要写一个小Demo巩固, 小Demo放在项目中又会面临实际场景中可能没有想到的问题. 所以尽量不要只做到浅尝辄止. 如果不错, 或许可以帮助别人, 能帮到别人, 这应该会让自己在学习知识巩固知识的喜悦上更开心. 当然, 对于苦逼的码农来说, 不停的bug不停的需求. 这是比较蛋疼的. 没有时间可能会阻碍到自己去学习进步. ","date":"2016-12-05","objectID":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B6/:0:0","tags":["android","自定义View"],"title":"年终福利-一个实用方便的图片控件SImageView(第一弹)","uri":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B6/"},{"categories":null,"content":"控件说明 这是一个相对ImageView功能的扩展的控件, 但是没有继承ImageView直接继承的View. 比如QQ群组头像,微信群组头像, 设置描边, 设置圆角矩形头像,圆形头像等. 直接设置即可. 对于多个图片的排列和图片的具体显示进行了接口分离. 可以自定义实现任何排列效果和显示效果. 目前只完成了第一阶段. 第一阶段(已完成): 完成开发常用的头像处理效果功能集合. 并对onMeasure``padding等进行处理, 实现一个可以工作的类. 第二阶段(下个礼拜吧): 支持图片网络地址设置, 相当于内置了图片缓存策略. 这样可以省去一些图片加载库的依赖如果项目中对图片的依赖比较严重, 对性能要求高的. 可能还得使用一些高性能的库如Fresco. 但大公司可能会有时间去自己实现的. 第三阶段(没想好..): 做一些性能优化吧 废话太多了…. 抱歉, 看效果吧 ","date":"2016-12-05","objectID":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B6/:1:0","tags":["android","自定义View"],"title":"年终福利-一个实用方便的图片控件SImageView(第一弹)","uri":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B6/"},{"categories":null,"content":"效果展示 图片可能比较大, 如果不出现, 刷新页面试试或者多等一会. 项目地址 看着还可以随手撒个星星, 鼓励鼓励新人的我吧. ","date":"2016-12-05","objectID":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B6/:2:0","tags":["android","自定义View"],"title":"年终福利-一个实用方便的图片控件SImageView(第一弹)","uri":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B6/"},{"categories":null,"content":"使用说明 ","date":"2016-12-05","objectID":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B6/:3:0","tags":["android","自定义View"],"title":"年终福利-一个实用方便的图片控件SImageView(第一弹)","uri":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B6/"},{"categories":null,"content":"xml声明方式 \u003cLinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" xmlns:app=\"http://schemas.android.com/apk/res-auto\" android:orientation=\"vertical\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\"\u003e \u003c!--范例--\u003e \u003ccom.szysky.customize.siv.SImageView android:id=\"@+id/siv_main\" android:background=\"@color/colorAccent\" android:layout_width=\"match_parent\" android:layout_height=\"200dp\" app:displayType=\"rect\" app:border_color=\"@color/colorPrimary\" app:border_width=\"1dp\" app:img=\"@mipmap/ic_1\" app:scaleType=\"fix_XY\"/\u003e \u003c/LinearLayout\u003e 属性说明 displayType 设置控件中的图片要以什么类型显示. 可选值如下: circle: 圆形图片. (控件的默认值) rect: 矩形图片. round_rect: 圆角矩形图片. oval: 椭圆形图片 five_pointed_star: 五角星形图片 border_color\" 图片描边颜色. 只有当border_width\u003e0的时候才有效. 默认是黑色. border_width 图片描边的宽度. 默认值为0, 不显示描边. img 前景图片, 以上所有的效果, 都是对前景图片进行操作处理. scaleType 类似于ImageView的图片缩放选择. 只有当displayType=\"rect\"是矩形, 并且border_width=0dp条件下才有效果. 其余场景无意义.可选值如下: center_inside : 保持图片的完整性缩放, 可能会留白, 图片比例不变 center_crop : 保持控件全部被图片填充. 图片部分可能丢失, 图片比例不变. fix_XY : 保持图片的完整性并且控件被全部填充. 图片不会丢失, 不会留白. 图片比例会改变. ","date":"2016-12-05","objectID":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B6/:3:1","tags":["android","自定义View"],"title":"年终福利-一个实用方便的图片控件SImageView(第一弹)","uri":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B6/"},{"categories":null,"content":"代码设置 以下是常用方法, SImageView sImageView = (SImageView) itemView.findViewById(R.id.siv); // 设置描边颜色 sImageView.setBorderColor(Color.GREEN); // 设置描边宽度 单位dp值 sImageView.setBorderWidth(1); // 设置图片显示类型 // 可设置类型: SImageView.TYPE_CIRCLE(默认), SImageView.TYPE_OVAL, // SImageView.TYPE_RECT, SImageView.TYPE_ROUND_RECT, // SImageView.TYPE_FIVE_POINTED_STAR sImageView.setDisplayShape(SImageView.TYPE_ROUND_RECT); // 设置图片的缩放类型, 只有显示类型为矩形, 并且描边宽度为0. 才有效果. 区别在xml中有说明 // 可选类型3种:SCALE_TYPE_CENTER_INSIDE(默认), // SCALE_TYPE_FIX_XY ,SCALE_TYPE_CENTER_CROP mSImageView.setScaleType(SImageView.SCALE_TYPE_CENTER_INSIDE); // 设置微信群组样式显示. (可以自定义measure测量排列规则)替换measure测量策略如下: // 默认为qq群组的测量策略. 只要设置图片时传入多张图片的集合即可. sImageView.setLayoutManager(new WeChatLayoutManager(context)); // 设置图片 sImageView.setImages(List\u003cBitmap\u003e); // 接收一个图片集合, 实现qq群组或者微信群组效果 sImageView.setIdRes(id); // 接收图片资源id sImageView.setDrawable(Drawable); // 接收一个Drawable对象 sImageView.setBitmap(Bitmap); // 接收一个图片的bitmap 还有一些对外的方法: 方法名称 参数说明 方法作用 setCloseNormalOnePicLoad() 布尔值 设置true可以强制关闭一张图片时候的默认单张图片处理规则, 而由测量接口,绘制显示接口处理. setOvalRatio() float类型, 椭圆的宽高比值(必须大于0) 在单张图片并且椭圆类型显示时, 设置椭圆的显示的宽高比例 setRectRoundRadius() float类型, 设置范围0~2,默认1 在单张图片并且圆角矩形类型显示时, 设置圆角的弧度大小 setDrawStrategy() 可参考下面的扩展实现, 用来设置自定义图片实现策略 setLayoutManager() 可参考下面的扩展实现, 用来设置自定义或替换 图片的排列分布规则 对应的getter()方法省略. ","date":"2016-12-05","objectID":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B6/:3:2","tags":["android","自定义View"],"title":"年终福利-一个实用方便的图片控件SImageView(第一弹)","uri":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B6/"},{"categories":null,"content":"扩展实现 控件实现了measure测量布局和draw具体绘图实现的功能分离. 你可以任意实现排列规则, 和具体的绘图显示的规则. ","date":"2016-12-05","objectID":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B6/:3:3","tags":["android","自定义View"],"title":"年终福利-一个实用方便的图片控件SImageView(第一弹)","uri":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B6/"},{"categories":null,"content":"自定义measure测量布局 布局测量接口ILayoutManager. 相当于RecyclerView设置布局管理器. 或者View#onMeasure()的作用. 目前内置了2种布局来实现多张图片的排列. QQLayoutManager: 控件默认排列规则, 效果类似于qq群组头像,最大支持5张图片 WeChatLayoutManager: 效果类似于微信群组头像, 最大支持9张图片 通过setLayoutManager(ILayoutManager)来进行测量规则的具体实现类. 默认情况下, 如果控件只设置了一张图片是不会走测量的流程. 如果需要一张图片时也需要不规则的排布. 那么通过SImageView#setCloseNormalOnePicLoad(true). 强制关闭. 自定义实现: 实现ILayoutManager接口并在calculate()实现具体的排列效果. 并返回一个子图片的位置信息集合. 接口如下. 可参考已经实现的两个类. public interface ILayoutManager { /** * 布局measure排列计算方法, 具体规则由子类实现 * * @param viewWidth 控件的宽 * @param viewHeight 控件的高 * @param viewNum 控件图片的数量 * @return 返回一个信息集合, 提供 {@link com.szysky.customize.siv.effect.IDrawingStrategy#algorithm(Canvas, int, int, Bitmap, SImageView.ConfigInfo)}使用 */ ArrayList\u003cLayoutInfoGroup\u003e calculate(int viewWidth, int viewHeight, int viewNum); /** * 封装控件内部单个元素显示的布局信息 */ class LayoutInfoGroup implements Cloneable{ /** * 组合头像时, 每个单独元素可分配的最大宽高 */ public int innerWidth; public int innerHeight; /** * 每个单独元素,左上点和右下点. 可规划区域 */ public Point leftTopPoint = new Point(); public Point rightBottomPoint = new Point(); @Override protected Object clone() throws CloneNotSupportedException { LayoutInfoGroup clone = (LayoutInfoGroup) super.clone(); clone.leftTopPoint.set(leftTopPoint.x, leftTopPoint.y); clone.rightBottomPoint.set(rightBottomPoint.x, rightBottomPoint.y); return clone; } } } ","date":"2016-12-05","objectID":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B6/:3:4","tags":["android","自定义View"],"title":"年终福利-一个实用方便的图片控件SImageView(第一弹)","uri":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B6/"},{"categories":null,"content":"自定义的图片显示 控件内置了两种图片显示. 例如: 椭圆, 圆角矩形, 描边, 五角星等. 相当于View#onDraw()和Adapter#getView()作用. 具体显示分离. 绘制显示接口IDrawingStrategy 内置实现: NormalOnePicStrategy: 当控件设置单张图片时, 默认都是正中间(矩形除外, 保留了ImageView三种常用的缩放). 所以无需进行测量步骤. 直接通过配置的形状属性等进行相对应的配置实现效果. ConcreteDrawingStrategy: 当控件图片为多张的时被触发. 接收ILayoutManager#calculate()测量布局返回的子图片的信息集合, 进行具体的绘制工作. 可通过SImageView#setCloseNormalOnePicLoad(true)强制关闭控件单张图片执行NormalOnePicStrategy的逻辑. 全权由测量布局,绘制显示两个逻辑实现所有图片数量的处理. 通过setDrawStrategy(IDrawingStrategy)来进行图片绘制显示的具体策略类. 自定义绘制策略类. 实现IDrawingStrategy接口并实现对应方法, 方法里面有图片对应的画布,和需要显示的宽高信息等. 接口如下: public interface IDrawingStrategy { /** * 根据提供的画布, 和可绘制的位置实现具体效果 * * @param canvas {@link SImageView#onDraw(Canvas)} 中的画布 * @param childTotal 图片的总个数 * @param curChild 当前图片是第几张图片 * @param opeBitmap 需要操作的图片 * @param info 每个内部元素应该摆放的位置信息类 */ void algorithm(Canvas canvas, int childTotal, int curChild, Bitmap opeBitmap, SImageView.ConfigInfo info); } 项目地址 未完待续… 后期实现支持图片链接的设置并添加内置图片缓存 ","date":"2016-12-05","objectID":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B6/:3:5","tags":["android","自定义View"],"title":"年终福利-一个实用方便的图片控件SImageView(第一弹)","uri":"/posts/%E5%B9%B4%E7%BB%88%E7%A6%8F%E5%88%A9-simageview%E5%AE%9E%E7%94%A8%E7%9A%84%E5%9B%BE%E7%89%87%E6%8E%A7%E4%BB%B6/"},{"categories":null,"content":" 列举出设计模式中的六大原则应该如何实现 ","date":"2016-11-28","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E8%A7%A3%E6%9E%90/:0:0","tags":["设计模式"],"title":"设计模式之六大原则解析","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E8%A7%A3%E6%9E%90/"},{"categories":null,"content":"单一职责原则 SRP Single Responsibility Principle 场景: 如果让你写出一个图片缓存类, 要求内部实现缓存策略, 并提供方法只需要传递控件和图片地址就可以自动设置背景的类. 先给出最简单直接的写法. public class ImageLoader { /** * 图片的缓存 */ LruCache\u003cString , Bitmap\u003e mImageCache; /** * 线程池 */ ExecutorService mExecutorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()); public ImageLoader(){ // 初始化内存缓存策略 initImageCache(); } private void initImageCache() { // 获得可使用的最大内存 final int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024); // 设置 1/4 的最大内存为作为缓存 final int cacheSize = maxMemory / 4; mImageCache = new LruCache\u003cString,Bitmap\u003e(cacheSize){ @Override protected int sizeOf(String key, Bitmap value) { // 返回缓存的bitmap大小 return value.getRowBytes() * value.getHeight() /1024 ; } }; } public void displayImage(final ImageView iv, final String imgUrl){ // 获取缓存 Bitmap bitmap = mImageCache.get(imgUrl); if(null != bitmap){ iv.setImageBitmap(bitmap); return; } // 网络加载 iv.setTag(imgUrl); mExecutorService.submit(new Runnable() { @Override public void run() { Bitmap bitmap = downloadImage(imgUrl); if (null == bitmap) return ; if (iv.getTag().equals(imgUrl)) { iv.setImageBitmap(bitmap); } mImageCache.put(imgUrl,bitmap); } }); } /** * 根据图片的url下载图片并转换成bitmap对象返回 */ public Bitmap downloadImage(String url){ Bitmap bitmap = null; try { URL url1 = new URL(url); HttpURLConnection conn = (HttpURLConnection) url1.openConnection(); bitmap = BitmapFactory.decodeStream(conn.getInputStream()); conn.disconnect(); } catch (Exception e) { e.printStackTrace(); } return bitmap; } } 对于功能来说这是没有问题的. 但是接下来分析一下. 这样写会有什么弊端. 首先这个类的职责包括了两个图片缓存的逻辑和图片下载的逻辑. 耦合性太强, 类的职责过多那么就会造成类中的代码更多,两个逻辑的代码会交叉分布. 不易被阅读. 扩展性随着后续的实现磁盘缓存修改加载图片逻辑等会让代码越来越复杂难懂. 那么重构一下, 让两个职责分离开来. /** * 处理图片的加载 */ public class ImageLoader { /** * 图片的缓存 */ ImageCache mImageCache = new ImageCache(); /** * 线程池 */ ExecutorService mExecutorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()); public void displayImage(final ImageView iv, final String imgUrl){ // 获取缓存 Bitmap bitmap = mImageCache.getCache(imgUrl); if(null != bitmap){ iv.setImageBitmap(bitmap); return; } // 网络加载 iv.setTag(imgUrl); mExecutorService.submit(new Runnable() { @Override public void run() { Bitmap bitmap = downloadImage(imgUrl); if (null == bitmap) return ; if (iv.getTag().equals(imgUrl)) { iv.setImageBitmap(bitmap); } mImageCache.putCache(imgUrl,bitmap); } }); } /** * 根据图片的url下载图片并转换成bitmap对象返回 */ public Bitmap downloadImage(String url){ Bitmap bitmap = null; try { URL url1 = new URL(url); HttpURLConnection conn = (HttpURLConnection) url1.openConnection(); bitmap = BitmapFactory.decodeStream(conn.getInputStream()); conn.disconnect(); } catch (Exception e) { e.printStackTrace(); } return bitmap; } } /** * 图片缓存逻辑处理类 */ public class ImageCache { /** * 图片的缓存 */ LruCache\u003cString , Bitmap\u003e mImageCache; public ImageCache(){ // 初始化内存缓存策略 initImageCache(); } private void initImageCache() { // 获得可使用的最大内存 final int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024); // 设置 1/4 的最大内存为作为缓存 final int cacheSize = maxMemory / 4; mImageCache = new LruCache\u003cString,Bitmap\u003e(cacheSize){ @Override protected int sizeOf(String key, Bitmap value) { // 返回缓存的bitmap大小 return value.getRowBytes() * value.getHeight() /1024 ; } }; } /** * 提供一个对 bitmap 进行缓存的方法 */ public void putCache(String imgUrl, Bitmap bitmap){ mImageCache.put(imgUrl, bitmap); } /** * 对外提供一个 获取缓存的方法 */ public Bitmap getCache(String imgUrl){ return mImageCache.get(imgUrl); } } 将原类拆分为两个类之后, 每个类的职责变得清晰. 如果需要更改缓存策略那么只需要修改ImageCache类总逻辑. 如果需要替换HttpURLConnection为OKHttp那么只需要在ImageLoader类中修改. 这样充分了体现了一个类单一职责SRP的好处, 清晰, 排除了修改时的多余干扰代码. ","date":"2016-11-28","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E8%A7%A3%E6%9E%90/:1:0","tags":["设计模式"],"title":"设计模式之六大原则解析","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E8%A7%A3%E6%9E%90/"},{"categories":null,"content":"开闭原则 OCP 全称Open Close Principle 定义: 对于对象应该对于扩展是开放的, 对于修改是封闭的. 就是在后续的功能添加的时候要尽可能做到不修改已存在的代码! 就是通过继承 接口的特性来实现的. 就是我们口中常说的面向接口编程 还是上面的代码, 这个时候我们如果想增添一个二级缓存,添加一个磁盘的缓存那么代码就如下了 /** * 磁盘缓存 */ public class DiskCache { public static final String cacheDir = \"sdcard/cache/\"; // 从磁盘中获取缓存 public Bitmap getCache(String imgUrl){ return BitmapFactory.decodeFile(cacheDir+imgUrl); } // 向磁盘中缓存 public void putCache(String imgUrl, Bitmap bitmap){ try(FileOutputStream fileOutputStream = new FileOutputStream(cacheDir+imgUrl)){ // 对bitmap压缩到本地文件 bitmap.compress(Bitmap.CompressFormat.PNG, 100, fileOutputStream); } catch (IOException e) { e.printStackTrace(); } } } // 还需要对ImageLoader类进行部分修改 只贴出添加的代码 /** * 处理图片的加载 */ public class ImageLoader { /** * 磁盘缓存 */ DiskCache mDiskCache = new DiskCache(); /** * 设置一个标记表示是否开启磁盘缓存 */ public boolean isUseDiskCache = false; public void displayImage(final ImageView iv, final String imgUrl){ // 获取缓存 Bitmap bitmap = mImageCache.getCache(imgUrl); if(null != bitmap){ iv.setImageBitmap(bitmap); return; } // 判断磁盘缓存 if (isUseDiskCache){ bitmap = mDiskCache.getCache(imgUrl); if (null != bitmap) return; } // 省略相同的网络下载代码... } public void setUseDiskCache(boolean useDiskCache) { isUseDiskCache = useDiskCache; } } 至此初步的添加功能需求已经完成, 增加了一个DiskCache类实现磁盘缓存, 并在ImageLoader类中进行判断使用的代码. 分析: 现在的加载可以有两种.一种是只使用LruCache缓存, 另一种是实现两种缓存同时实现. 那么这样的代码会有怎样的问题? 问题1: 如果想实现单磁盘缓存? 那么必须再对ImageLoader进行修改. 添加判断条件. 并且三种缓存策略if的判断也就比较多. 问题2: 如果用户想实现自定义缓存? 呵呵哒. 目前的代码没这么厉害的扩展性… 那么看一下UML类图 可以看出只要添加一个缓存策略就要建立一个依赖关系. 那么如果通过接口的方式来修改代码呢. 看一下… /** * 缓存接口 */ public interface BaseCache { // 添加缓存的抽象方法 void putCache(String imgUrl, Bitmap bitmap); // 获取缓存的抽象方法 Bitmap getCache(String imgUrl); } /** * 双缓存 */ public class DoubleCache implements BaseCache { BaseCache mMemoryCache = new ImageCache(); BaseCache mDiskCache = new DiskCache(); @Override public void putCache(String imgUrl, Bitmap bitmap) { // 缓存 mMemoryCache.putCache(imgUrl, bitmap); mDiskCache.putCache(imgUrl, bitmap); } @Override public Bitmap getCache(String imgUrl) { // 先从缓存取没有再从sd取 Bitmap cache = mMemoryCache.getCache(imgUrl); if (null == cache){ cache = mDiskCache.getCache(imgUrl); } return cache; } } /** * 图片缓存逻辑处理类 */ public class ImageCache implements BaseCache{ /** * 图片的缓存 */ LruCache\u003cString , Bitmap\u003e mImageCache; public ImageCache(){ // 初始化内存缓存策略 initImageCache(); } private void initImageCache() { // 获得可使用的最大内存 final int maxMemory = (int) (Runtime.getRuntime().maxMemory() / 1024); // 设置 1/4 的最大内存为作为缓存 final int cacheSize = maxMemory / 4; mImageCache = new LruCache\u003cString,Bitmap\u003e(cacheSize){ @Override protected int sizeOf(String key, Bitmap value) { // 返回缓存的bitmap大小 return value.getRowBytes() * value.getHeight() /1024 ; } }; } /** * 提供一个对 bitmap 进行缓存的方法 */ @Override public void putCache(String imgUrl, Bitmap bitmap){ mImageCache.put(imgUrl, bitmap); } /** * 对外提供一个 获取缓存的方法 */ @Override public Bitmap getCache(String imgUrl){ return mImageCache.get(imgUrl); } } /** * 处理图片的加载 */ public class ImageLoader { /** * 图片的缓存 默认只是内存缓存 */ BaseCache mImageCache = new ImageCache(); /** * 注入缓存策略 */ public void setmImageCache(BaseCache mImageCache) { this.mImageCache = mImageCache; } /** * 线程池 */ ExecutorService mExecutorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()); public void displayImage(final ImageView iv, final String imgUrl){ // 获取缓存 具体的缓存策略实现了依赖注入. 有调用者后续决定, 默认内存缓存 Bitmap bitmap = mImageCache.getCache(imgUrl); if(null != bitmap){ iv.setImageBitmap(bitmap); return; } // 网络加载 iv.setTag(imgUrl); mExecutorService.submit(new Runnable() { @Override public void run() { Bitmap bitmap = downloadImage(imgUrl); if (null == bitmap) return ; if (iv.getTag().equals(imgUrl)) { iv.setImageBitmap(bitmap); } mImageCache.putCache(imgUrl,bitmap); } }); } /** * 根据图片的url下载图片并转换成bitmap对象返回 */ public Bitmap downloadImage(String url){ Bitmap bitmap = null; try { URL url1 = new URL(url); HttpURLConnection conn = (HttpURLConnection) url1.openConnection(); bitmap = BitmapFactory.decodeStream(conn.getInput","date":"2016-11-28","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E8%A7%A3%E6%9E%90/:2:0","tags":["设计模式"],"title":"设计模式之六大原则解析","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E8%A7%A3%E6%9E%90/"},{"categories":null,"content":"里氏替换原则 LSP 全称Liskov Substitution Principle 定义: 所有引用基类的地方必须能透明的使用其子类. 说白了就是Java中的继承和多态的特性. 父类可以直接引用子类类型. 比如Object可以引用任何类型的概念. 其实在上面的开闭原则中就已经存在了里氏替换 /** * 注入缓存策略 */ public void setmImageCache(BaseCache mImageCache) { this.mImageCache = mImageCache; } 参数接收的BaseCache类型. 可以透明的引用任何的子类. 通过抽象实现了多种可能. 一般来说开闭原则和里氏替换是不离不弃, 生死相依的. 通过里氏替换达到了对扩展的开发, 对修改封闭的效果. 这两个原则同时实现了一个OOP的一个重要特性抽象 ","date":"2016-11-28","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E8%A7%A3%E6%9E%90/:3:0","tags":["设计模式"],"title":"设计模式之六大原则解析","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E8%A7%A3%E6%9E%90/"},{"categories":null,"content":"依赖倒置原则 DIP 全称:Dependence Inversion Principle 定义: 指代了一种特定的解耦方式, 使得高层次的模块不依赖于低层次的模块实现细节. 高层次模块不应该依赖低层次, 两者都应该依赖其抽象 抽象不应该依赖细节 细节应该依赖抽象 而在Java中的表现就是: 模块间的依赖通过抽象发生, 实现类之间不发生直接的依赖关系, 其依赖关系是通过接口或抽象产生的 直接看代码, 还是上面的ImageLoader类中 // 依赖于接口抽象, BaseCache mImageCache = new ImageCache(); // 依赖于细节, 内存缓存 ImageCache mImageCache = new ImageCache(); // 依赖于细节, 双缓存 DoubleCache mImageCache = new DoubleCache(); 如果依赖了内存缓存细节, 那么注入的缓存策略必须是ImageCache的子类. 但是这个子类已经具备一个细节的实现, 我们再去做其他细节的实现. 岂不是很怪异. 这个类中的出现的方法也是匪夷所思. 并且可能用户实现的具体策略也不一定是内存方法的缓存. 在命名上的限制也是很不友好. 总结一句话: 依赖抽象, 而不依赖具体实现 ","date":"2016-11-28","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E8%A7%A3%E6%9E%90/:4:0","tags":["设计模式"],"title":"设计模式之六大原则解析","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E8%A7%A3%E6%9E%90/"},{"categories":null,"content":"接口隔离原则 ISP 全称: Interface Segregation Principle 定义: 类间的依赖关系应该建立在最小的接口上. 接口隔离的原则就是让系统接口耦合, 从而更容易重构, 更改和重新部署. 对于操作IO或者网络我们总是需要在finally中确保资源的释放. 如下 FileOutputStream fileOutputStream = null; try{ fileOutputStream = new FileOutputStream(cacheDir+imgUrl); bitmap.compress(Bitmap.CompressFormat.PNG, 100, fileOutputStream); }catch (IOException e) { e.printStackTrace(); }finally { try { fileOutputStream.close(); } catch (IOException e) { e.printStackTrace(); } } 这是多么蛋疼的代码… 一堆堆的花括号. 对于可关闭的对象, 都具备一个接口Closeable. 这个接口一个空接口, 也就是标识接口. 作用? 就是标识这个对象可以调用close()被关闭. 体现了一类对象的某一个特性. 而且这个特性建立在了最小接口的原则上. 那么编写这么一段代码 public class CloseUtils { // 整个方法通过最小接口的特性, 实现了隔离其他无用的属性. 只关心 // Closeable接口即可. 接口隔离 // 参数 对应了里氏替换的原则 public static void fastClose(Closeable closeObj){ if (null != closeObj){ try { // close()方法的调用, 对应了 依赖倒置原则 closeObj.close(); } catch (IOException e) { e.printStackTrace(); } } } } 之前的代码调用就变成了 FileOutputStream fileOutputStream = null; try{ fileOutputStream = new FileOutputStream(cacheDir+imgUrl); bitmap.compress(Bitmap.CompressFormat.PNG, 100, fileOutputStream); }catch (IOException e) { e.printStackTrace(); }finally { CloseUtils.fastClose(fileOutputStream); } 不仅简单, 而且方便到处调用, 看起来也舒服多了. ","date":"2016-11-28","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E8%A7%A3%E6%9E%90/:5:0","tags":["设计模式"],"title":"设计模式之六大原则解析","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E8%A7%A3%E6%9E%90/"},{"categories":null,"content":"迪米特原则 LOD Law of Demeter 就是一个对象应该尽可能少的关联其他对象. 通俗讲, 一个类应该对自己需要耦合或调用的类知道的最少, 类的内部如何实现与调用者或者依赖者没有关系, 调用者或者依赖者只需要知道他需要的方法即可, 其他的一概不关心. 因为类与类之间的关系越密切, 耦合度也就越大, 当一个类发生改变时, 对另一个类的影响也会变大. 太懒了, 无具体实现… ","date":"2016-11-28","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E8%A7%A3%E6%9E%90/:6:0","tags":["设计模式"],"title":"设计模式之六大原则解析","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%E8%A7%A3%E6%9E%90/"},{"categories":null,"content":"前一节, 对Window和WindowManager进行了分析, blog, 其中的WMS是不容忽视的角色 关于Android的framework层主要就是由它与另外一个系统服务ActivityManagerService和View构成, 这三个模块穿插在整个framework中. 和其他系统服务一样, WMS也是由SystemServer启动的. 调用了WMS#main()静态方法来构建的对象. 之后其他进程就可以通过ServiceManger查询window来获取WMS. main()比较简单就是通过Handler#runWithScissors()方法执行一个特殊的同步Task并在其中构造WMS的实例 WMS的构造方法主要是对一些窗口管理将要使用到的成员变量进行初始化 private WindowManagerService(Context context, InputManagerService inputManager, boolean haveInputMethods, boolean showBootMsgs, boolean onlyCore) { // 成员变量的赋值 mContext = context; // .... // 获取显示服务 mDisplayManager = (DisplayManager)context.getSystemService(Context.DISPLAY_SERVICE); // 构造APP事务对象 mAppTransition = new AppTransition(context, mH); // 获取IActivityManager对象 mActivityManager = ActivityManagerNative.getDefault(); // 构造Window对象 mAnimator = new WindowAnimator(this); // 初始化窗口管理策略 initPolicy(); // 开启Surface事务 SurfaceControl.openTransaction(); } WMS主要功能可以分为两方面, 一是对窗口的管理, 二是对事件的管理和分发. 其接口方法以AIDL的方式定义在IWindowManager.aidl文件中, 编译后生成一个对应的IWindowManager.java接口文件, 这个接口文件定义了WMS绝大部分的功能方法. 作为窗口管理承担者, WMS中定义了许多不同的窗口, 他们都被定义在WMS的成员变量中. public class WindowManagerService extends IWindowManager.Stub implements Watchdog.Monitor, WindowManagerPolicy.WindowManagerFuncs { // 已经完成启动的应用 final ArrayList\u003cAppWindowToken\u003e mFinishedStarting = new ArrayList\u003cAppWindowToken\u003e(); // 渐变窗口 final ArrayList\u003cFakeWindowImpl\u003e mFakeWindows = new ArrayList\u003cFakeWindowImpl\u003e(); // 尺寸正在改变的窗口 final ArrayList\u003cWindowState\u003e mResizingWindows = new ArrayList\u003cWindowState\u003e(); // 动画结束的窗口 final ArrayList\u003cWindowState\u003e mPendingRemove = new ArrayList\u003cWindowState\u003e(); // 即将释放Surface的窗口 final ArrayList\u003cWindowState\u003e mDestroySurface = new ArrayList\u003cWindowState\u003e(); // 失去焦点的窗口 ArrayList\u003cWindowState\u003e mLosingFocus = new ArrayList\u003cWindowState\u003e(); // 为了释放内存需要关闭的窗口 ArrayList\u003cWindowState\u003e mForceRemoves; // 正在打开的应用 final ArraySet\u003cAppWindowToken\u003e mOpeningApps = new ArraySet\u003cAppWindowToken\u003e(); // 正在关闭的应用 final ArraySet\u003cAppWindowToken\u003e mClosingApps = new ArraySet\u003cAppWindowToken\u003e(); // 当前获得焦点的窗口 WindowState mCurrentFocus = null; // 上一个获得焦点的窗口 WindowState mLastFocus = null; // 输入法窗口下方的窗口 WindowState mInputMethodTarget = null; // 输入法窗口 WindowState mInputMethodWindow = null; // 墙纸窗口 WindowState mWallpaperTarget = null; // 在切换过程中位于墙纸z-order下方的窗口 WindowState mLowerWallpaperTarget = null; // 在切换过程中位于墙纸z-order上方的窗口 WindowState mUpperWallpaperTarget = null; // 得到焦点的窗口 AppWindowToken mFocusedApp = null; } 可以看到大量的线性表应用, 不同的窗口或同一个窗口在不同的状态下可能位于不同的表中. 虽然状态较多, 但是对于Android来讲窗口可以用两种粗略的概括为应用窗口,系统窗口. 应用窗口: 就是常见的Activity,dialog,popup等都属于该类. 也可以继续分为子窗口(比如子窗口AlertDialog的常规创建需要使用activity的context). 而与应用相关的Window类主要是PhoneWindow,主要应用于手机,PhoneWindow继承与Window,核心是DecorView, 通过WindowManager进行DecorView的操作. 系统窗口: 常见的屏幕顶部的状态栏, 底部的导航栏, 桌面窗口等都是系统窗口. 系统窗口没有针对性的封装类, 只需要直接通过WindowManager直接进行View的操作即可. WMS是运行在系统进程中, 那么一个应用需要创建窗口时必然需要跨进程通信通知WMS生成一个窗口, 然后再由WMS向应用返回和窗口交互的消息. 上一篇说过, WindowManger的操作是桥接到了WindowMangerGlobal实现的具体逻辑, 最后会调用ViewRootImpl#setView()函数, 在该方法中通过addToDisplay()函数向WMS发起了一个Session请求. 最终会调用到Session#addToDisplay()函数. @Override public int addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, InputChannel outInputChannel) { return mService.addWindow(this, window, seq, attrs, viewVisibility, displayId, outContentInsets, outInputChannel); } 最后还是回到了WMS中建立连接, addToDisplay()最终返回的就是WMS#addWindow()的返回结果. WMS#addWindow()逻辑主要是先检查权限, 区分系统权限和应用权限通过PhoneWindowManager#checkAddPermission()判断窗口类型是否是系统级的. 如果不是系统级则返回一个ADD_OKAY值表示允许, 否则就需要SYSTEM_ALERT_WINDOW或者INTERNAL_SYSTEM_WINDOW的权限. 权限之后则相关Display显示信息以及窗口信息进行校队, 然后在WMS中获取对应的WindowToken, 之后根据不同的窗口类型检查窗口的有效性. 窗口的有效性检查完之后, 就会为该窗口创建一个WindowState对象类, 维护窗口的状态以及根据适当的机制来调整窗口的状态. 在WindowState对象构建完之后, 会通过mPolicy本质上就是PhoneWindowManager的adjustWindowParamsLw()函数决定该窗口是否需要获取焦点. 判断逻辑就是只要是TYPE_SYSTEM_OVERLAY或者TYPE_SECURE_SYSTEM_OVERLAY就不获取. 最后将窗口与其他相关组件关联. 在addWindow方法的最后一部分, 最重要的一步就是通过WindowState#attach()函数创建了一个关联SurfaceSession的对象以与SurfaceFlinger通信, 而SurfaceSession实际对应的就是native层中的SurfaceComposerCl","date":"2016-11-28","objectID":"/posts/windowmanagerservice/:0:0","tags":["android","framework"],"title":"WindowManagerService","uri":"/posts/windowmanagerservice/"},{"categories":null,"content":" WindowManager的重要程度不需要多说, 界面真正的显示, 外部事件的传递等. 这是一个子系统. 本章会梳理WindowManager,WindowManagerService,Surface,SurfaceFlinger之间的联系与交互的一个过程. 如果想了解不同的window级别的区别,如Activity,Dialog,Toast等请看另一篇blog 在此之前需要知道这么几件事情: 我们设置的View视图并不能直接显示在界面上. 而是需要依附在Window窗口上. 通过WindowManager操作才可以显示. Window是一个抽象的概念, 它可以说以DecorView的形式表现其存在. 代码层面Window是一个抽象类, 具体实现类是PhoneWindow ","date":"2016-11-28","objectID":"/posts/%E6%B7%B1%E5%85%A5windowmanager/:0:0","tags":["android","framework"],"title":"深入WindowManager","uri":"/posts/%E6%B7%B1%E5%85%A5windowmanager/"},{"categories":null,"content":"应用WindowManager的由来 对于重要的系统服务在手机开机的时候进行初始化, 然后保存在了系统进程中. 当我们应用启动的时候会触发ContextImpl类的加载, 在类加载的时候通过静态代码块对各个系统服务进行进行了注册,并保存到一个静态map容器中, 之后就可以通过getSystemService(serviceName)的形式获取不同的系统服务. ","date":"2016-11-28","objectID":"/posts/%E6%B7%B1%E5%85%A5windowmanager/:0:1","tags":["android","framework"],"title":"深入WindowManager","uri":"/posts/%E6%B7%B1%E5%85%A5windowmanager/"},{"categories":null,"content":"WM与Window的关联 那么当创建一个Dialog, 就需要创建一个Window, 并把Window与WM进行关联. 那么可以直接看看Dialog的构造函数是如何做的. Dialog(Context context, int theme, boolean createContextThemeWrapper) { // 从ContextImpl的集合获取WM系统服务 mWindowManager = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE); // 构建Window对象 Window w = PolicyManager.makeNewWindow(mContext); mWindow = w; // 实现Window.Callback接口, 为了后续的事件的传递 w.setCallback(this); // Window 和 WM 进行关联 w.setWindowManager(mWindowManager, null, null); } 关联的代码已经看到, 可以看一下内部调用顺序 // Window类 public void setWindowManager(WindowManager wm, IBinder appToken, String appName, boolean hardwareAccelerated) { mWindowManager = ((WindowManagerImpl)wm).createLocalWindowManager(this); } // 继续跟踪 // WindowManagerImpl类 public WindowManagerImpl createLocalWindowManager(Window parentWindow) { return new WindowManagerImpl(mDisplay, parentWindow); } 最后创建了一个WindowManagerImpl对象, 与ContextImpl注册WindowManagerImpl不同的是, 这里多了一个参数parentWindow. 这也就说此时构建的WindowManagerImpl对象是与具体的Window关联的, 刚才说到了WindowManagerImpl类. 看一下这个类的大体你会发现. 这个类没有具体的逻辑处理, 而是把所有的逻辑利用桥接模式转给了WindowMangerGlobal这个对象的对应方法. 例如addView(),removeViewImmediate(),updateViewLayout()等. ","date":"2016-11-28","objectID":"/posts/%E6%B7%B1%E5%85%A5windowmanager/:0:2","tags":["android","framework"],"title":"深入WindowManager","uri":"/posts/%E6%B7%B1%E5%85%A5windowmanager/"},{"categories":null,"content":"View的显示过程 刚才说过WindowManager的实现类WindowManagerImpl只是通过桥接模式将事件传递给了WindowManagerGlobal. 那么对应的addView()逻辑肯定也在WindowManagerGlobal中. // 手机窗口显示View的入口, View被添加到WM中 public void addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow) { // 省略非关键代码 ViewRootImpl root; View panelParentView = null; synchronized (mLock) { // 1.构建了ViewRootImpl root = new ViewRootImpl(view.getContext(), display); // 2.设置View的布局参数 view.setLayoutParams(wparams); // 3.分别对View, ViewRootImpl,param进行存储 mViews.add(view); mRoots.add(root); mParams.add(wparams); } try{ // 4.通过ViewRootImpl#setView()将View显示到手机窗口 root.setView(view, wparams, panelParentView); } } 上面的代码中出现了一个ViewRootImpl对象, 不要认为它是一个View! 它继承自Handler类,是native层和java层View系统通信的桥梁. 例如performTraversals()就是收到系统绘制的View消息后, 通过调用是视图树的各个节点的绘制流程方法如measure,layout,draw来完成整棵树的视图. WMS是运行在Native层的, 而现在只是在Framewrok层. 那么之间的是如何建立联系的? ","date":"2016-11-28","objectID":"/posts/%E6%B7%B1%E5%85%A5windowmanager/:0:3","tags":["android","framework"],"title":"深入WindowManager","uri":"/posts/%E6%B7%B1%E5%85%A5windowmanager/"},{"categories":null,"content":"Native和Framework的连接 既然ViewRootImpl是通信的桥梁, 那么就看看其构造函数的创建. public ViewRootImpl(Context context, Display display) { // 省略非重要代码 // 获取Window Session, 也就是与WindowManagerService建立连接 mWindowSession = WindowManagerGlobal.getWindowSession(); // 保存创建本对象时的线程, 用于在更新UI的时候只能是mThread线程的条件判断 // 这也就为什么需要在UI线程才可以更新, 因为`ViewRootImpl`是在UI线程创建的 mThread = Thread.currentThread(); } 继续看看getWinSession()这个重要的函数 // WindowManagerGlobal public static IWindowSession getWindowSession() { synchronized (WindowManagerGlobal.class) { if (sWindowSession == null) { try { InputMethodManager imm = InputMethodManager.getInstance(); // 1. 获取了WindowManagerService IWindowManager windowManager = getWindowManagerService(); // 2. 与WindowManagerService建立了一个Session, 并返回 sWindowSession = windowManager.openSession(...); } catch (RemoteException e) { Log.e(TAG, \"Failed to open window session\", e); } } return sWindowSession; } } // 看一下获取WMS的实现 public static IWindowManager getWindowManagerService() { synchronized (WindowManagerGlobal.class) { if (sWindowManagerService == null) { // 典型的Binder通信 sWindowManagerService = IWindowManager.Stub.asInterface( ServiceManager.getService(\"window\")); } return sWindowManagerService; } } getWindowManagerService()函数首先获取了IWindowManager对象, 本质就是一个远程对应的Binder对象. 而远程WMS的Binder获取是通过ServiceManager.getService()实现的. 这里就可以总结为: Android Framework与WMS之间的通信也是通过Binder机制进行的. 这里就建立了与WMS的通信. 最后通过openSession()函数来与WMS建立一个通信会话, 相当于建立了一个长期的处理中心, 双方有什么需要够可以通过这个Session来交换信息. 但是! 此时不管是Dialog或者Activity的View还没有显示在手机屏幕上, WMS只是负责管理手机屏幕上的View的z-order, 也就是WMS管理当前状态下哪一个View应该在最上层显示. 所以WMS管理的并不是Window而是View, 只不过它管理的是属于某个Window下的View. 之前分析ViewRootImpl的构造函数结束了, 继续回View的显示问题上. 当与WMS建立Session之后就会调用ViewRootImpl#setView()函数, 该方法会向WMS发起显示Dialog或者Activity的DecorView的请求. setView()函数这里只关心两步: requestLayout(): 请求布局 通过WindowSession#add()向WMS发起显示Window的请求 先看一个请求布局的方法 @Override // ViewRootImpl类 public void requestLayout() { if (!mHandlingLayoutInLayoutRequest) { // 检测当前线程是否是创建ViewRootImpl对象的线程 // 通常子线程更新的崩溃是在这里抛出的异常 checkThread(); mLayoutRequested = true; // 向 handler 发送 DO_TRAVERSAL 消息 scheduleTraversals(); } } 在scheduleTraversals()发送消息之后, 就会触发整个视图树的绘制操作, 最终会触发执行performTraversals(). 这个函数主要做的操作如下: 获取Surface对象, 用于图形绘制 测量整个视图树的各个View的大小, 触发performMeasure() 布局整个视图树, 触发performLayout() 绘制整颗视图树, 触发performDraw() 在第四步中, Framework会获取到图形绘制表面Surface对象, 然后获取它的可绘制区域, 也就是常用的Canvas对象, 然后Framework在这个Canvas对象上绘制. 而在调用过程中通过draw()方法主要做了如下几个事情: 判断是使用CPU还是GPU来进行绘制 获取绘制表面Surface对象 通过Surface对象获取并且锁住Canvas绘图对象 从DecorView开始发起整颗视图树的绘制流程 Surface对象解锁Canvas, 并且通知SurfaceFlinger 当内容绘制完毕之后, 请求WMS显示该窗口上的内容, 至此,Activity``Dialog等组件的View就显示到了屏幕上. 这里整理的只是比较高层次的整体脉络. 整个WMS系统是即为复杂的, 涉及的概念和技术很是很多方面. 比如Surface等. 最后提出\u003cAndroid源码设计模式解析与实战\u003e一书的59页简化结构图 下一篇WindowManagerService的认知 ","date":"2016-11-28","objectID":"/posts/%E6%B7%B1%E5%85%A5windowmanager/:0:4","tags":["android","framework"],"title":"深入WindowManager","uri":"/posts/%E6%B7%B1%E5%85%A5windowmanager/"},{"categories":null,"content":"灵活之路 - 面向对象六大原则 如果下面文字描述,不是很明白那么跳转到后面链接有详细代码说明原则解析 单一职责原则SRP(Single Responsibility Principle) 定义: 就一个类而言, 应该仅有一个引起它的变化的原因. 通俗点就是一个类应该是相关性很高数据封装 举例: 现在有一个图片加载类. 但是这个类内部包含了图片下载的逻辑,图片缓存的逻辑这样就使得这个类的职责过多, 随着功能的不断完善, 这个类的代码和逻辑也变得纵横交错混合在了一起. 对于后续的修改维护扩展都是不利的. 所以让两个类组合起来, 一个类内部只负责图片下载,另一个类内部负责图片缓存. 保持每个类的单一职责 开闭原则OCP(Open Close Principle) 定义: 软件中的对象应该对于扩展是开放的 但是对于修改是封闭的. 通俗点 : 尽量通过扩展的方式来实现变化, 而不是通过修改已有的代码来实现. 举例: 此时我们实现了一个双缓存类和单缓存类. 在图片加载类中进行这两个缓存类的实例. 并对外暴露一个布尔值让用户设置是否使用双缓存来决定内部缓存的逻辑. ok. 目前看可能没有问题. 但是如果有一个更好的缓存算法类, 这时候每次都需要在图片加载类中修改代码. 这就违反了OCP原则, 利用继承,接口的特性可以让此类问题得以解决. 比如: 我们可以定义一个缓存接口, 在加载类中使用的个这个接口中的方法. 而这个接口的具体实现通过暴露一个方法让外部调用的时候传入, 以后如果有新的缓存类只需要调用方法传入接口的子类就可以. 这样就对于原始代码修改进行了关闭, 而对于扩展是开放的. 里氏替换原则LSP(Liskov Substitution Principle) 定义: 所有引用基类的地方必须能透明地使用其子类. 通俗点:是基于继承,多态两大特性. 再简单点抽象 举例: Window#show(View view)这个方法接收一个View, 但是我们可以Button,TextView等等. 其实很简单. 我们常用只不过不知道这个名字而已. 所以LSP的原则的核心就是抽象. 抽象又依赖于继承这个特性. 通常开闭原则和里氏替换是不离不弃的例如上面OCP中举得例子. 在外部调用就是利用了继承的特性, 也就是里氏替换 依赖倒置原则DIP(Dependence Inversion Principle) 定义: 指代了一种特定的解耦形式, 使得高层次的模块不依赖于低层次的模块的实现细节的目的, 依赖模块被颠倒了. 通俗点: 在Java中依赖抽象(接口,抽象类), 而不依赖具体实现类. 模块之间的依赖通过抽象发生, 实现类之间不发生直接的依赖关系, 其依赖关系是通过接口或抽象类产生. 举例: 还是在OCP中的例子, 内部加载类依赖于也就是成员变量是缓存接口, 而不是具体的某一个单缓存或者双缓存的实现类. 接口隔离原则ISP(Interface Segregation Principles) 定义: 接口的依赖关系应该建立在最小的接口上. 通俗点:接口隔离原则的目的是系统解开耦合, 从而容易重构, 更改和重新部署. 举例: 在操作一些IO文件,网络的时候我们总是伴随着try...catch...finally. 在最终调用块中调用close()确保资源可以正确的释放. 但这样这样的代码不仅可读性差可以每次都是写一些冗余的模板代码. 其实可以提供一个静态方法, 而根据java中的的特性,之上操作的对象都会实现一个标识接口Closeable,这个接口标识了一个可关闭的对象有一个close(). 所以这个静态方法的形参接收一个Closeable接口,并在方法内调用close()即可. 仔细想想: 这个方法的形参在调用的时候传入的实参是里氏替换原则, 而方法内部调用的是一个接口的close()方法,但传入的可能是某一个实现类,那么这不就是依赖导致原则,并且建立在最小化的依赖基础上, 只要知道这个对象是可关闭的, 别的一概不关心, 这就是接口隔离原则. 迪米特原则LOD(Law of Demeter) 定义: 一个对象应该对其他对象有最少的了解. 通俗点: 一个类应该对自己需要耦合或调用的类知道的最少, 类的内部如果实现与调用者或者依赖者没有关系, 调用者或者依赖者只需要知道他需要的方法即可, 其他一概不管. 举例: 房间类, 中介类, 上班族类. 可以上班族应该只关心中介类, 而不需要关注房间类. 只需要中介类返回房子的地址即可. 而不需要通过调用中介类返回一个房间类 . 这也就是代码中需要注意的. 不要过度耦合, 要降低类之间的关系. ","date":"2016-11-16","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/:1:0","tags":["设计模式"],"title":"设计模式之路","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/"},{"categories":null,"content":"启航之路 - UML类图说明 对于许多类组成的庞大关系网, 最好的办法是通过图来表示出其关系. 可以直观的看出组合的元素, 元素直接是如何存在的, 元素与哪些元素直接存在着联系等. 表示出来的图就是UML类图. 可以看如下一个稍微完整的一个UML类图 组成元素 类和接口: 通过黄色的矩形框来表示一个类, 例如上面鸟就是一个普通类, 如果类名是斜体那么就是抽象类, 如果和飞翔或者唐老鸭的表示法那么就是接口. 访问权限: 通过+ 公共权限, - 私有权限, # 保护权限 变量和方法: 分别在第二行, 和第三行表示,抽象方法同样斜体表示, 静态属性的用下划线表示. 关系结构 继承关系: 类与类之间的关系, 通过空心三角+实线表示, 通过箭头的方向指向父类表述关系. 实现关系: 类与接口直接的关系, 通过空心三角+虚线表示, 通过箭头的方向指向接口表述关系. 关联关系: 当一个类知道另一个类的时候,可以使用关联, 比如企鹅和气候两个类中, 企鹅类的变量有气候类的引用, 这个时候就如上图之间的关系. 实线箭头表示, 箭头指向被知道的类 依赖关系: 例如动物是依赖氧气和水的, 就如动物类中的方法形参类型依赖这两个类型. 如上图动物和水之间关系. 使用虚线箭头, 箭头指向被依赖的类 聚合关系: 表示一种弱拥用, A可以包含B, 但B不可以包含A. 如大雁和雁群两个类. 雁群类中会有一个数组,数组的元素是大雁类型. 这之间就是聚合. 使用空心菱形+实线箭头 合成关系: 也可以认为是组合. 是一种强拥有关系. 例如鸟类和翅膀类, 鸟类是整体, 翅膀类是部分. 并且其生命周期相同, 对应着就是在鸟类初始化的时候,翅膀类也会随之初始化. 并且, 上图中的鸟到翅膀还有1..2的字样. 这称为基数. 表明一段会有几个实例, 例如一个鸟会有两个翅膀. 如果一个类有无数个实例那就用n表示. 关联关系,聚合关系也是可以有基数的. 使用实心菱形+实线箭头表示. 编程是门技术, 更加是一门艺术, 不能只满足代码结果运行正确就完事, 时常考虑如果让代码更加简练, 更加容易维护, 更易扩展和复用, 这样才可以真正提高. ","date":"2016-11-16","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/:2:0","tags":["设计模式"],"title":"设计模式之路","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/"},{"categories":null,"content":"发现之路 - 23种设计模式 ","date":"2016-11-16","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/:3:0","tags":["设计模式"],"title":"设计模式之路","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/"},{"categories":null,"content":"单例模式 Singleton 模式介绍 定义: 确保某个类只有一个实例, 而且自行实例化并向整个系统提供这个实例. 场景: 确保一个类只会有一个对象实例, 避免产生多个对象消耗过多的资源, 或者某种类型的对象只应该有且只有一个. 如创建一个对象需要消耗的资源过多, 访问IO和数据库等资源时就可以考虑单例. 模式范例 单例模式的实现有5种. 饿汉式单例 –\u003e 实现代码 懒汉式单例 –\u003e 实现代码 静态内部类单例 –\u003e 实现代码 枚举单例 –\u003e 实现代码 容器实现单例 –\u003e 实现代码 这种方式在android源码中存在. 知识扩展 枚举实现法最大的优点就是实现简单, 但是在android却比较消耗内存. 有一点与其他单例模式不同的是: 默认枚举实例的创建是线程安全的. 为什么? 因为其他的单例在一种特定的场合下会重新创建对象,那就是反序列化. 反序列化是从磁盘读回数据并创建一个新的对象. 即使构造函数是私有的, 反序列化依然可以通过特殊的途径去创建一个实例, 相当于调用了构造函数. 反序列化提供了一个很特别的钩子函数, 类中具有一个私有的, 被实例化的方法readResolver(), 这个方法可以让开发人员控制对象的反序列化. 例如上面的几个单例模式, 如果想杜绝单例对象在被反序列化时重新生成对象, 那么必须加入如下方法: private Object readResolve() throws ObjectStreamException(){ return sInstent; // 返回单例中的实例对象 } 这样在反序列化的时候就不是默认的重新生成一个新对象. 而对于枚举,并不存在这个问题. 因为即使反序列化它也不会重新生成新的实例. Android源码对应模式 我们经常会在Activity中通过getSystemService(String name)这个函数来获取系统的服务, 比如说WMS,AMS,LayoutInflater等等. 这些服务都会在某一时刻以容器单例的形式保存在应用中. 以Adapter#getView()中使用布局加载器LayoutInflate.from(context).inflate(layoutId,null)为例 会调用ContextImpl#getSystemService(String)方法获取服务, 而方法内部只是从一个SYSTEM_SERVICE_MAP名字的集合中获取了一个ServiceFetcher对象, 并从其中获取具体的服务返回. 那么我们可以缕一下应用的启动, 并定位到何时保存的这些服务到这个集合的. 首先应用的入口为ActivityThread#main(),在这个函数里面会创建ActivityThread对象, 并启动消息循环(UI)线程, 调用attach(boolean)函数 在attach(boolean)中通过Binder机制与ActivityManagerService通信, 最终回调本类的handlelaunchActivity()函数. 然后执行PerformLaunchActivity()函数, 开始创建Application,Context,Activity, 并把上下文关联到Activity中, 最终调用Activity#onCreate() ok刚才大概流程是这样的, 通过之前的分析我们知道, 各个系统服务是保存在ContextImpl类中的, 这个类是在上面的第3步中被初始化的. 看如下代码, 就是服务被注册的代码, 时机也就是第一个Context被创建的时候. class ContextImpl extends Context { // 存储所有系统服务的集合 private static final HashMap\u003cString, ServiceFetcher\u003e SYSTEM_SERVICE_MAP =new HashMap\u003cString, ServiceFetcher\u003e(); // 一个注册服务的并添加到结合的方法 private static void registerService(String serviceName, ServiceFetcher fetcher) { if (!(fetcher instanceof StaticServiceFetcher)) { fetcher.mContextCacheIndex = sNextPerContextServiceCacheIndex++; } SYSTEM_SERVICE_MAP.put(serviceName, fetcher); } // 静态语句块, 只在类第一次被加载的时候调用, 保证了服务只被添加一次. static { // 注册了LayoutInflate服务 registerService(LAYOUT_INFLATER_SERVICE, new ServiceFetcher() { public Object createService(ContextImpl ctx) { return PolicyManager.makeNewLayoutInflater(ctx.getOuterContext()); }}); registerService(INPUT_SERVICE, new StaticServiceFetcher() { public Object createStaticService() { return InputManager.getInstance(); }}); /** * 后面省略一大坨的注册的服务代码 **/ } } ","date":"2016-11-16","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/:3:1","tags":["设计模式"],"title":"设计模式之路","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/"},{"categories":null,"content":"建造者模式 Builder 模式介绍 一个复杂的对象有很多组成成分, 如汽车, 车轮, 方向盘, 发动机,等等. 为了在构建过程中对外部隐藏实现细节, 就可以使用Builder模式将部件和组装过程分离, 使得构建过程和部件都可以自由扩展, 两者之间的耦合也将到了最低. 定义: 将一个复杂对象的构建与它的表示分离, 使得同样的构建过程可以创建不同的表示. 场景: 当初始化一个队形特别复杂, 参数特别多, 且有很多参数都具有默认值时. 相同的方法, 不同的执行顺序, 产生不同的事件结果时 多个部件或零件, 都可以装配到一个对象中, 但是产生的运行结果又不相同. 模式范例 范例代码 范例的UML类图 上例中通过具体MacbookBuilder类构建Macbook对象, 而Director封装了构建复杂产品对象的过程, 对外隐藏了构建的细节. Builder于Director一起将一个复杂对象的构建与它的表示分离, 是的同样的构建过程可以创建不同的对象. 可能你会觉得唉? 怎么和我见过的Builder模式不一样呢? ,这是因为Director这个角色经常会被忽略. 而直接使用一个Builder来进行对象的封装, 并且这个Builder通常为链式调用, 它的每个setter方法都会返回this自身, 比如我们常用的AlertDialog. 下节介绍. Android源码模式实现 在Android中最经典的Builder实现就是AlertDialog. 看一下开发中的使用: // 一个粗略的创建dialog // 创建构建者builder角色 AlertDialog.Builder builder = new AlertDialog.Builder(this); builder.setIcon(android.R.drawable.sym_def_app_icon) .setTitle(\"标题\") .setMessage(\"message\") // 设置点击等.. .setPositiveButton(\"确定\", null); // 构建 AlertDialog alertDialog = builder.create(); // 显示 alertDialog.show(); 从类名就可以看出这是一个Builder模式, 通过Builder对象来组装Dialog的各个部分. 将Dialog的构造和表示进行了分离. 接下来看一下AlertDialog的源码: public class AlertDialog extends Dialog implements DialogInterface { // AlertController 这个对象会保存Builder对象中的各个参数 private AlertController mAlert; // 实际上操作的是上面这个变量中的属性 @Override public void setTitle(CharSequence title) { super.setTitle(title); mAlert.setTitle(title); } public void setMessage(CharSequence message) { mAlert.setMessage(message); } // 省略一坨代码如各种setter等 // Builder以内部类的形式存在 public static class Builder { // 1.存储AlertDialog的各个参数 如title,icon等 private final AlertController.AlertParams P; // 构造函数 public Builder(Context context) { this(context, resolveDialogTheme(context, 0)); } // 2. 设置参数, 我们构建的Builder设置的参数就是这些方法 public Builder setTitle(int titleId) { P.mTitle = P.mContext.getText(titleId); return this; } public Builder setTitle(CharSequence title) { P.mTitle = title; return this; } // .... // 3.构建AlertDialog, 传递参数 public AlertDialog create() { // 4.因为已经通过builder设置了参数, 接下来就可以创建真正需要的AlertDialog对象 final AlertDialog dialog = new AlertDialog(P.mContext, mTheme, false); // 5.将Builder类中的成员变量P应用到AlertDialog类中 P.apply(dialog.mAlert); dialog.setCancelable(P.mCancelable); if (P.mCancelable) { dialog.setCanceledOnTouchOutside(true); } dialog.setOnCancelListener(P.mOnCancelListener); dialog.setOnDismissListener(P.mOnDismissListener); if (P.mOnKeyListener != null) { dialog.setOnKeyListener(P.mOnKeyListener); } return dialog; } } } 对, 最后还调用了AlertDialog#show()函数, 这个函数主要做了如下几件事情: 通过dispatchOnCreate()函数来调用AlertDialog#onCreate()函数 然后调用AlertDialog#onStart()函数 最后将Dialog的DecorView添加到WindowManager中. 那么在看一下onCreate()函数的源码及后续调用. // AlertDialog类 protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); mAlert.installContent(); } // AlertController类 public void installContent() { // 设置窗口, 没有title类型 mWindow.requestFeature(Window.FEATURE_NO_TITLE); int contentView = selectContentView(); // 设置窗口的内容视图 mWindow.setContentView(contentView); // 初始化AlertDialog其他子视图的内容 setupView(); setupDecor(); } 这部分比较重要, 通过Window#setContentView()和Activity是一样的过程, 设置了内容布局, 通过AlertController的构造函数可以发现加载布局资源就是com.android.internal.R.layout.alert_dialog这个文件, 之前的Builder中的各种setter方法就是把设置的内容传入到这个布局当中. 可以看到Android源码中的AlertDialog并没有遵循GOF设计模式中经典的实现方式, 而是进行了变种, 但却使其使用更加的方便. 这里AlertDialog.Builder这个类同时扮演了范例中的builder,具体实现builder,Director的角色. 简化了Builder设计模式, 因为模块比较稳定不会存在变化, 根据具体场景简化模式, 正是体现了灵活运用设计模式的实例. 实战场景 就如Picasso,Glide等链式的调用, 你可以通过链式设置很多配置属性, 也可以仅调用两三此传入必要参数即可. 是的调用实现更加灵活. ","date":"2016-11-16","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/:3:2","tags":["设计模式"],"title":"设计模式之路","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/"},{"categories":null,"content":"原型模式 Prototype 模式介绍 创建性模式, 从一个样板对象中复制出一个内部属性一致的对象, 其实就是克隆. 而被复制的对象就叫做原型, 多用于创建复杂的或者构造耗时的实例 定义: 用原型实例指定创建对象的种类, 并通过拷贝这些原型创建新的对象. 场景: 类初始化需要消耗非常多的资源, 这个资源包括数据,硬件资源等, 可通过原型拷贝避免这些消耗 通过new产生一个对象需要非常繁琐的数据准备或访问权限, 同样可以使用原型模式 一个对象需要提供给其他对象访问, 并且会能会对其修改属性, 可以用原型拷贝多个对象提供使用 其实这个模式很简单, 就是利用Object#clone()方法可以复制一份提供使用(clone是一个native方法). 但是需要注意, 通过实现Cloneable接口的原型模式在调用clone函数构造并不一定就比通过new方式的快, 只有当通过new构造对象较为耗时或者说成本较高时, 通过clone方法才能获得效率提升. UML类图 模式范例 这里模式实现很简单, 实现也比较少, 这里就贴出代码 public class WordDocument implements Cloneable{ // 文本 public String mText; // 图片名列表 public ArrayList\u003cString\u003e mImages = new ArrayList\u003cString\u003e(); public WordDocument(){ System.out.println(\"-----------WordDocument构造函数-----------\"); } @Override protected WordDocument clone() { try { // 通过本地方法特殊途径, 构建一个对象 WordDocument doc = (WordDocument) super.clone(); doc.mText = this.mText; // 因为Image是引用类型, 这样直接赋值属于浅拷贝, 再次对集合进行clone. 实现wordDocument的深拷贝 doc.mImages = (ArrayList\u003cString\u003e) this.mImages.clone(); return doc; }catch (Exception ex){} return null; } /** * 打印文档内容 */ public void showDocument(){ System.out.println(\"------------开始输出内容---------------------\"); System.out.println(\"Text: \"+mText); System.out.println(\"List: \"+mImages.toString()); System.out.println(\"------------输出结束------------------------\"); } } 与标准的原型模式相比WordDocument就是一个具体实现的原型对象. 而实现的Cloneable接口为抽象的原型对象. 其实Cloneable这个接口内部没有任何方法, 所以其本质就是标识接口,只是表明这个类的对象是可拷贝的, 而clone()这个方法是Objec类中的, 如果没有标识这个接口, 那么调用会抛出异常. 深拷贝浅拷贝 例如上面的代码中进行修改一下 @Override protected WordDocument clone() { try { // 通过本地方法特殊途径, 构建一个对象 WordDocument doc = (WordDocument) super.clone(); doc.mText = this.mText; // 这里进行修改 那么此时属于浅拷贝 doc.mImages = this.mImages; return doc; } 你可能应该发现了什么, 其实本质不过就是通过super.clone()构建了一个本类对象的初始状态, 然后把被拷贝的对象的各个属性值进行赋值操作而已. 的确, 就是如此. 就如上面两处不同的代码, 浅拷贝: 也称影子拷贝, 拷贝出来的对象并不是完全一份独立的对象, 新的对象某些属性如引用传递可能会引用原始对象的对应属性值, 也就是说, 对浅拷贝的属性可能会影响到原始数据的属性. 深拷贝: 拷贝出一份原始对象, 并对原始对象的属性值, 进行复制添加到新拷贝的对象的各个属性上. 这样拷贝出来的对象与原始对象不存在任何关联, 只作为一个数据的副本存在. 上面因为mImages的类型是ArrayList如果直接进行赋值那么属于引用传递, 共享的一份数据源, 而如果在对ArrayList进行一次clone, 那么相当于又构建了一个集合并进行数据的复制. 而mText虽然是对象, 但是因为是String类型, 属于安全类型, 由于final类,实例不可更改的特性. 如果对副本进行字符串的修改, 只不过是把原引用删除,重新指向了新的字符串. Android源码对应实现 上面我们说了通过对集合再次调用clone()即可完成深拷贝. 那么看一下ArrayList源码 public class ArrayList\u003cE\u003e extends AbstractList\u003cE\u003e implements List\u003cE\u003e, RandomAccess, Cloneable, java.io.Serializable{ transient Object[] elementData; private int size; public Object clone() { try { ArrayList\u003c?\u003e v = (ArrayList\u003c?\u003e) super.clone(); v.elementData = Arrays.copyOf(elementData, size); v.modCount = 0; return v; } catch (CloneNotSupportedException e) { throw new InternalError(e); } } ArrayList的内部克隆实现很简单, 我们都知道ArrayList内部是通过数组的数据结构来实现的. 通过Arrays工具类对原始集合的数据进行赋值并添加到一个新的数组并返回, 而返回的数组挂到了克隆出来对象上的elementData变量上. 而集合的大小size没有被进行赋值? 因为其类型是整型, 属于值传递, 在clone之后原始值通过值传递到了新对象中, 即使修改也不会对原始对象有任何的影响. 那么Android源码中的实现是什么? Intent, 我们看如下代码 Intent intent = new Intent(\"某一个activity的action\"); intent.putExtra(\"result\", \"Successful\"); // 调用克隆方法 Intent clone = (Intent) intent.clone(); startActivity(clone); 这样同样没问题, 一样的效果. 那么看一下Intent#clone()内部是如何实现的. @Override public Object clone() { return new Intent(this); } /** * Copy constructor. */ public Intent(Intent o) { this.mAction = o.mAction; this.mData = o.mData; this.mType = o.mType; this.mPackage = o.mPackage; this.mComponent = o.mComponent; this.mFlags = o.mFlags; this.mContentUserHint = o.mContentUserHint; if (o.mCategories != null) { this.mCategories = new ArraySet\u003cString\u003e(o.mCategories); } if (o.mExtras != null) { this.mExtras = new Bundle(o.mExtras); } if (o.mSourceBounds != null) { this.mSourceBounds = new Rect(o.mSourceBounds); } if (o.mSelector != null) { this.mSelector = new Intent(o.mSelector); } if (o.mClipData != null) { this.mClipData = new ClipData(o.mClipData); } } 很简单不需要解释了, 手动new的并进行数据复制. 相当于封装了一下复制的细节而已. 但是为什么没有调用super.clone()来实现拷贝呢? 之前说过使用clone还是new关键字是需要根据构造对象的成本来决定的, 如果对象的构造成本比较复杂或者麻烦, 那么clone则是一种更优的选择, 否则就可以使用new的形式. 这和c++拷贝构造函数是一样的. 实战场景 当登录模块登录成功之后, 会把一些个人信息,token等信息在保存类中的某个数据结构上, 并通过一个方法对外暴露出去, 提供其他模块使用. 但是如果你返回的是一个数据结构也就是一个对","date":"2016-11-16","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/:3:3","tags":["设计模式"],"title":"设计模式之路","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/"},{"categories":null,"content":"工厂方法模式 Factory 模式介绍 创建型设计模式, 其实这个模式可能在开发中出现很多回了, 只是并不了解什么是工厂模式的概念. 定义: 定义一个用于创建的对象的接口, 让子类决定实例化哪个类 场景: 在任何需要生成复杂对象的地方, 都可以使用工厂方法模式. 复杂对象适合使用工厂模式, 用new就可以完成创建的对象无需使用工厂模式. 工厂方法模式完全符合设计模式原则, 降低了对象之间的耦合度, 而且, 工厂方法模式依赖于抽象的架构, 将实例化的任务交由了子类实现. 模式范例 实现代码 这是范例的UML类图. 其实这里, 可以去掉抽象的工厂类, 只需要一个工厂即可. 这样会更加简洁直观. Android源码对应实现 List和Set不陌生, 都继承Collection接口, 而Collection接口继承Iterable接口, 而这个接口很简单就一个iterator()方法, 如下 public interface Collection\u003cE\u003e extends Iterable\u003cE\u003e { // .... } public interface Iterable\u003cT\u003e { Iterator\u003cT\u003e iterator(); // 可能JDK1.8之后添加两个默认方法, 这里我们不需要关心 } 关于List和Set迭代器的方法遍历元素应该都用过. 那么看一下源码实现. public class ArrayList\u003cE\u003e extends AbstractList\u003cE\u003e implements Cloneable, Serializable, RandomAccess { @Override public Iterator\u003cE\u003e iterator() { return new ArrayListIterator(); } private class ArrayListIterator implements Iterator\u003cE\u003e { private int remaining = size; private int removalIndex = -1; private int expectedModCount = modCount; public boolean hasNext() { return remaining != 0; } @SuppressWarnings(\"unchecked\") public E next() { ArrayList\u003cE\u003e ourList = ArrayList.this; // 返回集合大小元素, 还有几个未遍历 int rem = remaining; if (ourList.modCount != expectedModCount) { throw new ConcurrentModificationException(); } if (rem == 0) { throw new NoSuchElementException(); } remaining = rem - 1; return (E) ourList.array[removalIndex = ourList.size - rem]; } public void remove() { Object[] a = array; int removalIdx = removalIndex; if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } if (removalIdx \u003c 0) { throw new IllegalStateException(); } System.arraycopy(a, removalIdx + 1, a, removalIdx, remaining); a[--size] = null; // Prevent memory leak removalIndex = -1; expectedModCount = ++modCount; } } } // hashSet 复写逻辑 public class HashSet\u003cE\u003e extends AbstractSet\u003cE\u003e implements Set\u003cE\u003e, Cloneable,Serializable { public Iterator\u003cE\u003e iterator() { return backingMap.keySet().iterator(); } } // HashMap 复写逻辑 public class HashMap\u003cK, V\u003e extends AbstractMap\u003cK, V\u003e implements Cloneable, Serializable { Iterator\u003cK\u003e newKeyIterator() { return new KeyIterator(); } private final class KeyIterator extends HashIterator implements Iterator\u003cK\u003e { public K next() { return nextEntry().key; } } } HashSet的iterator方法会返回成员变量backingMap中对应HashSet对象元素的迭代器对象, 最终返回的是KeySet中的一个迭代器对象 ArrayList和HashMap中的iterator()就相当一个工厂方法, 专为new对象而生! 而Android中, 看一下如下代码 public class MainActivity extends Activity { protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(new FrameLayout(this)); } } 通过onCreate()这个方法, 我们可以构建出任何样式的根布局, 如LinearLayout,TextView等等. 我们在不同的Activity#onCreate()方法将设置的布局通过setContentView()函数传递给frameworks并显示出来. 这不就是一个工厂模式的结构. 方法内部可以创建不同的对象, 产生不同的实例. 实战场景 例如对数据的持久化, 可以通过的途径有SP,File,SQLite等. 但是对数据的操作无非就是增删改查, 那么我们可以抽象一个抽象类并定义CURD抽象方法. SP, File,SQLite分别继承抽象类, 并在抽象方法实现自己的处理逻辑. 然后就可以创建一个工厂类, 工厂类有一个方法, 形参为产品实现类的字节码, 返回一个泛型上限限定是产品的抽象类对象, 方法内部通过字节码反射具体的产品类实例. 这样在使用的使用, 我们只需有通过工厂方法传入的不同产品Class就可以构建不同的实例, 而数据的CRUD通过依赖倒置抽象特性, 高层不需要依赖底层的类. ","date":"2016-11-16","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/:3:4","tags":["设计模式"],"title":"设计模式之路","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/"},{"categories":null,"content":"抽象工厂模式 Abstract Factory 模式介绍 创建型设计模式, 之前工厂模式会生产某一个产品, 但是如果说, 不同的操作系统图形的场景下的两个产品按钮和文本框. 对于每一个操作系统, 其本身就构成了一个单独的产品. 两种产品两种变化, 这种情况就较之前的普通工厂升级了复杂度, 如: Android中的Button和TextView, iOS中的Button和TextView或者WindowPhone场景… 定义: 为创建一组相关或者是相互依赖的的对象提供一个接口, 而不需要指定他们的具体类 场景: 一个对象族有相同的约束时可以使用抽象工厂, 如android和iOS都有打电话软件和短信软件, 两者都属于软件的范畴, 但是他们的操作平台不同, 实现逻辑也不会相同. 这个时候就可以使用抽象工厂方法模式 模式范例 实现代码 范例UML图 看一下运行结果: 如果这是时候, 如果想创建一种使用普通轮胎, 新款发动机的车型. 只需要继承抽象工厂, 并使用原有的普通轮胎类, 并继承IEngfine实现一款新的发动机类. 即可完成扩展. 这就是通过接口扩展. 上面的范例, 对于每一个造车的工厂, 内部使用的零件不管哪个车场都是具有抽象的轮胎和发送机类. 这样可以达到一种自由组合的状态. 但是弊端也显示出来了, 不仅需要扩展新的工厂类还要扩展新的组件类. Android源码对应实现 抽象工厂在Android实现较少, 上一节说onCreate()方法就相当于一个工厂方法. 那么对于另外一个组件Service#onBind()同样也可以看做一个工厂方法. 如果从frameworks层的角度来看Activity和Service可以看做一个具体的工厂, 这样来看相当于一个抽象方法模式的雏形也没错. 另一个更像的例子是Android底层对MediaPlayer使用. 这里书上噼里啪啦一堆C语言. 我就不抄了…. ","date":"2016-11-16","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/:3:5","tags":["设计模式"],"title":"设计模式之路","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/"},{"categories":null,"content":"策略模式 Strategy 模式介绍 开发中可能有这样的情况: 实现某一个功能可以有多中算法或者策略, 我们根据不同的功能来选择不同的算法. 针对这种情况, 1.可以在一个类中封装多个方法, 每个方法实现不同算法. 2.通过if..else if..else..条件判断来决定使用哪种算法. 但是这两种都是硬编码实现. 并且随着算法的增多类也就变得臃肿, 维护的成本随之变高. 如果需要增加一种新的算法, 必然需要对算法类进行修改. 这就违反了OCP原则和单一职责的原则. 定义: 策略模式定义了一系列的算法, 并将每一个算法封装起来, 而且使它们还可以相互替换. 策略模式让算法独立于使用它的客户而独立变化. 场景: 针对同一类型问题的多种处理方式, 仅仅是具体行为有差别时 需要安全地封装多种同一类型的操作时 出现同一抽象类有多个子类, 而又不需要使用if-else或者switch等来选择具体子类. 模式范例 最方便的记忆法就是记住, 策略模式可以去掉if-else或者switch. 语句, 即使后续会扩展通过接口来进行扩展, 不会对源代码进行修改. 满足了OCP开闭原则. 看一下范例代码: –\u003e 对于交通费用的计算, 计算的算法可能会有公交, 地铁等… 代码地址 范例类图: 在看一下代码的使用以及结果–\u003e public static void main (String arg[]){ // 创建操作策略的环境类 TranficCalculator calculator = new TranficCalculator(); // 设置公交车的策略, 并准备计算 calculator.setStrategy(new BusStrategy()); System.out.println(\"公交车--\u003e计算9公里价格: \"+calculator.calculatePrice(9)); // 设置地铁的策略, 并准备计算 calculator.setStrategy(new SubwayStrategy()); System.out.println(\"地铁--\u003e计算9公里价格: \"+calculator.calculatePrice(9)); } // 结果--\u003e 公交车--\u003e计算9公里价格: 1 地铁--\u003e计算9公里价格: 4 你应该可以发现, 这种方式在隐藏实现的同时, 可扩展性变得很强, 如果此时需要增加一个出租车的计算策略, 那么只需要添加一个实现了计算策略接口即可. 对原始代码的修改进行了关闭, 并对扩展开放. Android源码对应实现 动画里面的插值器Interpolator利用了策略模式, 利用Interpolator策略的抽象, LinearInterpolator,CycleInterpolator等插值器为具体的实现策略, 通过注入不同的插值器实现不同的动态效果. 看一下大概的类图 动画中的TimeInterpolator时间插值器, 它的作用是根据时间流逝的百分比计算出当前属性值改变的百分比, 内置的插值器有如下几种 线性插值器(LinearInterpolator)用于匀速动画 加速减速插值器(AccelerateDecelerateInterpolator):起始时动画加速, 结尾时动画减速 减速插值器(DecelerateInterpolator): 用于随着时间的推移动画越来越慢. 动画中的TypeEvalutor类型估值器: 根据当前属性改变的百分比来计算改变后的属性值. 内置的类型估值器有如下几种 整型估值器(IntEvalutor) 浮点型估值器(FloatEvalutor) Color估值器(ArgbEvalutor) 接下来就开始回忆一下从一个动画开始后, 代码究竟做了什么? 对于源码的起始点入口就是调用View的startAnimation() public void startAnimation(Animation animation) { // 1.初始化动画的开始时间 animation.setStartTime(Animation.START_ON_FIRST_FRAME); // 2.对View设置动画 setAnimation(animation); // 3.刷新父类缓存 invalidateParentCaches(); // 4.刷新View本身及子View invalidate(true); } 这里首先设置了动画的起始时间, 然后将该动画设置到View中, 最后再向ViewGroup请求刷新视图, 随后ViewGroup会调用dispatchDraw()方法对这个View所在的区域进行重绘. 其实对于某一个View的重绘最终是调用其ViewGroup的drawChild(...)方法. 跟入一下 protected boolean drawChild(Canvas canvas, View child, long drawingTime) { // 简单的转发 return child.draw(canvas, this, drawingTime); } boolean draw(Canvas canvas, ViewGroup parent, long drawingTime) { // .... // 查看是否需要清除动画信息 final int flags = parent.mGroupFlags; // 省略无关代码 // 获取设置的动画信息 final Animation a = getAnimation(); if (a != null) { // 绘制动画 more = drawAnimation(parent, drawingTime, a, scalingRequired); //... } } 父类会调用子类的draw方法, 其中会先判断是否设置了清除动画的标记, 然后再获取该View动画信息, 如果设置了动画, 就会调用View#drawAnimation()方法. private boolean drawAnimation(ViewGroup parent, long drawingTime, Animation a, boolean scalingRequired) { Transformation invalidationTransform; final int flags = parent.mGroupFlags; final boolean initialized = a.isInitialized(); // 1. 判断动画是否已经初始化过 if (!initialized) { a.initialize(mRight - mLeft, mBottom - mTop, parent.getWidth(), parent.getHeight()); a.initializeInvalidateRegion(0, 0, mRight - mLeft, mBottom - mTop); if (mAttachInfo != null) a.setListenerHandler(mAttachInfo.mHandler); // 如果设置了动画的监听, 则触发对应的回调 onAnimationStart(); } // 获取Transformation对象, 存储动画的信息 final Transformation t = parent.getChildTransformation(); // 2. 调用Animation#getTransformation, 通过计算获取动画的相关值 boolean more = a.getTransformation(drawingTime, t, 1f); if (more) { // 3. 根据具体实现, 判断当前动画类型是否需要进行调整位置大小, 然后刷新不同的区域 if (!a.willChangeBounds()) { // ... } else { // 获取重绘区域 a.getInvalidateRegion(0, 0, mRight - mLeft, mBottom - mTop, region, invalidationTransform); parent.mPrivateFlags |= PFLAG_DRAW_ANIMATION; // 更新计算有效区域 final int left = mLeft + (int) region.left; final int top = mTop + (int) region.top; // 进行区域更新 parent.invalidate(left, top, left + (int) (region.width() + .5f), top + (int) (region.height() + .5f)); } } return more; } drawAnimation中主要操作是动画的初始化, 动画操作, 界面刷新. 动画的回调监听onStart()会在动画进行初始化的时候调用, 动画的具体实现是通过Animation#getTransformation()方法.这个方法主要获取了缩放系数和调用Animation.getTransformation(long, Transformation)来计算和应用动画效果. public boolean getTransformation(long currentTime, Transformation outTransformati","date":"2016-11-16","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/:3:6","tags":["设计模式"],"title":"设计模式之路","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/"},{"categories":null,"content":"状态模式 State 模式介绍 状态模式中的行为是由状态来决定的, 不同的状态有不同的行为, 状态模式和策略模式的结构几乎一模一样, 但他们的目的, 本质却完全不一样. 状态模式的行为是平行的不可替换的. 策略模式的行为是彼此独立, 可相互替换的. 总结一句话表述: 状态模式是把对象的行为包装在不同的状态对象里, 每一个状态对象都有一个共同的抽象状态基类, 状态模式的意图是让一个对象在其内部状态改变的时候, 其行为也随之改变 定义: 当一个对象的内在状态改变时允许改变其行为, 这个对象看起来像是改变了其类. 场景: 一个代码的行为取决于它的装填, 并且必须在运行时根据其状态改变它的行为 代码中包含大量与对象状态有关的条件语句, 同样可以去除分支语句的效果 模式范例 例如电视开关机状态下的频道切换或者音量调节, 不同的状态下的各种功能行为是不同的. 关机: 功能音量频道切换是无效的, 开机: 却可以实现. 实现这样一个关系, 如果最简单暴力的方法就是一个类实现, 里面充斥了各种条件判断来实现不同场景的功能. 范例代码实现 范例类图: 客户端的实现: public static void main(String arg[]){ TvController tvController = new TvController(); // 开机 tvController.powerOn(); // 下一个频道 tvController.nextChannel(); // 调高音量 tvController.turnUp(); // 关机 tvController.powerOff(); // 关机状态下调低音量 tvController.turnDown(); } /** 输出结果--\u003e * 开机了-- * 下一个频道 * 调高音量 * 关机了-- **/ 其实有多重行为, 但代码中却不存在了条件分支语句 Android源码对相应实现 WiFi管理 其中的实现就使用了状态模式 在WiFi复杂的调用中, 存在一个State的状态类, 它代表了WiFi的某个状态, 定义如下: public class State implements IState { // 进入当前状态之后调用该函数 @Override public void enter() { } // 退出该状态后改用该函数 @Override public void exit() { } // 处理消息 @Override public boolean processMessage(Message msg) { return false; } } 状态之间并不是可以随意切换的, 他们有一种层级关系, 这些层级关系StateMachine的构造函数中被定义的, 代码如下: // WiFiStateMachine public WifiStateMachine(Context context, String wlanInterface, WifiTrafficPoller trafficPoller){ super(\"WifiStateMachine\"); addState(mDefaultState); addState(mInitialState, mDefaultState); addState(mSupplicantStartingState, mDefaultState); addState(mSupplicantStartedState, mDefaultState); addState(mDriverStartingState, mSupplicantStartedState); addState(mDriverStartedState, mSupplicantStartedState); addState(mScanModeState, mDriverStartedState); addState(mConnectModeState, mDriverStartedState); addState(mL2ConnectedState, mConnectModeState); addState(mObtainingIpState, mL2ConnectedState); addState(mVerifyingLinkState, mL2ConnectedState); addState(mConnectedState, mL2ConnectedState); addState(mRoamingState, mL2ConnectedState); addState(mDisconnectingState, mConnectModeState); addState(mDisconnectedState, mConnectModeState); addState(mWpsRunningState, mConnectModeState); addState(mWaitForP2pDisableState, mSupplicantStartedState); addState(mDriverStoppingState, mSupplicantStartedState); addState(mDriverStoppedState, mSupplicantStartedState); addState(mSupplicantStoppingState, mDefaultState); addState(mSoftApStartingState, mDefaultState); addState(mSoftApStartedState, mDefaultState); addState(mTetheringState, mSoftApStartedState); addState(mTetheredState, mSoftApStartedState); addState(mUntetheringState, mSoftApStartedState); // 初始化模式为mInitialState setInitialState(mInitialState); } 在构造函数中调用了addState()函数, 这些函数最终会调用SmHandler#addState()函数. 这个函数就是在状态之间建立一个层级关系, 这是一个树形的层级关系. 状态之间并不是跨越式的转换, 当前状态只能转换到上一个状态或者下一个状态. 上面说的比较抽象, 列举书中的例子. 一个电梯的状态有停止, 运行, 开门, 关门. 在运行状态只能到停止状态. 不会直接开门状态,这会出人命的, 关门状态也是不合乎常理的. 所以就如下关系图片: 正如上图, 不同状态对于不同的指令的反应是完全不一样的, WiFi工作状态机制也是同理, 除了对状态之间的转换进行控制之外, 还通过状态模式来对不同的命令进行不同的处理. State类就是状态的基类, 它与Wifi相关的子类都定义在WifiStateMachine中. State的类有enter,exit,processMessage三个函数, 进入状态之后会调用enter(), 退出时调用exit(), 处理具体消息时调用processMessage(). 而状态模式的核心就是当一个对象的内在状态改变时允许改变其行为, 所以我们关注processMessage()不同的状态下就是依赖这个函数实现不同行为的. 例如: 在请求扫描Wifi时, 如果在初始化状态(InitialState)下, 说明Wifi驱动还没有进行加载和启动, 扫描的请求会被会被忽略. 而在驱动加载状态下, 请求会被添加到延迟处理的消息队列中, 等待驱动加载完毕进行扫描请求. 总结起来: 就是将请求的处理封装到状态类中, 在不同的状态类中对同一个请求进行不同的处理. 它能够消除一些重复的if-else逻辑, 使得程序的结构更加清晰, 可扩展性和稳定性也有了一定的提高 实战场景 例如新浪微博首页, 任何状态下可以看微博, 当点击转发后, 如果是登录状态那么就可以直接调转转发页面, 如果是未登录状态那么需要调转到登录界面. 这就可以使用状态模式进行逻辑的分离. ","date":"2016-11-16","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/:3:7","tags":["设计模式"],"title":"设计模式之路","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/"},{"categories":null,"content":"责任链模式 模式介绍 行为型设计模式, 将每一个对象看做一个节点, 并把所有节点串成一条链式, 从链头开始传递事件, 如果无法处理交给节点的下一个节点位置上, 直到有节点处理了这个事件. 定义: 使多个对象都有机会处理请求, 从而避免了请求的发送者和接收者之间的耦合关系. 将这些对象连成一条链, 并沿着这条链传递该请求, 直到对象处理它为止 场景: 多个对象都可以处理一个请求时, 但具体由哪个对象处理是在运行时决定. 模式范例 出差是需要经费的, 那么肯定需要找领导签字才会批下钱, 但是如果经费较多, 你的上一级可能无权签字,这个时候上一级领导就会把这个审批带向他的上级提交.. 直到有可以批准的为止. 从始至终出差人只需要知道自己的上一级即可. 不需要知道其他的审批人. 范例代码 范例类图 看一下客户端的调用–\u003e public static void main(String args[]){ // 构造3个处理者对象 Handler1 handler1 = new Handler1(); Handler2 handler2 = new Handler2(); Handler3 handler3 = new Handler3(); // 构造3个请求者对象 Request1 re1 = new Request1(\"请求1\"); Request2 re2 = new Request2(\"请求2\"); Request3 re3 = new Request3(\"请求3\"); // 设置当前处理者对象下一个节点的处理者对象 handler1.nextHandler = handler2; handler2.nextHandler = handler3; // 准备开始请求 // 总是从链式的首端发起请求 handler1.handleRequest(re1); handler1.handleRequest(re2); handler1.handleRequest(re3); } // 执行结果===================\u003e 处理者 1 处理请求, 请求的等级为: 1 处理者 2 处理请求, 请求的等级为: 2 处理者 3 处理请求, 请求的等级为: 3 对于每个处理者其内部的逻辑是完全灵活的, 比如可以进行跳级传递等… Android源码对应实现 责任链模式在Android中比较类似的就是事件的分发处理, 每当用户接触屏幕时, Android就会将对应的事件包装成一个事件对象从ViewTree的顶部之上而下地分发传递. ViewGroup事件投递的递归调用就类似一条责任链, 一旦其寻到责任者, 那么就由责任者持有并消费掉该次事件 具体的体现在View#onTouchEvent()方法返回值的设置, 如果返回false, 那么就意味着当前View不会是该次事件的责任人, 将不会对其持有, 如果返回true, 则相反, 此时View会持有该事件并不在向外传递. ","date":"2016-11-16","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/:3:8","tags":["设计模式"],"title":"设计模式之路","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/"},{"categories":null,"content":"解释器模式 Interpreter 模式介绍 这是较少使用的行为型模式, 其提供了一种解释语言的语法或表达式的方式, 该模式定义了一个表达式接口, 通过该接口解释一个特定的上下文. 定义: 给定一个语言, 定义它的文法的一种表示, 并定义一个解释器, 该解释器使用该表示来解释语言中的句子. 文法? 如他很高,他很胖,他很瘦. 这三个语句可以看做一个他很[形容词]这样的结构, 可以看做是一条文法 场景: 如果某个简单的语言需要解释执行而且可以将该语言中的语句表示为一个抽象语法树时可以考虑使用解释器模式 在某些特定的领域出现不断重复的问题时, 可以将该领域的问题转化为一种语法规则下的语句, 然后构建解释器来解释该语句. 模式范例 不好理解看看是通过代码形式的表示是否可以清楚一些? 比如一个场景是算术表达式的解释, 如m + n + p, 如果使用解释器模式对该表达式进行解释, 那么代表数字的mnp3个字母我们可以看成是终结符号, 而+这个算术运算符则可以当做非终结符号. 代码范例 如最终调用方式: public static void main(String arg[]){ Calculator calculator = new Calculator(\"12 + 11 + 13 + 14\"); System.out.println(calculator.calculate()); } // 结果如下: 50 这个例子只是先了对加减法的解释计算, 如果要实现更多的运算规则, 乘除取余, 只需要创建对应解释器即可, 但是混合运算的复杂是要考虑各种符号的优先级的问题,这个就比较麻烦. 将一个具体的文法通过一个解释器解释, 把复杂的文法规则分离为简单的功能进行解释, 最后将其组合成一颗抽象的语法树解释执行, 至此, 可以看到解释器模式的原理和本质: 将复杂的问题简单化, 模块化, 分离实现, 解释执行 Android源码对应实现 Android源码中的解释器模式并不多见, 虽然没有经典实现, 但是可以在一些地方看到对解释器模式原理的应用. AndroidManifest.xml这个清单文件 整理一下大体过程. 关于读取配置文件, 那么就需要一个很重要的类PackageParser. 该类对AndroidManifest.xml中每一个组件标签创建了对应的类, 用于存储相应的消息. PackageParser为Activity,Service,Provider,Permission等构件在其内部以内部类的方式创建了对应的类, 按照解释器模式的定义, 这些类其实都对应AndroidManifest.xml中的一个标签, 也就是一条文法, 其在对该配置文件解析时充分运用了解释器模式分离实现, 解释器执行的特性. 对一个APK文件的解析会调用PackageManagerService#scanPackageLI()方法, 这个方法有两种实现 private PackageParser.Package scanPackageLI(File scanFile, int parseFlags, int scanFlags,long currentTime, UserHandle user); private PackageParser.Package scanPackageLI(PackageParser.Package pkg, int parseFlags,int scanFlags, long currentTime, UserHandle user) 两者的唯一区别是第一个参数, 第一种实现为File第二种为PackageParser.Package. 在具体解析某个文件时会先调用第一种实现解析apk文件, 在调用第二种实现将解析后的信息保存至PMS中. 而这两种方法中同样会调用一个函数名相同但参数不同的函数. ParserPackage(...). 对于参数1为File类型的其中主要逻辑就是为了第二种参数为Resources实现准备好需要的参数, 然后可以调用第二种ParserPackage(Resource ...). 而ParserPackage的第二种实现逻辑比较复杂, 内部主要对整个AndroidManifest.xml配置文件的每个子节点进行具体的解析. 例如parseApplication方法的会对application节点进行解析, 对于不同的子标签会调用不同的解析方法来对其内部进行解析. 如碰到了activity标签, 那么会调用parseActivity()进行内部解析. 而parseActivity()不仅承担着对Activity的解析, 其同样承担着Broadcast的解析. 并会继续调用方法对内部标签进行解析如parseIntent和parseMetaData等. ","date":"2016-11-16","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/:3:9","tags":["设计模式"],"title":"设计模式之路","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/"},{"categories":null,"content":"命令模式 Command 模式介绍 行为型设计模式, 如当我们点击关机键的时候, 系统就会执行一系列的操作, 保存程序的进度, 结束程序, 调用内核命令关机. 用户不关心命令做了什么, 只需要点击关机即可达到效果. 定义: 将一个请求封装成一个对象, 从而让用户使用不同的请求把客户端参数化; 对请求排队或者记录请求日志, 以及支持可撤销操作. 场景: 需要抽象出待执行的操作, 然后以参数的形式提供出来– 类似于过程设计中的回调机制, 而命令模式正式回调机制的一个面向对象的替代品 在不同的时刻指定, 排列和执行请求. 一个命令对象可以有与初始请求无关的生存期 需要支持取消操作 支持修改日志的功能, 这样当系统崩溃的时候, 这些修改可以重做一遍 需要支持事务的操作 模式范例 把俄罗斯方块的大体逻辑模拟成代码, 向左,向右,变形,加速下落这四个按钮相当于请求者, 执行具体按钮命令的逻辑方法可以看做是命令角色. 范例代码 范例类图 代码测试 public static void main(String arg[]){ // 创建游戏 TetrisMachine machine = new TetrisMachine(); // 根据游戏构造四个命令 LeftCommand leftCommand = new LeftCommand(machine); RightCommand rightCommand = new RightCommand(machine); FastCommand fastCommand = new FastCommand(machine); TransformCommand transformCommand = new TransformCommand(machine); // 按钮可以执行不同的命令 Buttons buttons = new Buttons(); buttons.setmLeftCom(leftCommand); buttons.setmRightCom(rightCommand); buttons.setmFastCom(fastCommand); buttons.setmTransformCom(transformCommand); // 具体按下那个按钮玩家说的算 buttons.toLeft(); buttons.toRight(); buttons.fast(); buttons.transform(); } 其实调用逻辑做的很复杂, 完全可以直接创建TetrisMachine类直接调用的. 这样做的主要原因是后续开发方便, 比如如果需要增加或修改游戏功能只需要修改TetrisMachine类就可以. 然后修改一下Player类. 但是事物是相对的对开发者方便了, 但是如果别人负责了这个项目看到这个功能可能会花更多时间去理解,反而简单的事情没有很直接的表达. 除此之外, 使用命令模式的另一个好处是可以实现命令记录的功能, 如上面代码中, 如果要Button请求者角色中使用一个数据结构来存储执行过的命令对象, 以此可以很方便地知道刚刚执行过哪些命令动作, 并可以在需要时恢复 Android源码对应实现 Android中关于命令模式的使用虽然不少, 但都不是典型, 很多方面的应用与其他大多数设计模式一样都有一定的变种, 一个比较经典的例子是Android的事件机制中底层逻辑对事件的转发处理, Android的每一种事件在屏幕上产生后都会经过底层逻辑将其封装转换为一个NotifiArgs对象. 实战场景 很好的一个场景就是, 对画板模块的使用, 可以很方便的实现重画,撤销等功能. ","date":"2016-11-16","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/:3:10","tags":["设计模式"],"title":"设计模式之路","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/"},{"categories":null,"content":"观察者模式 Observer 模式介绍 一个使用率非常高的模式, 常用的地方GUI系统, 订阅–发布系统. 最明显的特点就是解耦, 将被观察者和观察者进行解耦, 使得依赖性更小. 定义: 定义对象间一种一对多的依赖关系,使得每当一个对象改变状态, 则所有依赖于它的对象都会得到通知并被自动更新. 场景: 关联行为场景, 需要注意的是, 关联行为是可拆分的, 而不是组合的关系 事件多级触发场景 跨系统的消息交换场景, 如消息队列,事件总线的处理机制 模式范例 例如一个简单的订阅, 订阅者可以在被观察者更新的时候收到通知. 范例源码 类图就不需要了, 因为JDK已经内置了此模式的实现, 看一下范例的调用方式和结果 public static void main(String arg[]){ // 创建被观察对象 DecTechFrontier decTechFrontier = new DecTechFrontier(); // 创建几个观察者 Coder co1 = new Coder(\"张飞\"); Coder co2 = new Coder(\"李逵\"); Coder co3 = new Coder(\"关羽\"); Coder co4 = new Coder(\"孙悟空\"); // 将观察者注册到被观察的对象 decTechFrontier.addObserver(co1); decTechFrontier.addObserver(co2); decTechFrontier.addObserver(co4); decTechFrontier.addObserver(co3); // 发布消息 decTechFrontier.postNewPublication(\"葵花宝典\"); } // =====\u003e 输出结果 你好, 关羽, 你订阅的东西有更新了: 葵花宝典 你好, 孙悟空, 你订阅的东西有更新了: 葵花宝典 你好, 李逵, 你订阅的东西有更新了: 葵花宝典 你好, 张飞, 你订阅的东西有更新了: 葵花宝典 Observer和Observable是JDK中的内置类型, 可见观察者模式是非常重要的, 这里Observer是抽象观察者角色, 范例Coder类扮演的是具体观察者角色; Observable对应的是抽象主题角色, 范例DecTechFrontier是具体的主题角色. 主题角色通过setChange()标识主题发生改变,并通过notifyObservable()通知所有的观察者角色. 而观察者都过复写update()方法来实现主题更新时需要做的事情 . 至此这两个角色并没有耦合. Android源码对应实现 ListView中的Adapter#notifyDataSetChange()就是通过观察者模式实现的子View的更新. 首先是notifyDataSetChange()方法为入口. 这个方法定义在BaseAdapter中. public abstract class BaseAdapter implements ListAdapter, SpinnerAdapter { // 数据集观察者 private final DataSetObservable mDataSetObservable = new DataSetObservable(); public void registerDataSetObserver(DataSetObserver observer) { mDataSetObservable.registerObserver(observer); } public void unregisterDataSetObserver(DataSetObserver observer) { mDataSetObservable.unregisterObserver(observer); } /** * 数据发生改变是, 调用所有观察者 **/ public void notifyDataSetChanged() { mDataSetObservable.notifyChanged(); } } 很明显的BaseAdapter是一个观察者模式, 那么接着看一下如何运作, 以及这个观察者是什么. public class DataSetObservable extends Observable\u003cDataSetObserver\u003e { // 调用每个观察者的onChange函数来通知他们被观察者发生了改变 public void notifyChanged() { synchronized(mObservers) { // 调用所有的观察者onChange() for (int i = mObservers.size() - 1; i \u003e= 0; i--) { mObservers.get(i).onChanged(); } } } } 可以看到我们调用的notifyDataSetChanged()会遍历所有的观察者中的onChange(). 这些观察者就是在ListView通过setAdapter()方法设置Adapter产生的. @Override public void setAdapter(ListAdapter adapter) { // 如果已经有了一个Adapter, 那么先注销该Adapter对应的观察者 if (mAdapter != null \u0026\u0026 mDataSetObserver != null) { mAdapter.unregisterDataSetObserver(mDataSetObserver); } super.setAdapter(adapter); if (mAdapter != null) { mAreAllItemsSelectable = mAdapter.areAllItemsEnabled(); mOldItemCount = mItemCount; // 获取数据的数量 mItemCount = mAdapter.getCount(); checkFocus(); // *** 创建一个数据集观察者 mDataSetObserver = new AdapterDataSetObserver(); // 将这个观察者注册到Adapter中, 实际上注册到了 DataSetObservable中 mAdapter.registerDataSetObserver(mDataSetObserver); } requestLayout(); } 可以看出, 在设置Adapter时会构建一个AdapterDataSetObserver, 这就是之前说的观察者, 最后将这个观察者注册到Adapter中 那么AdapterDataSetObserver是什么? 是如何运作的? 首先这个这个类定义在了ListView的父类AbsListView中, 而这个类又继承了AbsListView的父类AdapterView的AdapterDataSetObserver.如下 class AdapterDataSetObserver extends DataSetObserver { private Parcelable mInstanceState = null; // 核心方法 @Override public void onChanged() { mDataChanged = true; mOldItemCount = mItemCount; // 获取adapter的数量 mItemCount = getAdapter().getCount(); if (AdapterView.this.getAdapter().hasStableIds() \u0026\u0026 mInstanceState != null \u0026\u0026 mOldItemCount == 0 \u0026\u0026 mItemCount \u003e 0) { AdapterView.this.onRestoreInstanceState(mInstanceState); mInstanceState = null; } else { rememberSyncState(); } checkFocus(); // 重新布局 requestLayout(); } } 这回应该很清楚了, 当ListView的数据发生变化时, 调用了Adapter#notifyDataSetChanged()函数, 这个函数又会调用DataSetObserver#notifyChange()函数, 这个函数会遍历所有的观察者AdapterDataSetObserver#onChange() 在onChange()方法中又会调用ListView重新布局, 使得ListView刷新界面 实战场景 事件总线! ","date":"2016-11-16","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/:3:11","tags":["设计模式"],"title":"设计模式之路","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/"},{"categories":null,"content":"备忘录模式 Memento 模式介绍 一种行为模式, 该模式用于保存对象, 并且在之后可以再次恢复到此状态 定义: 在不破坏封闭的前提下, 捕获一个对象的内部状态,并在该对象之外保存这个状态, 以后就可将该对象恢复到原先保存的状态. 场景: 需要保存一个对象在某一个时刻的状态或部分状态 如果用一个接口来让其他对象得到这些状态, 将会暴露对象的实现细节并破坏对象的封装性, 一个对象不希望外界直接访问其内部状态, 通过中间对象可以间接访问其内部状态. 模式范例 比如一个游戏, 在退出时候保存进度, 在进入的时候恢复进度的场景 范例源码 范例类图 范例的使用–\u003e public static void main(String arg[]){ // 构建游戏对象 CallOfDuty game = new CallOfDuty(); // 1 打游戏 game.play(); Caretaker caretaker = new Caretaker(); // 2 游戏存档 caretaker.archive(game.createMemo()); // 3 退出游戏 game.quit(); // 4 恢复游戏 CallOfDuty newGame = new CallOfDuty(); newGame.restore(caretaker.getMemo()); } // =======\u003e 运行结果 玩游戏: 第1关 奋战杀敌中 进度升级中 到达 第2关 ----- 退出前的游戏属性: 当前游戏信息: checkpoint=2 ,mLifeValue=90 ,mWeapon=沙漠之鹰 退出游戏 ----- 恢复后的游戏属性--\u003e 当前游戏信息: checkpoint=2 ,mLifeValue=90 ,mWeapon=沙漠之鹰 可以看到CallOfDuty在这里为Originator角色, 也就是需要存储的对象, 在这里并没有直接存储对象, 而是通过Memo对CallOfDuty对象的数据进行存储, 然后在存储Memo对象, 最终对Memo的存储操作交给Caretaker对象. 在这个过程中, 各个角色职责清晰, 单一, 即对外屏蔽了对CallOfDuty角色的直接访问, 在满足了对象状态存取功能的同时也使得该模块的结构清晰, 整洁. Android源码对应实现 在Android源码中的状态模式应用是Activity中的状态保存. 在这里, Activity扮演了Caretaker角色, 负责存储和恢复UI的状态信息; Activity,Fragment,View,ViewGroup等对象为Originator角色, 也就是需要存储状态的角色. Memo则由Bundle类扮演. ","date":"2016-11-16","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/:3:12","tags":["设计模式"],"title":"设计模式之路","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/"},{"categories":null,"content":"迭代器模式 Iterator 模式介绍 也成为游标模式, 行为性设计模式. 源于对容器的访问. 定义: 提供了一种方法顺序访问一个容器对象中的各个元素, 而不需要暴露该对象的内部表示 场景: 遍历一个容器对象 模式实现 场景: 如两个部门, 老板想要对两个部门的统计数据, 但是如果两个部门的内部实现存储如果是一个用数组, 一个集合, 那么老板访问就需要了解其内部的数据结构. 使得老板的职责过多, 这个时候如果用迭代器模式实现,统一遍历方式, 那么就会很方便,也不会对外暴露内部的实现细节. 如下: 范例代码 使用情况: public static void main(String args[]){ CompanSu companSu = new CompanSu(); check(companSu.iterator()); CompanLi companLi = new CompanLi(); check(companLi.iterator()); } private static void check(Iterator iterator) { while (iterator.hasNext()){ System.out.println(iterator.next().toString()); } } // ======\u003e 结果 Employee{name='小敏', age=99, sex='男', position='程序员'} Employee{name='小李', age=98, sex='男', position='程序员'} Employee{name='小往', age=11, sex='女', position='程序员'} Employee{name='小爱', age=9, sex='女', position='程序员'} Employee{name='大敏', age=66, sex='妖', position='未知'} Employee{name='大李', age=66, sex='妖', position='未知'} 这个例子只是列举个思想, 可以看到通过迭代器实现, 就可以对外通过一个统一的接口, 来对不同的内部细节不一样的容器进行访问. 这也是List,Map都实现迭代器的意义. Android源码对应实现 几乎开发者不会自己去实现一个迭代器, 例如Android中, 除了各种数据结构体, 最典型的就是数据库查询使用了Cursor. 当使用SQLiteDatabase#query()方法查询数据时, 会返回一个Cursor对象. 该对象实质就是一个迭代器. 所以可以看出迭代器模式, 特点很明显也很单一, 支持以不同的方式去遍历一个容器对象, 也可以有多个遍历, 弱化了容器与遍历算法之间的关系. 几乎每一种高级语言都有对应的内置迭代器实现. ","date":"2016-11-16","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/:3:13","tags":["设计模式"],"title":"设计模式之路","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/"},{"categories":null,"content":"模板模式 Template 模式介绍 某一个算法所需要的关键步骤是已知的, 但是某一步的具体实现是未知的需要子类去实现 定义: 定义一个操作中的算法框架, 而将一些步骤延迟到子类中, 使得子类可以不改变一个算法的结构即可重定义该算法的某些步骤. 场景: 多个子类有共有的方法, 并且逻辑基本相同 重要, 复杂的算法, 可以把核心算法设计为模板方法, 周边的相关细节由子类去实现 重构时, 模板方法模式是一个经常使用的模式, 把相同的代码抽取到父类, 然后通过钩子函数约束其行为 模式范例 模板方式实际上是封装一个固定流程, 然后暴露某一个步骤方法, 这里以计算机开机为例子, 范例代码 代码使用: public static void main(String arg[]){ CodeComputer codeComputer = new CodeComputer(); codeComputer.startUp(); MilitaryComputer militaryComputer = new MilitaryComputer(); militaryComputer.startUp(); } // ========\u003e 运行结果 --------- 开机 start ----------- 开启电源 硬件检测 载入操作系统 需要密码 ---------- 关机 end --------------- --------- 开机 start ----------- 开启电源 硬件检测 \u003e\u003e 需要检测防火墙 载入操作系统 需要进行眼膜验证 ---------- 关机 end --------------- 上面代码不管什么情况四个步骤是必须的, 开启电源是刚需,不需要子类实现, startUp()设置方法是final因为调用流程是必须的. 而其余的方法根据不同的需求来进行改造. Android源码对应实现 Android中AsyncTask就是一个比较明显的模板方法模式. 其内部调用顺序就是 execute–\u003eonPreExecute–\u003edoInBackground–\u003eonPostExecute 或者比如Activity的声明周期方法. ","date":"2016-11-16","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/:3:14","tags":["设计模式"],"title":"设计模式之路","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/"},{"categories":null,"content":"访问者模式 Visitor 模式介绍 访问者模式是一种将数据操作与数据结构分离的设计模式,它是23种设计模式最复杂的一个, 但使用率不高. 大体思想, 软件系统中拥有一个由许多对象构成的, 比较稳定的对象结构, 这些对象的类都拥有一个accept方法用来接收访问者对象的访问. 访问者是一个接口, 他拥有visit方法, 这个方法对访问到的对象结构中不同的类型元素做出不同的处理. 定义: 封装一些作用于某种数据结构中的各个元素的操作, 它可以在不改变这个数据结构的前提下定义作用于这些元素的新的操作 场景: 对象结构比较稳定, 但经常需要在此对象结构上定义新的操作 需要对一个对象结构中的对象进行很多不同的并且不相关的操作, 而需要避免这些操作污染这些对象的类, 也不希望在增加新操作时修改这些类 模式范例 场景: 公司的年度考核, 评定员工分别是CEO和CTO, 而CEO只关注工程师的代码量和经理的新产品数; CTO关注的是工程师的KPI和经理的KPI. 这时CEO和CTO对于不同员工的关注点是不一样的. 这就需要对不同的员工类型进行不同的处理. 访问者模式此时可以派上用场了. 范例代码 代码使用结果: public static void main(String args[]){ // 构建报表 BusinessReport report = new BusinessReport(); System.out.println(\"----------给CEO看的报表----------\"); // 设置访问者, 这里是CEO report.showReport(new CEOVisitor()); System.out.println(\"----------给CTO看的报表----------\"); // 注入另一访问者CTO report.showReport(new CTOVisitor()); } // ======\u003e 结果 ----------给CEO看的报表---------- CEO访问--\u003e 经理王经理 . KPI : 9 , 新产品数量: 0 CEO访问--\u003e 工程师工程师-jake . KPI : 2 CEO访问--\u003e 工程师工程师-小李 . KPI : 5 CEO访问--\u003e 工程师工程师-小张 . KPI : 0 ----------给CTO看的报表---------- CTO访问--\u003e 经理 王经理 , 新产品数量: 0 CTO访问--\u003e 工程师 工程师-jake . 代码行数 : 14290 CTO访问--\u003e 工程师 工程师-小李 . 代码行数 : 2183 CTO访问--\u003e 工程师 工程师-小张 . 代码行数 : 83422 范例中Staff扮演了Element角色, 而Enginner和Manager都是ConcreteElement; CEOVisitor和CTOVistor都是具体的Vistor对象, 而BusinessReport就是ObjectStructure; Client就是客户端 访问者最大的优点就是增加访问者非常容易, 如果要增加一个访问者, 只需要创建一个实现了Visitor接口的类, 然后实现两个visi函数来对不同的元素进行不同的操作, 从而达到数据对象与数据操作相分离的效果. Android源码对应实现 APT的注解. 简单记录一下. 首先编译器将代码抽象成一个代码元素的树, 然后在编译时对整棵树进行遍历访问, 每个元素都有一个accept()接收访问者的访问, 每个访问者中都有对应的visit()函数, 例如visitType()函数就是对类型元素的访问, 在每个visit函数中对不同的类型进行不同的处理, 这样就达到了差异处理效果, 同时将数据结构与数据操作分离, 使得每个类型的职责单一, 易于升级维护. JDK还特意预留了visitUnknown()接口应对Java语言后续发展可能添加的元素类型问题, 灵活的将访问者模式的缺点化解. ","date":"2016-11-16","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/:3:15","tags":["设计模式"],"title":"设计模式之路","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/"},{"categories":null,"content":"中介者模式 Mediator 模式介绍 也称为调节者模式或者调停者模式 定义: 包装了一系列对象互相作用的方式, 使得这些对象不必互相明显作用. 从而使他们可以松散耦合. 当某些对象之间的作用发生改变时, 不会立即影响其他的一些对象之间的作用. 保证这些作用可以彼此独立的变化. 中介者模式将多对多的关系转化为一对多的相互作用. 中介者模式将对象的行为和协作抽象化, 把对象在小尺度的行为上与其他对象的相互作用分开处理. 场景: 当对象之间的交互操作很多且每个对象的行为都依赖彼此时, 为防止在修改一个对象的行为会涉及修改很多其他对象的行为, 可采用中介者模式, 来解决紧耦合问题. 该模式将对象之间的多对多关系变成了一对多关系, 中介者对象将系统从网状结构变成以调停者为中心的星形结构, 达到降低系统的复杂性, 提高可扩展的作用. 模式范例 场景: 以电脑为例, 电脑主要部分为:CPU, 内存, 显卡, IO设备. 通常需要一个东西把这些组件连接起来共同工作,这就是主板的工作. 任何的两块模块之间的通信都会经过主板去协调. 这里以读取光盘为例.看主板是如何充当这个中介者角色的. 范例代码 代码使用 public static void main(String arg[]){ // 构造主板对象 MainBoard mainBoard = new MainBoard(); // 构造各个零件同事 CDDevice cdDevice = new CDDevice(mainBoard); CPU cpu = new CPU(mainBoard); GraphicsCard graphicsCard = new GraphicsCard(mainBoard); SoundCard soundCard = new SoundCard(mainBoard); // 将各个部件安装到主板 mainBoard.setCdDevice(cdDevice); mainBoard.setCpu(cpu); mainBoard.setGraphicsCard(graphicsCard); mainBoard.setSoundCard(soundCard); // 完成后开始放片 cdDevice.load(); } 从图片可以看出, 虽然彼此间会互相交互, 但是通过中介者模式, 会让一个网状的关系, 转成一个以中介者为中心的星状图. Android源码对应实现 中介者模式在Android源码中比较好的例子是Keyguard锁屏的实现. public class KeyguardViewMediator extends SystemUI { private AlarmManager mAlarmManager; private AudioManager mAudioManager; private StatusBarManager mStatusBarManager; private boolean mSwitchingUser; private boolean mSystemReady; private boolean mBootCompleted; private boolean mBootSendUserPresent; // .... } 可以看到类中存在很多XXManager的变量, 这些各种各样的管理器就是各个具体的实现类, Android使用KeyguardViewMediator充当这个中介者协调这些管理器的状态改变, 同样也会定义很多方法来处理这些管理器的状态, 以解锁或锁屏时声音的播放为例, 对应的方法playSounds()来协调音频这一状态. 而其他管理器的协调同样可以在此类找到. 而另一个中介者模式的例子就是Binder机制, 在Binder机制中有3个非常重要的组件ServiceManager,Binder Driver和Bp Binder. 其中Bp Binder是Binder的一个代理角色, 其提供了IBinder接口给各个客户端服务使用, 这三者就扮演了一个中介者角色 当手机启动后, ServiceManager会先向Binder Driver进行注册, 同样ServiceManager也是一个服务, 但特殊性在于, 它在Binder Driver中是最先被注册的, 其注册ID为0, 当其他的服务想要注册到Binder Driver时, 会先通过这个0号ID获取到ServiceManager所对应的IBinder接口, 该接口实质上的实现逻辑是由Bp Binder实现的, 获取到对应的接口后就回调其中的transact()方法, 此后就会在Binder Driver中注册一个ID 1来对应这个服务, 如果客户端想要使用这个服务, 那么他会先获取ID 0的接口, 也就是ServiceManager所对应的接口, 并调用其transact()要求连接到刚才的服务, 这个时候Binder Driver就会将ID 1的服务回传给客户端并将相关信息反馈给ServiceManager完成连接. 这里ServiceManger和Binder Driver就相当于一个中介者, 协调各个服务器和客户端. ","date":"2016-11-16","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/:3:16","tags":["设计模式"],"title":"设计模式之路","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/"},{"categories":null,"content":"代理模式 Proxy 模式介绍 也称委托模式, 结构性设计模式. 生活中也是有很多常见的代理例子, 代理上网, 叫外卖, 通过律师打官司都是一种代理 定义: 为其他对象提供一种代理以控制对这个对象的访问 场景: 当无法或不想直接访问某个对象或访问某个对象存在困难时可以通过一个代理对象来间接访问, 为了保证客户端使用的透明性, 委托对象与代理对象需要实现相同的接口. 模式范例 场景: 公司拖欠工资, 员工通过律师来间接的和公司要钱. 范例源码 使用时代码 public static void main(String args[]){ // 构造一个起诉者 ConcreteLawsuit concreteLawsuit = new ConcreteLawsuit(); // 构造一个律师, 被代理者 Lawyer lawyer = new Lawyer(concreteLawsuit); // 律师代理 lawyer.submit(); lawyer.burden(); lawyer.defend(); lawyer.finish(); } 代理模式大致分为两个部分, 一个是静态代理,还有一个是动态代理. 静态代理如上述示例那样, 代理者的代码由程序员自己或者通过自动化工具生成固定的代码再对其进行编译, 也就是说在我们的代码运行前代理类class编译文件就已经存在 动态代理则与静态代理相反, 通过反射机制动态生成代理者对象, 也就是说我们在code阶段压根就不需要知道代理谁, 代理谁将会在执行阶段决定, 而Java也给我们提供了一个便捷的动态代理接口InvocationHandler, 并复写invoke() 动态代理最终的调用方式: // 构造一个动态代理 DynamicProxy dynamicProxy = new DynamicProxy(concreteLawsuit); // 获取被代理者的ClassLoader ClassLoader classLoader = concreteLawsuit.getClass().getClassLoader(); // 动态构造一个代理者律师 ILawsuit law = (ILawsuit) Proxy.newProxyInstance(classLoader, new Class[]{ILawsuit.class}, dynamicProxy); // 动态调用 law.submit(); law.burden(); law.defend(); law.finish(); Android源码对应实现 Android源码中的代理模式实现有很多, 如源码中的ActivityManagerProxy代理类, 其具体代理的是ActivityManagerNative的子类ActivityManagerService. ActivityManagerProxy与ActivityManagerNative处于同一个文件. 而ActivityManagerProxy和ActivityManagerNative都继承了IActivityManager 可以很明显的看出这三个类构成的代理模式, 但是由于AMN是抽象类, 所以具体的实现交由了子类AMS去实现. 而AMS是系统级的Service并且运行于独立的进程空间中, 可以通过ServiceManager来获取它. 而AMP也运行于自己所处的进程空间中, 两者并不相同, 因此AMS和AMP的通信必定是通过跨进程来进行的, 所以此处源码中所实现的实质为远程代理. AMP在实际的逻辑处理中并未过多地被外部类使用, 因为在Android中管理与维护Activity相关信息的是另一个叫做ActivityManager的类, ActivityManager虽说管理着相关信息, 但是实质上其大多数逻辑都是由AMP承担的. ","date":"2016-11-16","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/:3:17","tags":["设计模式"],"title":"设计模式之路","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/"},{"categories":null,"content":"组合模式 Composite 模式介绍 结构性设计模式, 比较简单, 把一组相似的对象看做一个对象来处理, 并根据一个树状结构来组合对象, 然后提供一个统一的方法去访问相应的对象, 以此忽略掉对象与对象集合之间的差别. 定义: 将对象组合成树形结构以表示整体-部分的层次结构, 使得用户对单个对象和组合对象的使用一致性 场景: 表示对象的部分-整体层次结构 从一个整体中能够独立出部分模块或功能的场景 模式范例 一个很好的组合例子就是文件夹和文件之间的关系. 以此为例, 看看一个简单文件系统是如何构成的. 范例源码 使用代码和结果 public static void main(String arg[]){ // 构造一个目录对象表示c盘目录 Folder diskC = new Folder(\"C\"); // C盘根目录下有一个文件 Log.txt diskC.addDir(new File(\"Lag.txt\")); // C盘下还有3个子目录 diskC.addDir(new Folder(\"目录1\")); Folder dirs = new Folder(\"目录2\"); dirs.addDir(new File(\"null.txt\")); diskC.addDir(dirs); diskC.addDir(new Folder(\"目录3\")); // 打印文件结构 diskC.print(); } // =========\u003e 结果 C (Lag.txt,目录1 (),目录2 (null.txt),目录3 ()) 从根节点依次延伸可以很明显看出这是一个树状的嵌套结构. 这就是组合模式 Android源码对应实现 这个模式在Android有一个很经典的表示, 我们一直再使用, 就是View和ViewGroup结构. 由于View的视图层级中使用的是安全的设计模式, 所以只能是ViewGroup才可以包含View,反之则不可以, 而上面的范例使用的是透明的组合模式. 可以观察一下具体有哪些不同. ","date":"2016-11-16","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/:3:18","tags":["设计模式"],"title":"设计模式之路","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/"},{"categories":null,"content":"适配器模式 Adapter 模式介绍 这也是一个我们从始至终都在使用的模式, ListView,GridView,RecycleView. 适器就是将两个不兼容的类融合在一起, 有点像粘合剂. 定义: 把一个类的接口转换成客户端所期待的另一个接口, 从而使原本因接口不匹配而无法在一起工作的两个类能够在一起工作. 场景: 系统需要使用现有的类, 而此类的接口不符合系统的需要, 即接口不兼容 想要建立一个可以重复使用的类, 用于与一些比起之间没有太大关联的一些类, 包括一些可能在将来引进的类一起工作 需要一个统一的输出接口, 而输入端的类型不可预知 模式范例 软件开发有一句话: 任何问题都可以加一个中间层来解决. 正式对适配器模式的描述, 最常见的就是笔记本电脑一般用的5V电压, 但是生活中的电压都是标准的220V. 所以我们笔记本都通过一个电源适配器来解决此问题. 范例代码 类图关系很简单就不贴出来了 代码中有两种实现: 类适配器模式 : 主要是Adapter角色是继承需要适配的角色. 对象适配器模式: 通过在构造适配器的时候传入适配对象. 使用组合的形式实现接口兼容. 相比较, 使用对象适配器更加的灵活, 另一个好处就是被适配对象的方法不会暴露出来, 而类适配器由于继承了被适配的对象, 因此被适配对象类在Adapter类中同样存在, 这就使得Adapter出现了一些奇怪的方法, 用户的使用成本也较高. Android源码对应实现 不用说Adapter大家都知道. Android的做法增加了个Adapter层来隔离变化, 将ListView需要的关于Item View接口抽象到Adapter对象中, 并且在ListView内部调用了Adapter这些接口完成布局等操作. 这样只要用户实现了Adapter的接口, 并且将该Adapter设置给ListView, ListView就可以按照用户设定的UI效果, 数量, 数据来显示每一项数据. ","date":"2016-11-16","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/:3:19","tags":["设计模式"],"title":"设计模式之路","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/"},{"categories":null,"content":"装饰模式 Decorator 模式介绍 也称包装模式, 结构性设计模式, 使用一种对客户端透明的方式来动态的扩展对象的功能, 同时他也是继承关系的一种替代方案之一 定义: 动态地给一个对象添加一些额外的职责. 就增加功能来说, 装饰模式相比生成子类更加灵活. 场景: 需要透明且动态地扩展类的功能时 模式范例 人穿衣服的例子 范例源码 其实可以这种扩展并非是直接修改原有方法逻辑或者结构, 更恰当的说, 仅仅是在另一个类中将原有方法和逻辑进行封装整合. 装饰模式和代理模式有点类似, 比较容易混淆的是会把装饰模式当成代理模式. 装饰模式是以对客户端透明的方式扩展对象的功能, 是继承关系的一个替代方案. 而代理模式则是给一个对象提供一个对象代理, 并由代理对象来控制对原有对象的引用. 装饰模式应该为所装饰的对象增强功能; 代理模式对代理的对象施加控制, 但不对对象本身的功能增强. Android源码对应实现 Context, 是不是熟悉的不能再熟悉了. 它的本质就是一个抽象类. 在装饰模式中相当于抽象组件. 虽然Activity继承了Context但是其中的startActivity(),startService()这些都是由另一个继承者来处理的的. 这个Context的另一个继承者就是ContextImpl. ContextImpl内部实现了Context的抽象方法. 而Activity等组件只是将其中的方法进行了转发调用. ","date":"2016-11-16","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/:3:20","tags":["设计模式"],"title":"设计模式之路","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/"},{"categories":null,"content":"享元模式 Flyweight 模式介绍 用尽可能减少内存使用量, 它适合用于可能存在大量重复对象的场景, 来缓存可共享的对象, 达到对象共享, 避免创建过多对象的效果. 就可以提升性能, 避免内存抖动 定义: 使用共享对象可有效地支持大量的相似对象 场景: 系统中存在大量的相似对象 细粒度的对象都具备比较接近的外部状态, 而且内部状态与环境无关, 也就是说对象没有特定身份 需要缓冲池的场景 模式范例 通过售票口的出票来为例 范例代码 代码使用和结果 public class Client { public static void main(String arg[]){ Ticket ticket = TicketFactory.getTicket(\"青岛\", \"北京\"); ticket.showTicketInfo(\"上铺\"); Ticket ticket1 = TicketFactory.getTicket(\"青岛\", \"上海\"); ticket1.showTicketInfo(\"上铺\"); Ticket ticket2 = TicketFactory.getTicket(\"青岛\", \"北京\"); ticket2.showTicketInfo(\"上铺\"); } } // ========\u003e 创建对象--\u003e 青岛-北京 购买 从青岛 到 上铺 的北京火车票, 价格: 293 创建对象--\u003e 青岛-上海 购买 从青岛 到 上铺 的上海火车票, 价格: 20 使用缓存--\u003e 青岛-北京 购买 从青岛 到 上铺 的北京火车票, 价格: 141 其实主要思想就是: 让可复用的对象实现复用, 减少无用的重复创建的步骤. Android源码对应实现 Message对象. 在使用Handler传递数据的时候. 不可避免的需要使用Message. 即使你通过Handler.post(Runnable)传递一个接口, 在源码内部同样会通过Message为载体挂到callback变量上传递. 看一下. 源码中是如何维护一个频繁需要使用对象的 private static Message sPool; // 静态! // 获取一个Message public static Message obtain() { synchronized (sPoolSync) { if (sPool != null) { Message m = sPool; sPool = m.next; m.next = null; m.flags = 0; // clear in-use flag sPoolSize--; return m; } } return new Message(); } // 回收, 实现缓存的方法 public void recycle() { if (isInUse()) { if (gCheckRecycle) { throw new IllegalStateException(\"This message cannot be recycled because it \" + \"is still in use.\"); } return; } recycleUnchecked(); } void recycleUnchecked() { flags = FLAG_IN_USE; what = 0; arg1 = 0; arg2 = 0; obj = null; replyTo = null; sendingUid = -1; when = 0; target = null; callback = null; data = null; synchronized (sPoolSync) { if (sPoolSize \u003c MAX_POOL_SIZE) { next = sPool; sPool = this; sPoolSize++; } } } Android是在调用了recycle()方法的时候实现了缓存, 在obtain()的时候取缓存如果没有, 那么就会创建新的对象. 缓存实现的方式是一个单向链表, 每次调用recycle()会把这个对象挂在链表头.看一下如下的图. ","date":"2016-11-16","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/:3:21","tags":["设计模式"],"title":"设计模式之路","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/"},{"categories":null,"content":"外观模式 Facade 模式介绍 使用频率很高, 也可以说是第三方SDK都会使用, 本质就是加上一个中间层的传递, 既可以做到统一一个高层类, 降低用户的使用成本, 也能屏蔽一些实现细节. 可能你不经意间使用很多次此模式, 只是没有在理论层面认知它的存在. 定义: 要求一个子系统的外部与其内部的通信必须通过一个统一的对象进行. 门面模式也就是Facade模式提供了一个高层次的接口. 场景: 为一个复杂子系统提供一个简单接口. 当需要构建一个层次结构的子系统时. 使用外观模式定义子系统的每层的入口点. 如果子系统相互依赖可以仅通过facade进行通信. 模式范例 以手机的外观模式为例 范例代码 Android源码对应实现 还是Context, Context对于开发者来说是最重要的高层接口. Context只是定义了很多接口的抽象类, 这些接口的功能实现并不是在Context以及子类中, 而是通过其他的子系统来完成的, 例如startActivity()的真正实现是通过AMS, 获取应用包信息是通过PMS. 而Centext只是做了一个高层次的统一封装. 好处显而易见, 对于开发者, 你只要知道这个高层类即可. 不需要知道太多的子系统就能完成开发. ","date":"2016-11-16","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/:3:22","tags":["设计模式"],"title":"设计模式之路","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/"},{"categories":null,"content":"桥接模式 模式介绍 结构性设计模式 定义: 将抽象部分与实际部分分离, 使他们都可以独立地进行变化 场景: 一个类存在两个独立变化的维度, 且这两个维度都需要进行扩展 对于那些不想使用继承或者因为多层次继承导致系统类的个数的急剧增加的系统, 也可以考虑使用此模式 如果一个系统需要在构件的抽象化角色和具体化角色之间更加灵活, 避免在两个层次之间建立静态的继承联系, 可以通过桥接模式使他们在抽象层建立一个关联关系 模式范例 以喝咖啡为例子, 一个咖啡馆中咖啡有四种, 分别是大杯加糖, 小杯加糖, 大杯无糖, 小杯无糖. 但是对于一杯咖啡来说这4种状态中实际上就是两种变化. 糖的状态和杯的状态. 范例代码 代码使用以及结果: public static void main(String args[]){ // 原汁原味 Ordinary ordinary = new Ordinary(); // 准备糖类 Sugar sugar = new Sugar(); // 大杯咖啡原味 LargeCoffee largeCoffee = new LargeCoffee(ordinary); largeCoffee.makeCoffee(); // 小杯咖啡 原味 SmallCoffee smallCoffee = new SmallCoffee(ordinary); smallCoffee.makeCoffee(); // 大杯咖啡 加糖 LargeCoffee larSugar = new LargeCoffee(sugar); larSugar.makeCoffee(); // 小杯咖啡 加糖 LargeCoffee smallSugar = new LargeCoffee(sugar); smallSugar.makeCoffee(); } //=========\u003e结果 大杯的 原味 咖啡 小杯的 原味 咖啡 大杯的 加糖 咖啡 大杯的 加糖 咖啡 这里CoffeeAdditives相当于作为了实现部分, 而Coffee则对应抽象部分, 模式中定义所谓的抽象和实现实质上对应的是两个独立变化的维度. 也就是说任何多维度变化或者说多个树状类之间的耦合都可以使用桥接模式来解耦. 范例中的这两个基类, 并不一定就是所谓的对应的角色, 两者各自为一维度,独立变化. 如果需要增加口味的种类, 只需要继承CoffeeAdditives实现不同的子类即可完成加奶,加盐的新功能的添加. 不管是这两个角色谁变化了, 相对于对方而言都是独立的没有过多的交际. Android源码对应实现 桥接模式在Android中应用的比较广泛. 一般都是作用于大范围. View的具体控件都定义了不同类型控件的所拥有的基本属性和行为, 但是将它们绘制到屏幕上的部分是与View相关的功能类DisplayList,Hardwarelayer,Canvas负责. 这俩个部分可以看做桥接 Adapter与AdapterView之间也可以看做是桥接 Window和WindowManager之间的关系. Window和PhoneWindow构成窗口的抽象部分; WindowManager和WindowManagerImpl为实现部分; 实现部分的具体实现类WMI使用WindowManagerGlobal通过IWindowManager接口与WMS进行交互. 并由WMS完成具体的窗口工作. ","date":"2016-11-16","objectID":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/:3:23","tags":["设计模式"],"title":"设计模式之路","uri":"/posts/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B7%AF/"},{"categories":null,"content":"[TOC] ","date":"2016-11-16","objectID":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/:0:0","tags":["面试整理"],"title":"面经之Java篇","uri":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/"},{"categories":null,"content":"Java基础 ","date":"2016-11-16","objectID":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/:1:0","tags":["面试整理"],"title":"面经之Java篇","uri":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/"},{"categories":null,"content":"关键字transient volatile transient 加了该关键字的属性，不会被序列化。 换句话说，这个字段仅存于调用者内存，而不会写到磁盘里持久化。 序列化原理：将待续列化的对象中的信息写入到磁盘或网络流中。序列化中的引用会进行“深度复制”，并且如果两个对象有共同的引用对象，且两个对象都写入同一个流，那么该引用对象不会重复创建，只会创建一次，并还原到虚拟机后引用的还是同一个对象。但是，如果写入不同的流中，那么两次创建的是完全不同还原对象。 volatile 每个线程访问堆中对象时，将堆中对象load到线程本地内存中，建立一个变量副本，之后线程就不再和对象在堆变量值有任何关系，而是直接修改副本变量值。 修改完之后，自动把线程变量副本的值写到对象在堆变量中。这样堆中对象的值就产生了变化。这些操作不是原子性的。 使用volatile修饰变量，JVM只是保证从内存加载到线程工作内存中的值是最新的。因此，即使使用volatile还是会存在并发情况。 比如： volatile static int a=0; //线程A和线程B同时执行 a++; 此时线程A拿到a的最新值0，线程B也拿到最新值0；但是，A执行a++后，值为1，B也同样计算得到a=1，它们再同时写回到堆内存，使得最后a的值为1，并不为2. ","date":"2016-11-16","objectID":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/:1:1","tags":["面试整理"],"title":"面经之Java篇","uri":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/"},{"categories":null,"content":"Java1.7 1.8新特性 Java1.7 （1）所有整数int， short，long，byte都可以用二进制表示，用0b开头。 （2）switch支持String类型。 （3）try-with-resource语句：在try()里面（括号里面）语句中声明一个或多个资源，try括号中的资源在最后会自动关闭. （4）catch多个异常 （5）数字类型的下划线表示 更友好的表示方式，不过要注意下划线添加的一些标准，如: long creditCardNumber = 1234_5678_9012_3456L; (6)泛型实例的创建可以通过类型推断来简化 可以去掉后面new部分的泛型类型，只用\u003c\u003e就可以了 Java1.8 (1)lambda表达式，最大的新增的特性 (2)允许给接口添加非抽象（即子类可以不用去实现）的方法，需要在方法前加default (3)函数式接口。每个lambda表达式都对应一个类型，通常是接口类型。而“函数式接口”是指仅仅只包含一个抽象方法的接口，每一个该类型的lambda表达式都会被匹配到这个抽象方法。因为默认方法不算抽象方法，所有也可以给函数式接口添加默认方法。我们可以将lambda表达式当成任意一个只包含一个抽象方法的接口类型。为确保你的接口满足这个要求，可以添加@FuntionalInterface注解。 (4)方法与构造函数引用。Java8允许使用::关键字来传递方法或者构造函数的引用。 (5) …… ","date":"2016-11-16","objectID":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/:1:2","tags":["面试整理"],"title":"面经之Java篇","uri":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/"},{"categories":null,"content":"interface和abstract类区别 继承方面: abstract class在Java中表示的是一种继承关系，一个类只能使用一次继承关系。但是，一个类却可以实现多个interface。 成员变量方面: 在abstract class中可以有自己的数据成员，也可以有非abstarct的方法，而在interface中，只能够有静态的不能被修改的数据成员（也就是必须是static final的，不过在interface中一般不定义数据成员），所有的方法都是public abstract的。 抽象方法方面: 实现抽象类和接口的类必须实现其中的所有抽象方法。抽象类中可以有非抽象方法，而接口中所有方法为抽象方法。 访问权限方面: 抽象类中的变量默认是friendly型，其值可以在子类中重新定义，也可以重新赋值。接口中定义的变量默认是public static final型，且必须给其赋初值，所以实现类中不能重新定义，也不能改变其值。 设计理念方面: abstract class和interface所反映出的设计理念不同。其实abstract class表示的是\"is-a“关系，interface表示的是”like-a“关系。 ","date":"2016-11-16","objectID":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/:1:3","tags":["面试整理"],"title":"面经之Java篇","uri":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/"},{"categories":null,"content":"XML解析方式DOM,SAX,PULL DOM 通过DOM解析xml的好处就是: 我们可以随时访问到某个节点的相邻节点，并且对xml文档的插入也非常的方便 不好的地方就是: 其会将整个xml文档加载到内存中，这样会大大的占用我们的内存资源 对于手机来说，内存资源是非常非常宝贵的，所以在手机当中，通过DOM这种方式来解析xml是用的比较少的。使用DOM方式，类似JS，可以调用getElementsByTagName()、getChildNodes()等等方法。 SAX SAX解析xml是基于事件流的处理方式的。因此每解析到一个标签，它并不会记录这个标签之前的信息，而我们只会知道当前这个标签的名字和它的属性，至于标签里面的嵌套，上层标签的名字这些都是无法知道的。SAX解析xml最重要的步骤就是定义一个我们自己的Handler处理类，我们可以让其继承 DefaultHandler这个类，然后在里面重写5个回调方法，分别是： startDocument startElement characters endElement endDocument PULL Pull解析和SAX解析类似，都是基于事件流的方式，在Android中自带了Pull解析的jar包，所以我们不需要导入第三方的jar包了。Pull解析器和SAX解析器虽有区别但也有相似性。 他们的区别为： SAX解析器的工作方式是自动将事件推入注册的事件处理器进行处理，因此你不能控制事件的处理主动结束；而Pull解析器的工作方式为允许你的应用程序代码主动从解析器中获取事件，正因为是主动获取事件，因此可以在满足了需要的条件后不再获取事件，结束解析。 他们的相似性在运行方式上: Pull解析器也提供了类似SAX的事件（开始文档START_DOCUMENT和结束文档END_DOCUMENT，开始 元素 TART_TAG和结束元素END_TAG，遇到元素内容TEXT等），但需要调用next()方法提取它们（主动提取事件）。调用parser.nextText();方法获取标签内的文本 XmlPullParserFactory factory = XmlPullParserFactory.newInstance(); XmlPullParser xmlPullParser = factory.newPullParser(); xml.setInput(new StringReader(xmlData)); int eventType = xmlPullParser.getEventType(); while(eventType!=XmlPullParser.END_DOCUMENT){ String nodeName = xmlPullParser.getName(); switch(eventType){ case XmlPullParser.START_DOCUMENT:{} case XmlPullParser.START_TAG:{} case XmlPullParser.END_TAG:{} } eventType = parser.next(); } ","date":"2016-11-16","objectID":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/:1:4","tags":["面试整理"],"title":"面经之Java篇","uri":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/"},{"categories":null,"content":"foreach和for循环 foreach foreach本质是通过迭代器遍历，有如下特点： 无需获取容器大小 需要创建额外的迭代器变量 遍历期间得到的是对象，没有索引位置信息，因此没办法将指定索引位置对象替换为新对象 for for需要获取容器大小，如果计算大小比较耗时，那么for循环效率肯定低下 for循环是根据容器大小防止越界，因此每次循环需要进行一次比较 效率 由于每次循环时，使用for循环都得计算容器大小并且还需要比较，因此，在对容器里面的每个元素进行遍历时，foreach效率更高。 这个结论也不是绝对的，在选择for，foreach的时候，应该考虑以下几点： 如果只是读数据，优先选择foreach，因为效率高，而且代码简单，方便； 如果要写数据，即替换指定索引位置处的对象，就只能选择for了，而且选择第二个for效率更高！ ","date":"2016-11-16","objectID":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/:1:5","tags":["面试整理"],"title":"面经之Java篇","uri":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/"},{"categories":null,"content":"NIO NIO是非阻塞的IO，Java NIO由一下几个核心部分组成：Channels、Buffers、Selectors。 虽然Java NIO中除此之外还有很多类和组件，但是Channel，Buffer和Selector构成了核心的API。其他组件如Pipe和FileLock,只不过是与其他三个核心组件共同使用的工具类。 Channel：基本上所有的IO在NIO中都从一个Channel开始，Channel有点像流。数据可以从Channel读到Buffer中，也可以从Buffer写到Channel中。Channel和Buffer有好多类型，Channel主要有：FileChannel、DataGramChannel、SocketChannel、ServerSocketChannel。涵盖了UDP和TCP网络的IO以及文件IO。 Buffer：NIO主要的Buffer有：ByteBuffer、CharBuffer、DoubleBuffer、FloatBuffer、IntBuffer、LongBuffer、ShortBuffer这些Buffer涵盖了你能通过IO发送的基本数据类型。 Selector：允许单线程处理多个Channel。如果你的应用打开了多个连接（通道），但每个连接的流量都很低，使用Selector就会很方便。例如一个聊天服务器中。要使用Selector，得先向Selector注册Channel然后调用它的select()方法。这个方法会一直堵塞知道某个注册的通道有事件就绪。一旦这个方法返回线程就可以处理这些事件，事件的例子有如新连接进来，数据接收等。 NIO的使用 // 注册 // 创建Selector对象 Selector sel = Selector.open(); // 创建可选择通道，并配置为非阻塞模式 ServerSocketChannel server = ServerSocketChannel.open(); server.configureBlocking(false); // 绑定通道到指定端口 ServerSocket socket = server.socket(); InetSocketAddress address = new InetSocketAddress(port); socket.bind(address); // 向Selector中注册感兴趣的事件 server.register(sel, SelectionKey.OP_ACCEPT); return sel; // 处理 try { while(true) { // 该调用会阻塞，直到至少有一个事件发生 selector.select(); Set\u003cSelectionKey\u003e keys = selector.selectedKeys(); Iterator\u003cSelectionKey\u003e iter = keys.iterator(); while (iter.hasNext()) { SelectionKey key = (SelectionKey) iter.next(); iter.remove(); process(key); } } } catch (IOException e) { e.printStackTrace(); } ByteBuffer使用 创建ByteBuffer //（1）使用allocate()静态方法 ByteBuffer buffer=ByteBuffer.allocate(256); //以上方法将创建一个容量为256字节的ByteBuffer,如果发现创建的缓冲区容量太小,唯一的选择就是重新创建一个大小合适的缓冲区. //（2）通过包装一个已有的数组来创建如下,通过包装的方法创建的缓冲区保留了被包装数组内保存的数据. ByteBuffer buffer=ByteBuffer.wrap(byteArray); // 如果要将一个字符串存入ByteBuffer,可以如下操作: String sendString=\"你好,服务器. \"; ByteBuffer sendBuffer=ByteBuffer.wrap(sendString.getBytes(\"UTF-16\")); 缓冲区 buffer.flip(); //这个方法用来将缓冲区准备为数据传出状态,执行以上方法后,输出通道会从数据的开头而不是末尾开始.回绕保持缓冲区中的数据不变,只是准备写入而不是读取. buffer.clear(); //这个方法实际上也不会改变缓冲区的数据,而只是简单的重置了缓冲区的主要索引值.不必为了每次读写都创建新的缓冲区,那样做会降低性能.相反,要重用现在的缓冲区,在再次读取之前要清除缓冲区. 3.3 一个简单例子 使用通道和ByteBuffer实现文件复制功能： public void copy(String from, String to) throws IOException { // 分配缓存 ByteBuffer buff = ByteBuffer.allocate(128); // 输入、输出通道 FileChannel fin = null; FileChannel fout = null; try { // 初始化输入输出通道 fin = new FileInputStream(from).getChannel(); fout = new FileOutputStream(to).getChannel(); // 从输入通道循环读取数据到缓存，并把缓存数据写入到输出通道 while (fin.read(buff) != -1) { buff.flip(); fout.write(buff); buff.clear(); } } catch (FileNotFoundException e) { } finally { try { if (fin != null) { fin.close(); } if (fout != null) { fout.close(); } } catch (IOException e) { throw e; } } } //如果需要将ByteBuffer转为FloatBuffer，则可以通过调用： ByteBuffer buff = ByteBuffer.allocate(128); buff.asFloatBuffer() //ByteBuffer转为其他的Buffer，如:CharBuffer、DoubleBuffer、IntBuffer、LongBuffer、ShortBuffer，都有对应的asXXXBuffer()方法。 ","date":"2016-11-16","objectID":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/:1:6","tags":["面试整理"],"title":"面经之Java篇","uri":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/"},{"categories":null,"content":"反射机制 什么是反射 反射机制允许程序在运行时取得任何一个已知名称的class的内部信息，容许程序在运行时加载、探知、使用编译期间未知的class。即Java的反射机制可以加载一个运行时才得知名称的class，获得其完整结构。所谓的反射机制就是Java语言在运行时拥有一项自观的能力，即程序可以在运行时访问、检测和修改它本身状态或行为的一种能力。通过这种能力可以彻底的了解自身的情况为下一步的动作做准备。 反射操作的对象 在程序运行期间，Java运行时系统始终为所有的对象维护一个被称为运行时的类型标识。这个信息保存着每个对象所属的类足迹。虚拟机利用运行时信息选择相应的方法执行。然而，可以通过专门的Java类访问这些信息。保存这些信息的类称为Class，泛型形式为Class。Class是反射机制的基础，反射API通过操作Class来获取其完整结构。 Java的反射机制的实现要借助于4个类：Class，Constructor，Field，Method，通过这四个对象我们可以粗略的看到一个类的各个组成部分 反射提供的功能 Java 反射机制主要提供了以下功能： 在运行时判断任意一个对象所属的类 在运行时构造任意一个类的对象 在运行时判断任意一个类所具有的成员变量和方法 在运行时调用任意一个对象的方法 两种编译： 静态编译：在编译时确定类型，绑定对象,即通过。 动态编译：运行时确定类型，绑定对象。动态编译最大限度发挥了Java的灵活性，体现了多态的应用，有以降低类之间的藕合性。 反射机制优缺点: 优点：就是可以实现动态创建对象和编译，体现出很大的灵活性，特别是在J2EE的开发中 它的灵活性就表现的十分明显。 缺点：对性能有影响。使用反射基本上是一种解释操作，我们可以告诉JVM，我们希望做什么并且它满足我们的要求。这类操作总是慢于只直接执行相同的操作。并且它饶过了源码，会干扰原来的内部逻辑。 反射机制中常用API函数 // getClass()方式： /** * Object类中的getClass()方法返回一个Class类型的实例 */ Boolean var1 = true; Class\u003c?\u003e classType1 = var1.getClass(); //输出：class java.lang.Boolean System.out.println(classType1); //（2）T.class方式： /** * * 运用T.class 语法(T是任意的Java类型) */ Class\u003c?\u003e classType2 = Boolean.class; //输出：class java.lang.Boolean System.out.println(classType2); //（3）Class.forName()方式： /** * * 运用static method Class.forName()（使用时应该提供异常处理器） */ Class\u003c?\u003e classType3 = Class.forName(\"java.lang.Boolean\"); //输出：class java.lang.Boolean System.out.println(classType3); //（4）TYPE语法方式： /** * * 运用primitive wrapper classes的TYPE语法 * 这里返回的是原生类型,和Boolean.class返回的不同 */ Class\u003c?\u003e classType4 = Boolean.TYPE; //输出：boolean System.out.println(classType4); //注意：一个Class对象实际上表示的是一个类型，而这个类型未必一定是一种类。例如，int不是类，但int.class是一个Class类型的对象。虚拟机为每个类型管理一个Class对象。因此，可以用==运算符实现两个类对象比较的操作。 // Class常用的方法： /** * 返回类的名字 * 如：java.lang.String */ String getName(); /** * 快速地创建一个类的实例 * 调用默认构造器，如果该类没有默认构造器，抛出异常 * 如果要为构造器提供参数， * 使用java.lang.reflect.Constructor中的newInstance方法 */ Object newInstance(); /** * 返回超类 */ getSuperclass(); /** * 给定名称的形式分别返回类支持的public域、方法和构造器数组， * 其中包括超类的公有成员 */ Field[] getFields(); Method[] getMethods(); Constructor\u003c?\u003e[] getConstructors(); /** * 获取指定的域、方法、构造函数 */ Field getField(String name) Method getMethod(String name, Class\u003c?\u003e... parameterTypes) Constructor\u003cT\u003e getConstructor(Class\u003c?\u003e... parameterTypes) 使用反射分析类 一个类主要由修饰符，域，构造器，方法组成，而Field、Method、Constructor类，分别用于描述类的域、方法和构造器。另外java.lang.reflect包中的Modifier类可以分析访问修饰符。那么用它们就可以分析类。 Class getDeclaringClass() 返回一个用于描述类中定义的构造器、方法或域的Class对象 String getName() 返回相应条目的名称 int getModifiers() 返回整型数值，用不同的位开关描述访问修饰符的使用状况 Constructor Class[] getExceptionTypes() 返回一个用于描述方法抛出的异常类型的Class对象数组 Class[] getParameterTypes() 返回一个用于描述参数类型的Class对象数组 Field Class getType() 用于返回描述域所属类型的Class类型对象 static String toString(int modifiers) 返回对应modifiers位设置的修饰符的字符串表示 static boolean isXXX(int modifiers) 检测方法名中对应的修饰符在modifiers中的值 访问权限问题： 由于反射机制的默认行为受限于Java的访问控制，比如，访问私有的方法，字段，除非拥有访问权限，否则Java安全机制允许查看任意对象有哪些域，而不允许读它们的值（读取将抛异常）。然而如果一个Java程序没有受到安全管理器的控制，就可以覆盖访问控制。为了达到这个目的，就需要调用Field、Method、Constructor对象的setAccessible()方法。 void setAccessible(boolean flag) 为反射对象设置可访问标志，flag为true表明屏蔽Java语言的访问检查，使得对象的私有属性也可以被查询和设置 boolean isAccessible() 返回反射对象的可访问标志的值 static void setAccessible(AccessibleObject[] array, boolean flag) 一种设置对象数组可访问标志的快捷方法 ","date":"2016-11-16","objectID":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/:1:7","tags":["面试整理"],"title":"面经之Java篇","uri":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/"},{"categories":null,"content":"Object的公用方法 Object的共有方法如下： //创建并返回此对象的一个副本。 protected Object clone() ; //指示其他某个对象是否与此对象“相等” boolean equals(Object obj) ; /** * 当垃圾回收器确定不存在对该对象的更多引用时， * 由对象的垃圾回收器调用此方法 */ protected void finalize() ; //返回此 Object 的运行时类 Class getClass(); //返回该对象的哈希码值 int hashCode(); //唤醒在此对象监视器上等待的单个线程 void notify(); //唤醒在此对象监视器上等待的所有线程 void notifyAll(); //返回该对象的字符串表示 String toString(); /** * 在其他线程调用此对象的 notify() * 方法或 notifyAll() 方法前，导致当前线程等待 */ void wait(); /** * 在其他线程调用此对象的 notify() 方法或 notifyAll() 方法， * 或者超过指定的时间量前，导致当前线程等待 */ void wait(long timeout); /** * 在其他线程调用此对象的 notify() 方法或 notifyAll() 方法， * 或者其他某个线程中断当前线程，或者已超过某个实际时间量前， * 导致当前线程等待 */ void wait(long timeout, int nanos); ","date":"2016-11-16","objectID":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/:1:8","tags":["面试整理"],"title":"面经之Java篇","uri":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/"},{"categories":null,"content":"wait()和sleep()的区别 父类方面 这两个方法来自不同的类分别是：sleep来自Thread类；wait来自Object类。 sleep是Thread的静态类方法，谁调用的谁去睡觉，即使在a线程里调用b的sleep方法，实际上还是a去睡觉，要让b线程睡觉要在b的代码中调用sleep。 锁方面 最主要是sleep方法没有释放锁，而wait方法释放了锁，使得其他线程可以使用同步控制块或者方法。 sleep不出让系统资源；wait是进入线程等待池等待，出让系统资源，其他线程可以占用CPU。一般wait不会加时间限制，因为如果wait线程的运行资源不够，再出来也没用，要等待其他线程调用notify/notifyAll唤醒等待池中的所有线程，才会进入就绪队列等待OS分配系统资源。sleep(milliseconds)可以用时间指定使它自动唤醒过来，如果时间不到只能调用interrupt()强行打断。 Thread.sleep(0)的作用是“触发操作系统立刻重新进行一次CPU竞争”。 使用范围方面 wait，notify和notifyAll只能在同步控制方法或者同步控制块里面使用，而sleep可以在任何地方使用。 如： synchronized(x){ x.notify() //或者wait() } ","date":"2016-11-16","objectID":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/:1:9","tags":["面试整理"],"title":"面经之Java篇","uri":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/"},{"categories":null,"content":"BlockingQueue CountDownLatch BlockingQueue BlockingQueue接口定义了一种阻塞的FIFO queue，每一个BlockingQueue都有一个容量： 当容量满时，往BlockingQueue中添加数据时会造成阻塞,当容量为空时，取元素操作会阻塞。 BlockingQueue有两个实现类：ArrayBlockingQueue和LinkedBlockingQueue。 ArrayBlockingQueue 一个由数组支持的有界阻塞队列 按先进先出原则排序 一旦创建好这个数组，就不能再增加其容量 试图向已满的队列中放入元素会导致操作受阻塞 试图从空的队列中提取元素将导致类似的阻塞。 LinkedBlockingQueue LinkedBlockingQueue是一个基于已链接节点的、范围任意的blocking queue的实现 此队列按FIFO（先进先出）排序元素。队列的头部 是在队列中时间最长的元素。队列的尾部 是在队列中时间最短的元素 新元素插入到队列的尾部，并且队列检索操作会获得位于队列头部的元素。链接队列的吞吐量通常要高于基于数组的队列，但是在大多数并发应用程序中，其可预知的性能要低. 可选的容量范围构造方法参数作为防止队列过度扩展的一种方法。 如果未指定容量，则它等于Integer.MAX_VALUE。除非插入节点会使队列超出容量，否则每次插入后会动态地创建链接节点 ，容量范围可以在构造方法参数中指定作为防止队列过度扩展。 此对象是 线程阻塞-安全的 不接受null元素 实现了Collection和Iterator接口的所有可选 方法 在JDK5/6中，LinkedBlockingQueue和ArrayBlocingQueue等对象的poll(long timeout, TimeUnit unit)存在内存泄露Leak的对象AbstractQueuedSynchronizer.Node，据称JDK5会在Update12里Fix，JDK6会在Update2里Fix ArrayBlockingQueue和LinkedBlockingQueue的区别 队列中锁的实现不同 ArrayBlockingQueue实现的队列中的锁是没有分离的，即生产和消费用的是同一个锁； LinkedBlockingQueue实现的队列中的锁是分离的，即生产用的是putLock，消费是takeLock 在生产或消费时操作不同 ArrayBlockingQueue实现的队列中在生产和消费的时候，是直接将枚举对象插入或移除的； LinkedBlockingQueue实现的队列中在生产和消费的时候，需要把枚举对象转换为Node进行插入或移除，会影响性能 队列大小初始化方式不同 ArrayBlockingQueue实现的队列中必须指定队列的大小； LinkedBlockingQueue实现的队列中可以不指定队列的大小，但是默认是Integer.MAX_VALUE CountDownLatch 一个同步辅助类，在完成一组正在其他线程中执行的操作之前，它允许一个或多个线程一直等待。主要方法 public CountDownLatch(count); public void countDown(); public void await() ; 构造方法指定了计数的次数。countDown方法，当前线程调用此方法则计数减一。await方法，调用该方法会一直阻塞当前线程，直到计时器的值为0. ","date":"2016-11-16","objectID":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/:1:10","tags":["面试整理"],"title":"面经之Java篇","uri":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/"},{"categories":null,"content":"锁的等级 synchronized在修饰代码块的时候需要一个reference对象作为锁的对象. 在修饰实例方法的时候默认是当前实例对象作为锁的对象. 在修饰类方法（静态方法）时候默认是当前类的Class对象作为锁的对象. synchronized使用总结如下 对象锁钥匙只能有一把才能互斥，才能保证共享变量的唯一性 在静态方法上的锁，和实例方法上的锁，默认不是同样的，如果同步需要制定两把锁一样。 关于同一个类的方法上的锁，来自于调用该方法的对象，如果调用该方法的对象是相同的，那么锁必然相同，否则就不相同。比如 new A().x() 和 new A().x(),对象不同，锁不同，如果A的单例的，就能互斥。 静态方法加锁，能和所有其他静态方法加锁的 进行互斥 静态方法加锁，和xx.class 锁效果一样，直接属于类的 ","date":"2016-11-16","objectID":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/:1:11","tags":["面试整理"],"title":"面经之Java篇","uri":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/"},{"categories":null,"content":"synchronized lock reentrantLock synchronized 当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻最多只有一个线程执行该段代码，它是在 软件层面依赖JVM实现同步。 synchronized 方法的缺陷： 若将一个大的方法声明为synchronized将会大大影响效率，典型地，若将线程类的方法run()声明为synchronized，由于在线程的整个生命期内它一直在运行，因此将导致它对本类任何synchronized方法的调用都永远不会成功。 解决方案: 通过 synchronized关键字来声明synchronized 块。 Lock Lock接口实现提供了比使用synchronized方法和语句可获得的更广泛的锁定操作。此实现允许更灵活的结构，可以具有差别很大的属性，可以支持多个相关的Condition对象。在硬件层面依赖特殊的CPU指令实现同步更加灵活。 什么是Condition Condition接口将Object监视器方法（wait、notify 和 notifyAll）分解成截然不同的对象，以便通过将这些对象与任意 Lock实现组合使用，为每个对象提供多个等待set（wait-set）。其中，Lock替代了synchronized方法和语句的使用，Condition替代了 Object监视器方法的使用。 虽然synchronized方法和语句的范围机制使得使用监视器锁编程方便了很多，而且还帮助避免了很多涉及到锁的常见编程错误，但有时也需要以更为灵活的方式使用锁。例如，某些遍历并发访问的数据结果的算法要求使用\"hand-over-hand\"或\"chain locking”：获取节点 A的锁，然后再获取节点B的锁，然后释放A并获取C，然后释放B并获取D，依此类推。Lock接口的实现允许锁在不同的作用范围内获取和释放，并允许以任何顺序获取和释放多个锁，从而支持使用这种技术。 随着灵活性的增加，也带来了更多的责任。不使用块结构锁就失去了使用synchronized方法和语句时会出现的锁自动释放功能。在大多数情况下，应该使用以下语句： Lock l = ...; //lock接口的实现类对象 l.lock(); try { // access the resource protected by this lock } finally { l.unlock(); } 在java.util.concurrent.locks包中有很多Lock的实现类，常用的有ReentrantLock、ReadWriteLock（实现类ReentrantReadWriteLock）.它们是具体实现类，不是Java语言关键字。 ReentrantLock 一个可重入的互斥锁Lock，它具有与使用synchronized方法和语句所访问的隐式监视器锁相同的一些基本行为和语义，但功能更强大。 最典型的代码如下: class X { private final ReentrantLock lock = new ReentrantLock(); // ... public void m() { lock.lock(); // block until condition holds try { // ... method body } finally { lock.unlock() } } } 重入性：指的是同一个线程多次试图获取它所占有的锁，请求会成功。当释放锁的时候，直到重入次数清零，锁才释放完毕。 ReentrantLock的lock机制有2种，忽略中断锁和响应中断锁，这给我们带来了很大的灵活性。比如：如果A、B 2个线程去竞争锁，A线程得到了锁，B线程等待，但是A线程这个时候实在有太多事情要处理，就是一直不返回，B线程可能就会等不及了，想中断自己，不再等待这个锁了，转而处理其他事情。这个时候ReentrantLock就提供了2种机制，第一，B线程中断自己（或者别的线程中断它），但是ReentrantLock不去响应，继续让B线程等待，你再怎么中断，我全当耳边风（synchronized原语就是如此）；第二，B线程中断自己（或者别的线程中断它），ReentrantLock 处理了这个中断，并且不再等待这个锁的到来，完全放弃。 ReentrantLock相对于synchronized多了三个高级功能 等待可中断: 在持有锁的线程长时间不释放锁的时候,等待的线程可以选择放弃等待.tryLock(long timeout, TimeUnit unit) 公平锁: 按照申请锁的顺序来依次获得锁称为公平锁.synchronized的是非公平锁,ReentrantLock可以通过构造函数实现公平锁.new RenentrantLock(boolean fair)公平锁和非公平锁。这2种机制的意思从字面上也能了解个大概：即对于多线程来说，公平锁会依赖线程进来的顺序，后进来的线程后获得锁。而非公平锁的意思就是后进来的锁也可以和前边等待锁的线程同时竞争锁资源。对于效率来讲，当然是非公平锁效率更高，因为公平锁还要判断是不是线程队列的第一个才会让线程获得锁。 绑定多个Condition: 通过多次newCondition可以获得多个Condition对象,可以简单的实现比较复杂的线程同步的功能.通过await()，signal() synchronized和lock的用法与区别 synchronized是托管给JVM执行的，而Lock是Java写的控制锁的代码。 synchronized原始采用的是CPU悲观锁机制，即线程获得的是独占锁。独占锁意味着其他线程只能依靠阻塞来等待线程释放锁。而在CPU转换线程阻塞时会引起线程上下文切换，当有很多线程竞争锁的时候，会引起CPU频繁的上下文切换导致效率很低。　Lock用的是乐观锁方式。每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。 ReentrantLock必须在finally中释放锁，否则后果很严重，编码角度来说使用synchronized更加简单，不容易遗漏或者出错。 ReentrantLock提供了可轮询的锁请求，他可以尝试的去取得锁，如果取得成功则继续处理，取得不成功，可以等下次运行的时候处理，所以不容易产生死锁，而synchronized一旦进入锁请求要么成功，要么一直阻塞，所以更容易产生死锁。 synchronized的话，锁的范围是整个方法或synchronized块部分；而Lock因为是方法调用，可以跨方法，灵活性更大 一般情况下都是用synchronized原语实现同步，除非下列情况使用ReentrantLock: 某个线程在等待一个锁的控制权的这段时间需要中断 需要分开处理一些wait-notify，ReentrantLock里面的Condition应用，能够控制notify哪个线程 具有公平锁功能，每个到来的线程都将排队等候 ","date":"2016-11-16","objectID":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/:1:12","tags":["面试整理"],"title":"面经之Java篇","uri":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/"},{"categories":null,"content":"线程池 线程池基础 配置线程池一般如下语句： public static final Executor THREAD_POOL_EXECUTOR = new ThreadPoolExecutor( CORE_POOL_SIZE,MAXIMUM_POOL_SIZE,KEEP_ALIVE,TimeUnit.SECONDS, sPoolWorkQueue,sThreadFactory ); 当一个任务加入到线程池时: 如果此时线程池中的数量小于corePoolSize，即使线程池中的线程都处于空闲状态，也要创建新的线程来处理被添加的任务。 如果此时线程池中的数量等于 corePoolSize，但是缓冲队列 workQueue未满，那么任务被放入缓冲队列。 如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量小于maximumPoolSize，新建线程来处理被添加的任务。 如果此时线程池中的数量大于corePoolSize，缓冲队列workQueue满，并且线程池中的数量等于maximumPoolSize，那么通过 handler所指定的策略来处理此任务。 当线程池中的线程数量大于 corePoolSize时，如果某线程（非核心线程）空闲时间超过keepAliveTime，线程将被终止。这样，线程池可以动态的调整池中的线程数。 也就是,处理任务的优先级为： 核心线程corePoolSize 任务队列workQueue 最大线程maximumPoolSize 如果三者都满了，使用handler处理被拒绝的任务（一般为抛出java.util.concurrent.RejectedExecutionException异常） 线程池类型 线程池主要有以下4种： FixedThreadPool：线程数量固定的线程池，线程处于空闲状态时不会被回收，除非线程被关闭。当所有线程都处于活动状态时，新的任务都会处于等待状态，直到有线程空闲出来。 CachedThreadPool：线程数量不固定，只有非核心线程，可以放任意多个线程（Integer.MAX_VALUE）,线程池里所有线程处于活动状态时，创建新的线程处理新来的任务。否则利用闲置的线程处理新任务。线程池里空闲线程有超时机制，时长为60秒。 ScheduledThreadPool：核心线程数量是固定的，非核心线程是没有限制。当非核心线程闲置时会被立即回收。 SingleThreadExector：内部只有一个核心线程，确保所有任务在同一个线程中按顺序执行。 线程池使用方法 Runnable task=new Runnable(){ Public void run(){ //TODO ....... } }; //FixedThreadPool使用 ExecutorService fixedThreadPool=Executors.newFixedThreadPool(4); fixedThreadPool.execute(task); //CachedThreadPool的使用 ExecutorService cachedThreadPool=Executors.newCachedThreadPool(); cachedThreadPool.execute(task); //ScheduledThreadPool的使用 ExecutorService scheduledThreadPool=Executors.newScheduledThreadPool(4); //2000ms后执行task scheduledThreadPool.schedule(task,2000,TimeUnit.MILLISECONDS); //延迟10ms后，每隔1000ms执行一次task scheduledTheadPool.scheduleAtFixedRate(task,10,1000,TimeUnit.MILLISECONDS); //SingleThreadExector的使用 ExecutorService sigleThreadPool=Executors.newSingleThreadExecutor(); fixedThreadPool.execute(task); 线程池的优点 重用线程池中的线程，避免因为线程的创建和销毁所带来的性能开销 能有效控制线程池的最大并发数，避免大量线程之间因互相抢占系统资源而导致阻塞。 能够对线程进行简单的管理，并提供定时执行以及指定间隔循环执行等功能。 ","date":"2016-11-16","objectID":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/:1:13","tags":["面试整理"],"title":"面经之Java篇","uri":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/"},{"categories":null,"content":"线程 ThreadLocal 创建新线程的两种方法: 通过实现Runable接口,再将Runnable作为Thread的构造函数参数创建Thread对象 通过继承Thread类本身。 其实，Java中真正能创建新线程的只有Thread对象，通过Runnable的方式，最终还是需要通过Thread对象来创建线程。 当JVM启动时，通常都会有单个非守护线程（它通常会调用某个指定类的main方法）。JVM会继续执行线程，直到下列任一情况出现时为止： 调用了Runtime类的exit方法，并且安全管理器允许退出操作发生。 非守护线程的所有线程都已停止运行，无论是通过从对run方法的调用中返回，还是通过抛出一个传播到run方法之外的异常。 ThreadLocal设计理念和作用 设计理念 为每个线程创造一个资源的复本。将每一个线程存取数据的行为加以隔离，实现的方法就是给予每个线程一个特定空间来保管该线程所独享的资源。 作用 为每一个使用该变量的线程都提供一个变量值的副本，是每一个线程都可以独立地改变自己的副本，而不会和其它线程的副本冲突。从线程的角度看，就好像每一个线程都完全拥有该变量。 ThreadLocal使用 ThreadLocal实例通常是类中的private static字段，它们希望将状态与某一个线程相关联。每个线程都保持对其线程局部变量副本的隐式引用，只要线程是活动的并且ThreadLocal实例是可访问的，在线程消失之后，其线程局部实例的所有副本都会被垃圾回收（除非存在对这些副本的其他引用）。 // 首先创建ThreadLocal对象： ThreadLocal\u003cInteger\u003e mValue=new ThreadLocal\u003cInteger\u003e(); // 然后在线程中调用set和get方法来设置和获取值，例如： mValue.set(1); int value=mValue.get(); 实现原理 简单地说，就是在ThreadLocal类中有一个Map，用于存储每一个线程的变量的副本。Map的Key是Thread，value就是副本的值。 深入源码去看，ThreadLocal把线程和线程局部变量存在ThreadLocalMap中，而ThreadLocalMap是ThreadLocal的静态内部类，我们来看看ThreadLocalMap的部分源码： static class Entry extends WeakReference\u003cThreadLocal\u003c?\u003e\u003e { Object value; Entry(ThreadLocal\u003c?\u003e k, Object v) { super(k); value = v; } } 这个Map的key是ThreadLocal对象的弱引用，当要抛弃掉ThreadLocal对象时，垃圾收集器会忽略这个key的引用而清理掉ThreadLocal对象 。 那么到底是ThreadLocal还是Thread持有ThreadLocalMap对象的引用呢？ /* ThreadLocal values pertaining to this thread. * This map is maintained by the ThreadLocal class. */ ThreadLocal.ThreadLocalMap threadLocals = null; ThreadLocalMap变量属于Thread的内部属性,不同的Thread拥有完全不同的ThreadLocalMap变量.Thread中的ThreadLocalMap变量的值是在ThreadLocal对象进行set或者get操作时创建的.　在创建ThreadLocalMap之前,会首先检查当前Thread中的ThreadLocalMap变量是否已经存在,如果不存在则创建一个；如果已经存在,则使用当前Thread已创建的ThreadLocalMap.　ThreadLocal的接口方法 /** * 返回此线程局部变量的初始值 * * 线程第一次使用 get() 方法访问变量时将调用此方法，但如果线程之前调用 * 了 set(T) 方法，则不会对该线程再调用 initialValue 方法。通常，此 * 方法对每个线程最多调用一次，但如果在调用 get() 后又调用了 * remove()，则可能再次调用此方法。 * * 该实现返回 null；如果程序员希望线程局部变量具有 null 以外的值，则 * 必须为 ThreadLocal 创建子类，并重写此方法。通常将使用匿名内部类完 * 成此操作。 */ protected T initialValue(); /** * 返回此线程局部变量的当前线程的值 * * 如果变量没有用于当前线程的值，则先 * 将其初始化为调用initialValue() 方法返回的值。 */ public T get(); /** * 将此线程局部变量的当前线程副本中的值设置为指定值 * * 大部分子类不需要重写此方法，它们只依靠 initialValue() 方法 * 来设置线程局部变量的值 */ public void set(T value); /** * 移除此线程局部变量当前线程的值 * * 如果此线程局部变量随后被当前线程 读取，且这期间当前线程没有 * 设置其值，则将调用其 initialValue() 方法重新初始化其值。 * 这将导致在当前线程多次调用 initialValue 方法。 */ public void remove(); 如果希望线程局部变量初始化其它值，那么需要自己实现ThreadLocal的子类并重写该方法，通常使用一个内部类对ThreadLocal进行实例化。 ThreadLocal如何做到线程安全 从上面的分析我们可以得出： 因为每个Thread在进行对象访问时,访问的都是各自线程自己的ThreadLocalMap，所以保证了Thread与Thread之间的数据访问隔离。 不同的ThreadLocal实例操作同一Thread时，ThreadLocalMap在存储时采用当前ThreadLocal的实例作为key来保证数据访问隔离（上面源码Entry处可以看出）。　TheadLocal模式与同步机制的区别 实现机制: 同步机制采用了“以时间换空间”的方式,提供一份变量,让不同的线程排队访问.而ThreadLocal采用了“以空间换时间”的方式,为每一个线程都提供一份变量的副本,从而实现同时访问而互不影响。 同步共享方面: Java中的synchronized是一个保留字,它依靠JVM的锁机制来实现临界区的函数或者变量的访问中的原子性.在同步机制中,通过对象的锁机制保证同一时间只有一个线程访问变量.此时,被用作“锁机制”的变量是多个线程共享的；而ThreadLocal会为每一个线程维护一个和该线程绑定的变量的副本，从而隔离了多个线程的数据，每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。　3.使用场合同步机制是为了同步多个线程对相同资源的并发访问，是为了多个线程之间进行通信的有效方式。而ThreadLocal是隔离多个线程的数据共享，从根本上就不在多个线程之间共享资源（变量），这样当然不需要对多个线程进行同步了。所以，如果你需要进行多个线程之间进行通信，则使用同步机制。如果需要隔离多个线程之间的共享冲突，可以使用ThreadLocal。 ","date":"2016-11-16","objectID":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/:1:14","tags":["面试整理"],"title":"面经之Java篇","uri":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/"},{"categories":null,"content":"Java的四种引用 从JDK1.2版本开始，把对象的引用分为四种级别，从而使程序能更加灵活的控制对象的生命周期。这四种级别由高到低依次为：强引用、软引用、弱引用和虚引用。 强引用(StrongReference) 强引用是使用最普遍的引用。如果一个对象具有强引用，那垃圾回收器绝不会回收它。当内存空间不足，JVM宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足的问题。如代码String s=“abc\"中变量s就是字符串对象\"abc\"的一个强引用。只要你给强引用对象s赋空值null,该对象就可以被垃圾回收器回收。因为该对象此时不再含有其他强引用。 软引用（SoftReference） 如果内存足够，不回收；如果内存不足，则回收。软引用可用来实现内存敏感的高速缓存。软引用可以和引用队列ReferenceQueue联合使用，如果软引用的对象被垃圾回收，JVM就会把这个软引用加入到与之关联的引用队列中。 例如: String str=new String(\"Test\"); ReferenceQueue\u003cString\u003e rq=new ReferenceQueue\u003cString\u003e(); SoftReference\u003cString\u003e sr=new SoftReference\u003cString\u003e(str,rq); str = null; // 将强引用撤销 // 或者 SoftReference\u003cString\u003e sr=new SoftReference\u003cString\u003e(str); str=null;//将强引用撤掉 // 取出对象 String s = sr.get(); 如果被回收，则s为null，否则，s即为str所指引的对象\"Test” 弱引用(WeakReference) 弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程，因此不一定会很快发现那些只具有弱引用的对象，弱引用非常适合存储元数据。另一个使用弱引用的例子是WeakHashMap，它是除HashMap和TreeMap之外，Map接口的另一种实现。WeakHashMap有一个特点：Map中的键值(keys)都被封装成弱引用，也就是说一旦强引用被删除，WeakHashMap内部的弱引用就无法阻止该对象被垃圾回收器回收。弱引用的使用跟软引用使用方式相同，只是将SoftReference替换为WeakReference。 虚引用(PhantomReference) “虚引用\"顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。 虚引用主要用来跟踪对象被垃圾回收器回收的活动。虚引用与软引用和弱引用的一个区别在于：虚引用 必须 和引用队列 （ReferenceQueue）联合使用。当垃圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。 ","date":"2016-11-16","objectID":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/:1:15","tags":["面试整理"],"title":"面经之Java篇","uri":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/"},{"categories":null,"content":"static关键字 static静态修饰符 在程序中任何变量或者代码都是在编译时由系统自动分配内存来存储的。static修饰符表示静态的，在类加载时JVM会把它放到方法区，被本类以及本类的所有实例所共用。在编译后所分配的内存会一直存在，直到程序退出内存才会释放这个空间。如果一个被所有实例共用的方法被申明为static，那么就可以节省空间，不用每个实例初始化的时候都被分配到内存。 我们比较常见的static修饰是在静态变量和静态方法中。它们可以直接通过类名来访问。下面我们看看关于静态代码块和静态类。 静态代码块 说起静态代码块，就不得不说类初始化。类初始化是类加载的最后一步，前面类加载过程中，除了加载阶段用户可以通过自定义类加载器参与以外，其余动作都是虚拟机主导和控制。到了初始化阶段，才是真正执行类中定义Java程序代码。 准备阶段中，变量已经赋过一次系统要求的初始值，而在初始化阶段，根据程序员通过程序制定的主观计划初始化类变量。初始化过程其实是执行类构造器\u003cclinit\u003e()方法的过程。 \u003cclinit\u003e()方法是由编译器自动收集类中所有类变量的赋值动作和静态语句块中的语句合并产生的。收集的顺序是按照语句在源文件中出现的顺序。静态语句块中只能访问定义在静态语句块之前的变量，定义在它之后的变量可以赋值，但不能访问。 \u003cclinit\u003e()方法与类构造函数（或者说实例构造器()）不同，他不需要显式地调用父类构造器，虚拟机会保证子类的\u003cclinit\u003e()方法执行之前，父类的\u003cclinit\u003e()已经执行完毕。 静态类 只能在内部类中定义静态类 静态内部类与外层类绑定，即使没有创建外层类的对象，它一样存在。 静态类的方法可以是静态的方法也可以是非静态的方法，静态的方法可以在外层通过静态类调用，而非静态的方法必须要创建类的对象之后才能调用。 只能引用外部类的static成员变量（也就是类变量）。 如果一个内部类不是被定义成静态内部类，那么在定义成员变量或者成员方法的时候，是不能够被定义成静态的。 ","date":"2016-11-16","objectID":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/:1:16","tags":["面试整理"],"title":"面经之Java篇","uri":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/"},{"categories":null,"content":"集合的区别 Map 键映射到值的对象。 有如下特点: 一个映射不能包含重复的键 每个键最多只能映射到一个值。 某些映射实现可明确保证其顺序，如TreeMap类 另一类映射实现则不保证顺序如HashMap Map可以将key序列、value序列单独抽取出来。使用keySet()抽取key序列，将所有key生成一个Set。使用values抽取value序列，将所有value生成一个Collection，为什么key生成Set，而value生成Collection？因为key总是独一无二，value允许重复。 Map接口的部分函数原型如下: Set\u003cK\u003e keySet(); Collection\u003cV\u003e values(); V remove(Object key); V get(Object key); V put(K key, V value); void putAll(Map\u003c? extends K, ? extends V\u003e m); boolean containsKey(Object key); boolean containsValue(Object value); void clear(); int size(); boolean isEmpty(); Set 不能包含重复元素的Collection。如下特征： Set不包含满足e1.euqals(e2) 最多包含一个null元素(这里是指HashSet,TreeSet不支持插入null) 不可随机访问包含的元素 Set没有同步方法。 Set接口的部分函数原型如下: boolean add(E e); boolean remove(Object o); boolean addAll(Collection\u003c? extends E\u003e c); boolean removeAll(Collection\u003c?\u003e c); boolean contains(Object o); boolean containsAll(Collection\u003c?\u003e c); boolean retainAll(Collection\u003c?\u003e c); Object[] toArray(); T[] toArray(T[] a); void clear(); int size(); boolean isEmpty(); List 如下特征： 可随机访问包含的元素 元素是有序的 可在任意位置增、删元素 允许重复元素。 List接口的部分函数原型如下: E get(int index); E set(int index, E element); boolean add(E e); boolean remove(Object o); boolean addAll(Collection\u003c? extends E\u003e c); boolean removeAll(Collection\u003c?\u003e c); boolean contains(Object o); boolean containsAll(Collection\u003c?\u003e c); int indexOf(Object o); int lastIndexOf(Object o); boolean retainAll(Collection\u003c?\u003e c); Object[] toArray(); void clear(); int size(); boolean isEmpty(); Queue 队列，特点是先进先出。 Queue在使用时尽量避免Collection的add()和remove()方法，而是要使用offer()来加入元素，使用poll来获取并移出元素。他们的优点是通过返回值可以判断成功与否。add()和remove()方法在失败的时候会抛出异常。 如果使用而不移出该元素，使用element()或者peek()方法。值得注意的是LinkedList类实现了Queue接口，因此我们可以把LinkedList当初Queue来用。 Queue实现通常不允许插入null元素。尽管某些实现（如LinkedList）并不禁止将null插入到Queue中，即使在允许null的实现中，也不应将null插入到Queue中，因为null也作poll方法的一个特殊返回值，表明队列不包含元素。 Queue接口的部分函数原型如下: //插入新元素到队列，如果插入成功，返回true， //如果队列已满，抛出IllegalStateException异常 boolean add(E e); //插入新元素到队列，如果插入成功返回true //如果队列已满，返回false，但不抛出异常 boolean offer(E e); //返回第一个元素，并将该元素从队列中删除 //如果队列为空，抛出异常 E remove(); //返回第一个元素，并将该元素从队列中删除 //如果队列为空，返回null E poll(); //返回队列的第一个元素， //如果队列为空，抛异常 E element(); //返回队列的第一个元素， //如果队列为空，返回null E peek(); Queue接口有子接口BlockingQueue和Deque，BlockingQueue表示阻塞队列；Deque是双向队列，即可以从两端插入元素。BlockingQueue有如下几个实现类： ArrayBlockingQueue LinkedBlockingQueue 主要看看BlockingQueue的两个新方法： //插入一个新元素，如果队列已满，则一直等待（阻塞） void put(E e) throws InterruptedException; //返回队列的第一个元素并将该元素从队列里删除，如果队里为空，则一直等待（阻塞） E take() throws InterruptedException; ArrayBlockingQueue和LinkedBlockingQueue是阻塞队列的不同实现，即一个是通过数组方式，一个是通过链表的方式实现的阻塞队列。 有个特殊的接口BlockingDeque，BlockingDeque既实现了BlockingQueue又实现了Deque,而BlockingDeque的实现类有 LinkedBlockingDeque 前面我们说到，接口Deque是双向队列。接口Deque添加了如下新方法： void addFirst(E e); void addLast(E e); boolean offerFirst(E e); boolean offerLast(E e); E removeFirst(); E removeLast(); E pollFirst(); E pollLast(); E getFirst(); E getLast(); E peekFirst(); E peekLast(); Stack Stack继承自Vector（可增长的对象数组），也是同步的。他通过五个操作对类Vector进行了扩展，允许将向量视为堆栈。他提供了通常的push和pop操作，以及取堆栈顶点的peek方法。测试堆栈是否为空的empty方法、在堆栈中查找项并确定对堆栈顶距离的search方法。 Stack类的部分函数原型如下: public E push(E item); public synchronized E pop(); //返回栈顶的元素，但不将其出栈 public synchronized E peek(); public synchronized int search(Object o); public boolean empty(); ","date":"2016-11-16","objectID":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/:1:17","tags":["面试整理"],"title":"面经之Java篇","uri":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/"},{"categories":null,"content":"异常 异常类继承关系图: Throwable Throwable类是所有错误或异常的超类。只有当对象是此类或其子类之一的实例时，才能通过JVM或者是通过throw语句抛出；另外catch子句中的参数类型也必须是该类型。 Throwable类及其子类有两个构造方法: 不带参数 带有 String 参数，此参数可用于生成详细消息。 Throwable包含了其线程创建时线程执行堆栈的快照。它还包含了给出有关错误更多信息的消息字符串。Java将可抛出(Throwable)的结构分为三种类型： 错误(Error) 运行时异常(RuntimeException) 被检查的异常(Checked Exception) Error Error是Throwable的子类，用于指示合理的应用程序不应该试图捕获的严重问题。大多数这样的错误都是异常条件。和RuntimeException一样， 编译器也不会检查Error。当资源不足、约束失败、或是其它程序无法继续运行的条件发生时，就产生错误，程序本身无法修复这些错误的。 Exception Exception类及其子类是Throwable的一种形式，它指出了合理的应用程序想要捕获的条件。对于可以恢复的条件使用被检查异常（Exception的子类中除了RuntimeException之外的其它子类），对于程序错误使用运行时异常。　ClassNotFoundException 当应用程序试图使用以下方法通过字符串名加载类时： Class 类中的 forName 方法。 ClassLoader 类中的 findSystemClass 方法。 ClassLoader 类中的 loadClass 方法。 但是没有找到具有指定名称的类的定义，抛出该异常。 CloneNotSupportedException 当调用Object类中的clone方法复制对象，但该对象的类无法实现Cloneable接口时，抛出该异常。重写clone方法的应用程序也可能抛出此异常，指示不能或不应复制一个对象。 IOException 当发生某种I/O异常时，抛出此异常。此类是失败或中断的I/O操作生成的异常的通用类。 EOFException: 当输入过程中意外到达文件或流的末尾时，抛出此异常。此异常主要被数据输入流用来表明到达流的末尾。注意：其他许多输入操作返回一个特殊值表示到达流的末尾，而不是抛出异常。 FileNotFoundException: 当试图打开指定路径名表示的文件失败时，抛出此异常。在不存在具有指定路径名的文件时，此异常将由 FileInputStream、FileOutputStream和RandomAccessFile构造方法抛出。如果该文件存在，但是由于某些原因不可访问，比如试图打开一个只读文件进行写入，则此时这些构造方法仍然会抛出该异常。 MalformedURLException: 抛出这一异常指示出现了错误的URL。或者在规范字符串中找不到任何合法协议，或者无法解析字符串。　UnknownHostException: 指示主机IP地址无法确定而抛出的异常。 RuntimeException 是那些可能在Java虚拟机正常运行期间抛出的异常的超类。可能在执行方法期间抛出但未被捕获的RuntimeException的任何子类都无需在throws子句中进行声明。Java编译器不会检查它。当程序中可能出现这类异常时，还是会编译通过。虽然Java编译器不会检查运行时异常，但是我们也可以通过throws进行声明抛出，也可以通过try-catch对它进行捕获处理。 ArithmeticException：当出现异常的运算条件时，抛出此异常。例如，一个整数“除以零”时，抛出此类的一个实例。 ClassCastException：当试图将对象强制转换为不是实例的子类时，抛出该异常。例如：Object x = new Integer(0); IllegalArgumentException：抛出的异常表明向方法传递了一个不合法或不正确的参数。 IllegalStateException：在非法或不适当的时间调用方法时产生的信号。换句话说，即Java环境或Java应用程序没有处于请求操作所要求的适当状态下。 IndexOutOfBoundsException：指示某排序索引（例如对数组、字符串或向量的排序）超出范围时抛出。 应用程序可以为这个类创建子类，以指示类似的异常。 NoSuchElementException：由Enumeration的nextElement方法抛出，表明枚举中没有更多的元素。 NullPointerException：当应用程序试图在需要对象的地方使用null时，抛出该异常。这种情况包括： 调用null对象的实例方法。 访问或修改null对象的字段。 将null作为一个数组，获得其长度。 将null作为一个数组，访问或修改其时间片。 将null作为Throwable值抛出。 应用程序应该抛出该类的实例，指示其他对null对象的非法使用。 SOF（堆栈溢出 StackOverflow） 当应用程序递归太深而发生堆栈溢出时，抛出StackOverflowError错误。 程序中一旦出现死循环或者是大量的递归调用，在不断的压栈过程中，造成栈容量超过默认大小而导致溢出。我在8G的内存下，用eclipse进行递归调用测试，递归11410次后抛SOF异常 栈溢出的原因： 递归调用 大量循环或死循环 全局变量是否过多 数组、List、map数据过大 Android的OOM（Out Of Memory） 当内存占有量超过了虚拟机的分配的最大值时就会产生内存溢出（VM里面分配不出更多的page） 一般出现情况： 加载的图片太多或图片过大时 分配特大的数组 内存相应资源过多没有来不及释放。 解决方法： 在内存引用上做处理 对图片进行边界压缩, 配合软引用使用 显示的调用GC来回收内存例如if(bitmapObject.isRecycled()==false) //如果没有回收 bitmapObject.recycle(); 优化Dalvik虚拟机的堆内存分配 增强堆内存的处理效率VMRuntime.getRuntime().setTargetHeapUtilization(0.75); 设置堆内存的大小: VMRuntime.getRuntime().setMinimumHeapSize(6 * 1024 * 1024); 设置最小heap内存为6MB大小 用LruCache和AsyncTask解决 ","date":"2016-11-16","objectID":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/:1:18","tags":["面试整理"],"title":"面经之Java篇","uri":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/"},{"categories":null,"content":"Math类 double floor(double a); // 向下取整 double random(); // 产生随机数取值范围[0,1) double ceil(); // 向上取整 long round(double a); // 四舍五入 ","date":"2016-11-16","objectID":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/:1:19","tags":["面试整理"],"title":"面经之Java篇","uri":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/"},{"categories":null,"content":"String equals与==的区别 ==：对于基本类型，比较的是它们的值。对于复合类型（直接在堆中分配空间），比较的是它们在内存中的地址。 equals：该方法属于Object，而所有类都继承于Object这个基类，因此每个类都有这个方法。Object类中equals的默认实现是return (this == obj);，即默认是比较对象的内存地址。但在库中的一些类会覆盖重写equals这个方法，如：String、Integer、Date这些类中equals有自身的实现，而不再是比较类在堆内存中的地址。String中的equals，首先判断==，如果地址相同，那一定是返回true；如果地址不相同，再比较字符串字面值是否相等。 Switch能否用string做参数? 在Java7之前，switch只支持byte、short、char、int及其对应的封装类，以及Enum类型，在Java 7中，String类型被加上。 String、StringBuffer与StringBuilder的区别 字符串是否可变 String: 使用字符数组保存字符串：private final char value[];关键字final决定了String对象不可变。 StringBuilder和StringBuffer继承自AbStractStringBuilder类，AbstractStringBuilder类也是使用字符数组保存字符串：char[] value;没有final，可知这两个对象都是可变的。 线程安全 String对象不可变，也就可以理解为常量，显然线程安全。 StringBuffer对方法加了同步锁，因此是线程安全的。 StringBuilder没有加锁，是非线程安全的。 String 常用的函数 split split函数原型为：String[] split(String regex)。参数regex不是一个简单的字符串，而是一个正则表达式。因此，对于正则表达式中的关键字你需要使用转意符\\，例如.和|都是转义字符,必须得加\"\\\\\"： 如果用.作为分隔的话,必须写为String.split(\"\\\\.\")，而不能直接这样String.split(\".\"); 如果用|作为分隔的话,必须写为String.split(\"\\\\|\")，而不能直接这样String.split(\"|\"); 如果在一个字符串中有多个分隔符,可以用|作为连字符，比如待分割的字符串为String s=\"my; name,is HuaChao\"，如果希望把单词提取出来（以标点符号和空格为分割字符），可以写为：s.split(\",| |;\");注意， 两个|之间有空格，\",| |;\"表示，以,或空格以及;分割字符串。 replace、replaceAll、replaceFirst replace:原型为String replace(char oldChar, char newChar) ，即将所有的oldChar字符替换为newChar字符 replace:原型为String replace(CharSequence target, CharSequence replacement) ，即将所有的target字符串替换为replacement字符串 replaceAll：原型为String replaceAll(String regex, String replacement)，参数regex从名称可以看出，它是一个正则表达式。replacement为替换的新字符串，即将原字符串中，所有满足正则表达式regex的部分替换为replacement replaceFirst：原型为String replaceFirst(String regex, String replacement) ，跟replaceAll很像，只不过replaceFirst是替换第一个满足正则表达式regex的部分。 如下: public static void main(String[] args) throws Exception { String s=\"my.name.is.HuaChao\"; System.out.println(s.replace('.', '*')); System.out.println(s.replace(\".\", \"*\")); System.out.println(s.replaceAll(\".\", \"*\")); System.out.println(s.replaceFirst(\".\", \"*\")); } // 结果 my*name*is*HuaChao my*name*is*HuaChao ****************** *y.name.is.HuaChao 运行结果中，很好理解，第1个replace里面的参数是字符，不是正则表达式，replace会把所有的.字符替换为*；同样，第二个replace里面的参数是字符串，不是正则表达式；而replaceAll中，第一个参数是正则表达式，第二个参数是字符串，而正则表达式中的.是表示任意字符，因此，会把所有的字符替换为*；最后replaceFirst，只替换第一个字符。 正则表达式 如果我们需要从字符串中匹配出满足我们自定义的正则表达式的部分，就可以通过使用Pattern这个类。我们先看一个实际应用，假设我们要取出一个字符串中所有的字母，并显式出来： public static void main(String[] args) { String dataStr = \"---\u003e我是干扰字符\u003c---M12v,L23f,d34\"; Pattern pattern = Pattern.compile(\"[a-zA-Z]\"); Matcher matcher = pattern.matcher(dataStr); // 遍历匹配正则表达式的字符串 while (matcher.find()) { // s为匹配的字符串 String s = matcher.group(); System.out.println(s); } } // 结果 // M v L f d ","date":"2016-11-16","objectID":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/:1:20","tags":["面试整理"],"title":"面经之Java篇","uri":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/"},{"categories":null,"content":"List ArrayList ArrayList类的定义为: public class ArrayList\u003cE\u003e extends AbstractList\u003cE\u003e implements List\u003cE\u003e,RandomAccess,Cloneable,Serializable 特性: 可变大小的数组 非线程安全 当更多的元素加入到ArrayList时，其大小会动态的增长。每次增长的空间是其size的50%。初始容量是10. 允许null元素 LinkedList LinkedList类定义: public class LinkedList\u003cE\u003e extends AbstractSequentialList\u003cE\u003e implements List\u003cE\u003e, Deque\u003cE\u003e, Cloneable, Serializable LinkedList有如下特性： 是一个双链表 非线程安全 在添加和删除元素元素时具有比ArrayList更好的性能 LinkedList还实现了Queue接口（非直接实现，是通过实现Queue的子接口Deque间接实现Queue），该接口比List提供了更多方法。包括从尾部添加元素：offer(E)、返回第一个元素但不出队:peek()、返回第一个元素并出队：poll()等。 允许null元素 由于LinkedList不同步,可以通过如下方式转化为同步的List List list= Collections.synchronizedList(new LinkedList()); Vector Vector类定义: public class Vector\u003cE\u003e extends AbstractList\u003cE\u003e implements List\u003cE\u003e, RandomAccess, Cloneable, Serializable Vector类有如下特性： Vector和ArrayList类似，但属于强同步类。 比ArrayList多了线程安全。 默认每次动态增加空间是当前大小的2倍；如果在构造函数Vector(int initialCapacity, int capacityIncrement)中指定了capacityIncrement，每次动态增加的大小为capacityIncrement 初始容量是10. 允许null元素 ","date":"2016-11-16","objectID":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/:1:21","tags":["面试整理"],"title":"面经之Java篇","uri":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/"},{"categories":null,"content":"Map 首先各个子类的继承关系 类的定义: //HashMap public class HashMap\u003cK,V\u003e extends AbstractMap\u003cK,V\u003e implements Map\u003cK,V\u003e, Cloneable, Serializable{} //Hashtable public class Hashtable\u003cK,V\u003e extends Dictionary\u003cK,V\u003e implements Map\u003cK,V\u003e, Cloneable, java.io.Serializable {} //ConcurrentHashMap public class ConcurrentHashMap\u003cK, V\u003e extends AbstractMap\u003cK, V\u003e implements ConcurrentMap\u003cK, V\u003e, Serializable {} //TreeMap public class TreeMap\u003cK,V\u003e extends AbstractMap\u003cK,V\u003e implements NavigableMap\u003cK,V\u003e, Cloneable, java.io.Serializable{} //LinkedHashMap public class LinkedHashMap\u003cK,V\u003e extends HashMap\u003cK,V\u003e implements Map\u003cK,V\u003e{} HashMap内部实现 HashMap本质是数组加链表。根据key取得hash值，然后计算出数组下标，如果多个key对应到同一个下标，就用链表串起来。新插入的在前面。不保证映射顺序，特别是它不保证该顺序恒久不变。里面存放的是Map.Entry类，该类本质是个键值对。 HashMap数据结构：根据key的hashCode来计算hash值，只要hashCode相同，计算出来的hash值就一样。出现hash冲突，就采用链表的方式，将相同hash值的对象用链表连接。 HashMap存取：put新元素时，首先根据key的hashCode重新计算hash值（二次hash），根据这个新的hash值得到这个元素在数组的位置（下标），如果数组已经存放其他元素，那么该位置元素以链表形式存放，新加入的放链头，最先加入的在链尾。根据Key的hashCode二次hash的算法函数hash（int h），此方法加入了高位计算，防止低位不变而高位变化时造成的hash冲突。函数的具体实现如下(\u003e\u003e\u003e表示右移1位并忽略符号位，空位以0补齐。而\u003e\u003e表示右移不忽略符号位，即相当于除以2)： static int hash(int h){ h ^= (h\u003e\u003e\u003e20)^(h\u003e\u003e\u003e12); return h^(h\u003e\u003e\u003e7)^(h\u003e\u003e\u003e4); } 此时得到了二次hash，二次hash的主要目的就是将高位引入计算，使得计算出来的位置值与高位也有关。将二次hash值对数组长度取模运算这样一来元素的分布就比较均匀。但是，模运算的消耗比较大。在HashMap中这样做：调用indexFor(int h,int length)方法计算该对象应该保存在table数组的那个索引处： static int indexFor(int h,int length){ return h \u0026 (length-1); } 这个方法非常巧妙，它通过h\u0026(table.length-1)来得到该对象的保存位，而HashMap底层数组的长度总是2的n次方（即只有一位上是1，其他位上是0），这是HashMap在速度上的优化。 HashMap扩容（resize、rehash）：由上面可知，每次数组扩容为原来的两倍。扩容会带来一个性能上的问题，就是每次扩容需要重新计算每个元素的位置。那么HashMap什么时候进行扩容呢？这个跟loadFactor（加载因子）有关，默认情况下loadFactor为0.75.即当HashMap元素超过length*0.75时，需要扩大一倍，然后重新计算元素在数组的位置，这是一个非常消耗性能的操作，所以，如果已经预知HashMap中元素个数那么预设元素个数能够有效提高HashMap性能。 Fail-Fast(快速失败)机制： HashMap不是线程安全的，因此在使用迭代器过程中，其他线程修改了Map，那么将抛出ConcurrentModificationException异常，这就是fail-fast策略。实现原理为，通过modCount域，modCount顾名思义就是修改次数，对HashMap内容的修改都将增加这个值，在迭代器初始化过程会将这个值赋给迭代器的expectedModCount，迭代过程中，判断modCount跟expectedModCount是否相等，如果不相等就表示已经有其他的线程修改了Map。 ConcurrentHashMap 在HashMap的基础上,ConcurrentHashMap将数据分为多个segment，默认16个，然后每次操作对一个segment加锁，避免多线程锁的几率，提高并发效率。 HashTable和HashMap HashMap父类为AbstractMap，方法不同步，K，V可为null，添加新的kv，若k相同，则将新的v覆盖。 HashTable父类为Dictionary，方法同步，k，v不可为null，添加新的kv，若k相同，则将新的v覆盖。 TreeMap、HashMap、LinkedHashMap的区别 TreeMap 实现SortMap接口，能够把它保存的记录根据键排序，默认是按键值升序排序，也可以指定排序的比较器（通过构造器传入Comparator对象），当用Iterator遍历TreeMap时，得到的记录是排过序的。 LinkedhashMap，是HashMap子类，保存了记录的插入顺序，在用iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，如果需要输出的顺序和输入的相同，那么LinkedHashMap可以实现。LRU算法里面使用到LinkedHashMap,之所以用这个类而不用LinkedList，主要是LinkedHashMap取值速度快，免去了LinkedList遍历搜索过程。 ","date":"2016-11-16","objectID":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/:1:22","tags":["面试整理"],"title":"面经之Java篇","uri":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/"},{"categories":null,"content":"Collections和Arrays 由于collections主要针对Collection对象, 先看看Collection子类继承结构 Collections Java.util.Collections是一个包装类（工具类、帮助类），主要是针对集合类操作。它包含各种有关集合操作的静态多态方法。此类不能实例化，就像一个工具类，有如下功能： 二分搜索算法进行查找 为Collection添加不定数量参数作为子元素 将一个List所有元素复制到另一个 判断两个元素是否有相同的元素: 获取Collection最大、最小元素 用于对集合中的元素进行排序 将线程不安全的Map、Set转为线程安全的对象 返回单例 部分函数原型 static boolean addAll(Collection\u003c? super T\u003e c, T... elements); static int binarySearch(List\u003c? extends T\u003e list, T key, Comparator\u003c? super T\u003e c); static void copy(List\u003c? super T\u003e dest, List\u003c? extends T\u003e src); //如果没有相同的元素返回true static boolean disjoint(Collection\u003c?\u003e c1, Collection\u003c?\u003e c2); //最大最小值 static T max(Collection\u003c? extends T\u003e coll, Comparator\u003c? super T\u003e comp); static T min(Collection\u003c? extends T\u003e coll, Comparator\u003c? super T\u003e comp); //逆序 static Comparator\u003cT\u003e reverseOrder(Comparator\u003cT\u003e cmp) //返回只包含指定对象的单例Set static Set\u003cT\u003e singleton(T o); //返回只包含指定对象的单例列表 static List\u003cT\u003e singletonList(T o); //返回只包含指定对象的单例Map static Map\u003cK,V\u003e singletonMap(K key, V value); //排序 static void sort(List\u003cT\u003e list, Comparator\u003c? super T\u003e c); //交换指定位置的两个元素 static void swap(List\u003c?\u003e list, int i, int j) //将线程不安全的Collection转为线程安全的Collection static Collection\u003cT\u003e synchronizedCollection(Collection\u003cT\u003e c); static List\u003cT\u003e synchronizedList(List\u003cT\u003e list); static Map\u003cK,V\u003e synchronizedMap(Map\u003cK,V\u003e m); static Set\u003cT\u003e synchronizedSet(Set\u003cT\u003e s); Arrays 这些方法都是静态方法。主要是针对数组操作。Arrays跟Collections很像，包含如下功能： 二分搜索算法进行查找 将数组转List对象 复制数组指定范围的元素为一个新的数组 给数组指定范围的每个元素赋一个值，排序等等 函数部分原型: //针对基本类型的查找 //如果查找的数组类型是int[],则函数如下 //其他的基本类型对应的二分搜索函数原型为把int替换指定的类型就好 static int binarySearch(int[] a, int key); //针对基本类型，在指定范围进行二分搜索 //其他基本类型类似 static int binarySearch(int[] a, int fromIndex, int toIndex, int key); //针对类对象数组的二分搜索 static int binarySearch(T[] a, T key, Comparator\u003c? super T\u003e c) //针对一个数组，复制其元素到一个新的数组， //并将新的数组返回. //其他基本类型相似，将float替换掉即可 static float[] copyOf(float[] original, int newLength); //复制数组指定范围的元素到一个新的数组， //并将新的数组返回 //其他基本类型类似，将byte替换即可 static byte[] copyOfRange(byte[] original, int from, int to); //复制指定范围的类对象数组 static T[] copyOfRange(T[] original, int from, int to); //判断两个基本类型数组里面的元素是否相等 //其他基本类型只需将char替换 static boolean equals(char[] a, char[] a2); //判断两个类对象数组里面的元素是否相同 static boolean equals(Object[] a, Object[] a2); //为基本类型数组里面的每一个元素赋相同的值 //其他基本类型将boolean替换 static void fill(boolean[] a, boolean val); //类数组一样 static void fill(Object[] a, Object val) //返回hash码,基本类型替换long static int hashCode(long[] a); static int hashCode(Object[] a); //排序,基本类型替换byte static void sort(byte[] a); static void sort(byte[] a, int fromIndex, int toIndex); //模板类型排序 static void sort(T[] a, Comparator\u003c? super T\u003e c); static void sort(T[] a, int fromIndex, int toIndex, Comparator\u003c? super T\u003e c); //toString，基本类型替换long static String toString(long[] a); static String toString(Object[] a); ","date":"2016-11-16","objectID":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/:1:23","tags":["面试整理"],"title":"面经之Java篇","uri":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/"},{"categories":null,"content":"HashCode hashCode()方法 因为Object类提供了hashCode()方法，因此，每个类对象都拥有hashCode()方法。而Object的 hashCode是一个native方法,我们就不去深究其具体的实现了。 hashCode方法主要作用是为了配合散列的集合一起工作。散列集合包括HashSet、HashMap以及HashTable。 HashSet判断对象是否存在集合中 我们知道，集合中是不允许重复元素存在的，当HashSet需要添加新的对象obj时，如何判断obj是否已经存在于集合中呢？ 调用obj.hashCode()，得到对应的hashcode值。 如果集合中没有存储这个hashcode对应的对象，则直接添加。 如果集合中已经存储了这个hashcode对应的对象，则调用equals判断是否对象相同。 从上面过程可知，如果你重写equals方法，必须重写hashCode函数。因为： 如果只重写equals，根据你的规则将两个对象equals返回true，但是hashCode默认却不同，集合还是会添加新元素。 HashSet存取 HashSet是基于HashMap来实现的。HashSet相当于只利用HashMap的Key，而value使用一个 static final的Object对象标识。一次HashSet的存取相当于HashMap的一次存取，只不过HashSet只看重Key部分，不需要Value部分。因此，我们只需看接下来小节中的HashMap的put和get方法。 HashMap的put和get方法 我们知道，HashMap里面的结构是数组+链表。链表里面存储的元素就是键值对HashMap.Entry\u003cK,V\u003e对象。在存放Key-Value时，过程如下： 首先根据key的hashCode找到对应数组的位置 然后遍历该位置的链表，查找key是否已经存在 如果key已经存在，则直接更新value,并将旧的value作为函数返回 如果key不存在，则通过头插法，将新的键值对放入当前链表的第一个位置 注意，null key总是放入数组的第0个位置，因为null的哈希码为0 put方法已经讲解完，get方法相对就比较简单了: 首先根据key的hashCode找到对应数组的位置 然后遍历该位置的链表，查找key是否已经存在 ","date":"2016-11-16","objectID":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/:1:24","tags":["面试整理"],"title":"面经之Java篇","uri":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/"},{"categories":null,"content":"return和finally执行顺序 结论 不管有木有出现异常，finally块中代码都会执行； 当try和catch中有return时，finally仍然会执行； 如果语句上的执行顺序是先return后finally，会先执行return后面的语句，这个语句的结果是最终的返回值result。result会被保存下来，再执行finally，待finally执行完成后，再结束函数，将result的值返回。这种情形的finally对变量的值修改不会影响最终的函数返回。 finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。 ","date":"2016-11-16","objectID":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/:1:25","tags":["面试整理"],"title":"面经之Java篇","uri":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/"},{"categories":null,"content":"Override与Overload区别 Override(重写、覆盖) Override是子类对父类的允许访问的方法的实现过程进行重新编写，Override一个函数需要注意以下几点： 返回值、函数名、形参都不能改变。即外壳不变，重写内在实现。 子类方法不能缩小父类方法的访问权限（反过来是可以的） final的方法不能被重写 声明为static的方法不能被重写，但是能够被再次声明 子类和父类在同一个包中，子类可以重写父类所有方法，除了声明为private和final的方法。 子类和父类不在同一个包中，子类只能够重写父类的声明为public和protected的非final方法。 重写的方法能够抛出任何非强制异常，无论被重写的方法是否抛出异常。 重写的方法不能抛出新的强制性异常，或者比被重写方法声明的更广泛的强制性异常，反之则可以。 构造方法不能被重写 如果不能继承一个方法，则不能重写这个方法( 父类的private方法)。 解释一下强制性异常和非强制性异常： 除了RuntimeException外，都是强制性异常 所谓强制性异常就是在编写程序的过程中必需在抛出异常的部分try catch 或者向上throws异常 所谓非强制性异常就和上面相反了。不过你当然也可以try catch或者thows，只不过这不是强制性的。 Overload(重载) 重载是在同一个类里面，方法名字相同，而参数不同，返回类型可以相同也可以不同的多个方法。每个重载的方法都必须有一个独一无二的参数类型列表。 重载规则如下： 被重载的方法必须改变参数列表； 被重载的方法可以改变返回类型； 被重载的方法可以改变访问修饰符； 被重载的方法可以声明新的或更广的检查异常； 方法能够在同一个类中或者在一个子类中被重载。 ","date":"2016-11-16","objectID":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/:1:26","tags":["面试整理"],"title":"面经之Java篇","uri":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/"},{"categories":null,"content":"Java 虚拟机 ","date":"2016-11-16","objectID":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/:2:0","tags":["面试整理"],"title":"面经之Java篇","uri":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/"},{"categories":null,"content":"CAS 所谓CAS(Compare And Swap) 即比较并交换 在Intel处理器中，比较并交换通过指令的 cmpxchg 系列实现。CAS有三个操作数： 内存位置（V） 预期原值（A） 新值(B) 如果内存位置V的值与预期A原值相匹配，那么处理器会自动将该位置值更新为新值B。否则，处理器不做任何操作。 无论哪种情况，它都会在 CAS 指令之前返回该位置的值。（在CAS的一些特殊情况下将仅返回CAS是否成功，而不提取当前值。）CAS有效地说明了“我认为位置 V 应该包含值 A；如果包含该值，则将 B 放到这个位置；否则，不要更改该位置，只告诉我这个位置现在的值即可。 CAS应用 比较典型的应用就是AtomicInteger,可以看到，对i++和i--，都是通过CAS，并且通过一个死循环，compareAndSet函数内部就是通过jni操作CAS指令。直到CAS操作成功跳出循环。 private volatile int value; /** * Gets the current value. * * @return the current value */ public final int get() { return value; } /** * Atomically increments by one the current value. * * @return the previous value */ public final int getAndIncrement() { for (;;) { int current = get(); int next = current + 1; if (compareAndSet(current, next)) return current; } } /** * Atomically decrements by one the current value. * * @return the previous value */ public final int getAndDecrement() { for (;;) { int current = get(); int next = current - 1; if (compareAndSet(current, next)) return current; } } ","date":"2016-11-16","objectID":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/:2:1","tags":["面试整理"],"title":"面经之Java篇","uri":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/"},{"categories":null,"content":"GC收集器 Serial收集器 ParNew收集器 Parallel Scavenge收集器 Serial Old收集器 Parallel Old收集器 CMS收集器 G1收集器 Serial收集器 从名字可以看出，这个收集器是一个单线程的收集器。但是，它的“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是，在它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。 \"Stop The World\"是在用户不可见的情况下，把用户正常工作的线程全部停掉，这对很多应用是难以接受的，试想一下，要是你的计算机每运行1小时就暂停响应5分钟，你会是什么样的心情！ 运行示意图: 对于\"Stop The World\"给用户带来的不良体验，虚拟机设计者表示完全理解，但也表示非常委屈：“你妈妈在给你打扫房间时候，肯定也会让你老老实实地在椅子上或房间外呆着，如果她一边打扫，你一边乱扔纸屑，这房间还能打扫完？” 从JDK1.3开始，HotSpot虚拟机开发团队为消除或减少工作线程因内存回收而导致停顿的努力一直进行着。从Serial收集器到Parallel收集器，再到Concurrent Mark Sweep（CMS）乃至GC收集器的最前沿成功Garbage First（G1）收集器，用户线程停顿时间不短缩短，但是仍然无法完全消除！ 应用场景 虽然Serial收集器看起来“老而无用、食之无味弃之可惜”，但实际上到目前为止，它依然是虚拟机运行在Client模式下的默认新生代收集器。它有着优于其他收集器的地方：简单高效（与其他收集器的单线程比）。 对于限定单个CPU的环境来说，Serial收集器由于没有线程交互的开销，专心做垃圾收集自然可以获得更高的单线程收集效率。 在用户的桌面应用场景中，分配给虚拟机管理的内存一般来说不会很大，收集几十兆甚至一两百兆新生代（仅仅是新生代使用的内存，桌面应用基本上不会再大了），停顿时间完全可以控制在几十毫秒最多一百毫秒以内，只要不是频繁发生，这点停顿还是可以接受的，所以Serial收集器对应运行Client模式下的虚拟机来说是一个很好的选择。 ParNew 收集器 运行过程: ParNew收集器其实就是Serial收集器的多线程版本，除了使用多条线程进行垃圾收集之外，其余行为包括Serial收集器可用的所有控制参数（例如：-XX:SruvivorRatio、-XX:PretenureSizeThreshold、-XX:HandlePromotionFailure等）、收集算法、Stop The World、对象分配规则、回收策略等都与Serial收集器完全一样，在现实上，这两种收集器也共用了相当多代码。 ParNew收集器工作示意图: 应用场景 ParNew收集器除了多线程收集之外，其他与Serial收集器相比并没有太多创新之处，但它却是许多运行在Server模式下的虚拟机中首选的新生代收集器。其中一个与性能无关但很重要的原因是，除了Serial收集器外，目前只有它能与CMS收集器配合工作。 ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果。甚至由于存在线程交互的开销，该收集器在通过超线程技术实现两个CPU环境中都不能百分百地保证可以超越Serial收集器。当然，随着CPU数量增加，它对于GC时，系统资源的有效利用还是很有好处。它默认开启的收集线程数与CPU数量相同，在CPU非常多（例如32个，现在CPU动辄就4核加超线程，服务器超过32个逻辑CPU的情况越来越多了）环境下，可以使用-XX:ParalleGCThreads参数来限制垃圾收集的线程数。 Parallel Scavenge收集器 Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器….看上去和ParNew都一样，那它有啥特别的地方呢？ Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能第缩短垃圾收集时用户线程停顿时间，而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量。所谓的吞吐量就是： CPU用于运行用户代码的时间与CPU总消耗时间的比值，即：吞吐量=运行用户代码时间/(运行用户代码时间+垃圾收集时间) 虚拟机总共运行100分钟，其中垃圾收集消耗掉1分钟，那吞吐量就是99%。 Serial Old收集器 Serial Old是Serial收集器的老年代版本，它同样是一个单线程收集器，使用“标记-整理”算法，这个收集器的主要意义也是在于给Client模式下的虚拟机使用。如果在Server模式下，它主要还有两大用途： 在JDK1.5以及之前版本中与Parallel Scavenge收集器搭配使用 作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用 运行示意图和Serial收集器类似 Parallel Old收集器 Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。这个收集器在JDK1.6中才开始提供。 Parallel Old收集器运行示意图如下： CMS收集器 CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目的的收集器。目前很大一部分的Java应用集中在互联网站或者B/S系统服务器上，这类应用尤其重视服务的响应速度，希望系统停顿时间最短，以给用户最好的体验。CMS收集器就非常符合这类应用的需求。 从名字（包含“Mark Sweep”）上就可以看出，CMS收集器是基于“标记-清除”算法实现的，它的运作过程相对前面几种收集器来说更复杂一些，整个过程分为4个步骤： 初始标记 并发标记 重新标记 并发清除 其中，初始标记、重新标记着两个步骤仍然需要“Stop The World”。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快。并发标记阶段就是进行GC Roots Tracing的过程。而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间会比初始标记稍长一些，但远比并发标记时间短。 由于整个过程中耗时最长的并发标记和并发清除过程收集器线程都可以与用户线程一起工作，所有总体上来说，CMS收集器的内存回收过程是与用户线程一起并发执行的。CMS运作步骤如下： CMS是一款优秀的收集器，它的主要优点从名字上体现出来：并发收集、低停顿。但是CMS还远达不到完美程度，它有以下3个明显的缺点： CMS收集器对CPU资源非常敏感。在并发阶段，它虽然不会导致用户线程停顿，但是会因为占用一部分线程（或者说CPU资源）而导致应用程序变慢，总吞吐量会降低。 CMS收集器无法处理浮动垃圾，可能出现Concurrent Mode Failure失败而导致另一次Full GC产生。由于CMS并发清理阶段用户线程还在运行着，伴随程序运行自然就还会有新的垃圾不断产生，这一部分垃圾出现在标记过程之后，CMS无法再当次收集中处理掉它们，只好留待下一次GC时再清理掉。这部分垃圾就称为“浮动垃圾”。因此，CMS不能像其他收集器那样等到老年代几乎完全被填满再进行收集，CMS需要预留一部分空间。 由于CMS基于“标记-清除”算法，意味着收集结束时会有大量空间碎片产生。 G1收集器 G1（Garbage First）收集器是当今收集器技术发展的最前沿成果之一。G1是面向服务端应用的垃圾收集器，与其他GC收集器相比，G1具备如下特点： 并行与并发：充分利用多CPU、多核环境下的硬件优势，使用多个CPU（CPU或CPU核心）来缩短Stop-The-World停顿时间。部分其他收集器需要停顿Java线程执行的GC动作，G1仍然能通过并发方式让Java程序继续执行。 分代收集：与其他收集器一样，分代概念在G1中依然得以保存。 空间整合：与CMS的“标记-清理”算法不同，G1从整体上看是基于“标记-整理”算法实现的收集器，从局部上看是基于“复制”算法实现的，这两种算法意味着G1运作期间不会产生内存空间碎片。 可预测的停顿：这是G1相对于CMS的另一大优势，降低停顿时间是G1和CMS共同关注点，但G1除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得从超出N毫秒，这几乎已经是实时Java的垃圾收集器的特征了。 G1运作大致可划分为以下几个步骤： 初始标记 并发标记 最终标记 筛选回收 运行示意图如下： ","date":"2016-11-16","objectID":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/:2:2","tags":["面试整理"],"title":"面经之Java篇","uri":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/"},{"categories":null,"content":"内存模型和分区 逻辑内存模型 内存分区 程序计数器: 较小的内存空间。线程私有。可以看成是当前线程所执行的字节码的行号指示器。通过改变这个计数器的值来选取下一条需要执行的字节码指令。分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖计数器。此内存区域是唯一一个在JVM规范中没有规定任何OutofMemoryError情况的区域。 Java虚拟机栈: 线程私有，生命周期与线程相同。描述的是Java方法执行的内存模型：每个方法执行时都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用到执行完成，就对应一个栈帧在虚拟机栈中的入栈和到出栈的过程。会抛出StackOverflowError和OutOfMemoryError. 本地方法栈: 功能与虚拟机栈类似。区别在于本地方法栈为native方法服务。 Java堆: JVM所管理的内存中最大的一块。所有线程所共享。可分为：新生代和老年代。新生代可再细分为：Eden空间、From Survivor空间、To Survivor空间。有OutOfMemoryError异常。 方法区: 跟Java堆一样，是各个线程共享区域。存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。运行时常量池是方法区一部分。 直接内存: 不属于虚拟机运行时数据区的一部分。NIO引入了一种基于通道与缓冲区的IO方式。他可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。避免Java堆和Native堆之间来回复制数据，在某种场景中显著提高性能。由于不在堆中分配，因此不受到堆大小限制。但既然是内存总有会被用完时候，因此会抛出OutOfMemoryError。 ","date":"2016-11-16","objectID":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/:2:3","tags":["面试整理"],"title":"面经之Java篇","uri":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/"},{"categories":null,"content":"新生代老年代 新生代于老年代占空间比例 堆被划分为新生代和老年代。默认比例为1:2（可以通过–XX:NewRatio 设定）。新生代又分为Eden、From Survivor、To Survivor。这样划分的目的是为了使 ˚能够更好的管理堆内存中的对象，包括内存的分配以及回收。 新生代分为的三个部分, 默认比例为Eden:from:to=8:1:1（可以通过参数–XX:SurvivorRatio 来设定，–XX:SurvivorRatio =8表示Eden与一个Survivor空间比例为8:1） 存活对象的拷贝 一般新建的对象会分配到Eden区。这些对象经过第一次Minor GC后，如果仍然存活，将会被移到Survivor区。在Survivor每熬过一轮Minor GC年龄就增加1。 当年龄达到一定程度时(年龄阈值，默认为15，可以通过-XX:MaxTenuringThreshold来设置)，就会被移动到老年代。 from和to之间会经常互换角色，from变成to，to变成from。每次GC时，把Eden存活的对象和From Survivor中存活且没超过年龄阈值的对象复制到To Survivor中，From Survivor清空，变成To Survivor。 Minor GC与Full GC Java中的堆也是GC收集垃圾的主要区域。GC分为两种： Minor GC Full GC Minor GC是发生在新生代中的垃圾收集动作，所采用的是复制算法，因为Minor GC比较频繁，因此一般回收速度较快。Full GC 是发生在老年代的垃圾收集动作，所采用的是标记-清除算法，速度比Minor GC慢10倍以上。 大对象直接进入老年代。比如很长的字符串以及数组。通过设置-XX：PretenureSizeThreshold，令大于这个值得对象直接在老年代分配。这样做是为了避免在Eden和两个Survivor之间发生大量的内存复制。 什么时候发生 Minor GC？什么时候发生Full GC？ 当新生代Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。 老年代空间不足时Full GC ","date":"2016-11-16","objectID":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/:2:4","tags":["面试整理"],"title":"面经之Java篇","uri":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/"},{"categories":null,"content":"判断对象是否存活 判断哪些对象是存活的，哪些对象消亡的，典型的有两种方法： 引用计数算法 可达性分析算法 引用计数 给对象添加一个引用计数器，每当有一个地方引用它时，计数器+1，引用失效计数器-1；任何时候计数器为0的对象就是不可能再被使用。这有个问题是，两个对象相互引用导致两个对象都无法被回收。 可达性分析 通过一系列的GC Roots对象作为起点，从这些节点开始向下搜索。搜索所走过的路称为引用链。当一个对象到GC Roots没有任何引用链相连时，则证明此对象不可用。 可作为GC Root的对象有： 虚拟机栈（栈帧的本地变量表）中引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 本地方法栈中JNI引用对象 即使在可达性分析中不可达的对象，也并非是“非死不可”，这时候他们暂时处于“缓刑”阶段。要真正宣告一个对象死亡，需要经历两个阶段： 如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。 如果这个对象被判断为有必要执行finalize()方法。那么这个对象会被放到一个F-Queue队列中，并在稍后由一个虚拟机自动建立的、优先级低的Finalizer线程去执行它，这里的“执行”是指虚拟机会触发这个方法，但并不承诺等待它运行结束。这是为了防止finalize()方法执行缓慢使得F-Queue队列其他对象永久等待。 因此，对象可以在finalize()方法里把自己赋值给一个变量，以达到“自救”的目的，但是这样的“自救”只能用一次（虚拟机只会调用一次finalize()方法）。 ","date":"2016-11-16","objectID":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/:2:5","tags":["面试整理"],"title":"面经之Java篇","uri":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/"},{"categories":null,"content":"GC的三种收集方法 1.标记-清除 分为“标记”和“清除”两个阶段，首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象，他的标记过程在上面几行中已经提到过。 不足： 标记和清除两个过程效率不高 标记清除后产生大量不连续的内存碎片。 该算法主要用在老年代区域。 2.复制算法 将内存分为两部分，每次使用其中一块，当这块内存用完，就将还存活的对象复制到另一块上面。 不足： 浪费一半内存 通常用在新生代区域中，有个改进的方法是将新生代分为Eden、From Survivor、To Survivor。 3.标记-整理 标记过程和标记清除一样。但后续步骤不是直接对可回收对象进行清理，而是让所有存活对象向一端移动。 主要用在老年代区域。 ","date":"2016-11-16","objectID":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/:2:6","tags":["面试整理"],"title":"面经之Java篇","uri":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/"},{"categories":null,"content":"类加载过程 类加载的5个过程分为: 加载 验证 准备 解析 初始化 1.加载 通过类的全限定名来获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。 2.验证 文件格式验证 元数据验证 字节码验证 符号引用验证。 3.准备 为类变量（static）分配内存并设置类变量的初始值。 注意，实例变量并不在这个阶段分配内存。为类变量设置初始值并不是定义的值。 比如static int value = 123;那么变量value在准备阶段过后初始值为0，而不是123。值123是在\u003cclinit\u003e()方法中赋予。 4.解析 将常量池内的符号引用转为直接的引用. 5.初始化 按照static块和static变量在文件中的出现顺序，合并到\u003cclinit\u003e()方法中。实例变量由\u003cinit\u003e()函数赋值。 ","date":"2016-11-16","objectID":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/:2:7","tags":["面试整理"],"title":"面经之Java篇","uri":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/"},{"categories":null,"content":"静态分派 动态分派 静态分派 **概念:**静态分派与重载有关，虚拟机在重载时是通过参数的静态类型，而不是运行时的实际类型作为判定依据的；静态类型在编译期是可知的； 看如下例子: public class Test { static abstract class Human { } static class Man extends Human { } static class Woman extends Human { } public void sayHello(Human guy) { System.out.println(\"hello,guy!\"); } public void sayHello(Man guy) { System.out.println(\"hello gentleman!\"); } public void sayHello(Woman guy) { System.out.println(\"hello lady!\"); } public static void main(String[] args) { Human man = new Man(); Human woman = new Woman(); Test test = new Test(); test.sayHello(man); test.sayHello(woman); } } 输出结果为 : hello,guy! hello,guy! 稍微有Java开发经验的人都能得到正确的答案。但是为什么会选择执行参数类型为Human的重载呢？在解决这个问题之前，我们先按如下代码定义两个重要概念： Human man = new Man(); 上面代码中，Human称为变量的静态类型；后面的Man则称为变量的实际类型。 静态类型和实际类型在程序中都可以发生一些变化，区别是： 静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是编译期可知的 实际类型变化的结果在运行期才能确定，编译器在编译程序时并不知道一个对象的实际类型是什么。例如下面代码： //实际类型变化 Human man=new Man(); man=new Woman(); //静态类型变化 test.sayHello((Man)man); test.sayHello((Woman) man) 使用哪个重载版本，完全取决于传入参数的数量和数据类型。代码中刻意定义两个静态类型相同，但实际类型不同的变量，但虚拟机在重载时，是通过参数的静态类型而不是实际类型作为判断依据。并且静态类型在编译期是可知的，因此，在编译阶段，javac编译器会根据参数的静态类型决定使用哪个重载版本，所以选择了sayHello(Human)作为调用目标，并把这个方法的符号引用写到man()方法里面两条invokevirtual指令参数中。 所有依赖静态类型来定位方法执行版本的分派动作称为静态分派。静态分派的典型应用就是方法重载。 重载方法的匹配优先级 基本类型中，以char为例，按照如下优先级： char\u003eint\u003elong\u003efloat\u003edouble\u003eCharacter\u003eSerializable\u003eObject\u003e...其中…为变长参数， 注意：char到byte或short之间的转换是不安全的 引用类型中，需要根据继承关系进行匹配，注意只跟其编译时类型即静态类型相关。 动态分派 动态分派与重写(Override)相关。同样，看一个例子： public class Test { static abstract class Human { protected abstract void sayHello(); } static class Man extends Human { @Override protected void sayHello() { System.out.println(\"man say hello\"); } } static class Woman extends Human { @Override protected void sayHello() { System.out.println(\"woman say hello\"); } } public static void main(String[] args) { Human man = new Man(); Human woman = new Woman(); man.sayHello(); woman.sayHello(); man = new Woman(); man.sayHello(); } } 运行结果: man say hello woman say hello woman say hello 代码很简单，基本都能回答正确。但是现在问题是，虚拟机是如何知道调用哪个方法？ 显然这里不能再根据静态类型决定，因为静态类型同样都是Human的两个变量man和woman在调用sayHello()方法时执行了不同的行为，并且变量man在两次调用中执行了不同的方法。 导致这个现象的原因很明显，是这两个变量的实际类型不同，java虚拟机是如何根据实际类型来分派方法执行版本呢？ 看一下这两句代码： Human man=new Man(); Human woman=new Woman(); 这两个对象是即将要执行sayHello()方法的所有者，称为接受者。 由于invokevirtual指令执行第一步就是在运行期间确定接受者的实际类型，所以两次调用中的invokevirtual指令把常量池中类方法符号引用解析到不同的直接引用上，这个过程就是Java语言中方法重写的本质。这种运行期根据实际类型确定方法执行版本的分派过程称为动态分派。 ","date":"2016-11-16","objectID":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/:2:8","tags":["面试整理"],"title":"面经之Java篇","uri":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/"},{"categories":null,"content":"类与类加载器 类加载器虽然只用于实现类的加载动作，但它在Java程序中起到的作用却远远不限于类加载阶段。对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，每一个类加载器，都拥有一个独立的类名空间。简单说： 比较两个类是否“相等”，只有在这两个类是由同一个类加载器加载的前提下才有意义 否则，即使两个类来源于同一个Class文件，被同一个虚拟机加载，只要他们的类加载器不同，那这两个类就必定不等。 这里指的“相等”，包括代表Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，而包括使用instanceof关键字做对象所属关系判定等情况。 如果没有注意到类加载器的影响，在某些情况下，可能会产生具有迷惑性的结果，看个例子： public class Test { static ClassLoader myLoader = new ClassLoader() { @Override public Class\u003c?\u003e loadClass(String name) throws ClassNotFoundException { if (!name.equals(\"com.szysky.Test\")) return super.loadClass(name); try { String fileName = name.substring(name.lastIndexOf(\".\") + 1) + \".class\"; InputStream is = getClass().getResourceAsStream(fileName); if (is == null) { return super.loadClass(fileName); } byte[] b = new byte[is.available()]; is.read(b); return defineClass(name, b, 0, b.length); } catch (IOException e) { throw new ClassNotFoundException(name); } } }; public static void main(String[] args) throws Exception { Object obj = myLoader.loadClass(\"com.szysky.Test\"); System.out.println(obj); System.out.println(obj instanceof com.szysky.Test); } } 运行结果: class com.szysky.Test false 从第二句发现，这个对象与类com.szysky.Test做所属类型检查时返回了false，这是因为虚拟机中存在了两个Test类，一个是由系统应用程序类加载器加载的，另一个是由我们自定义的类加载器加载，虽然都是来自同一个class文件，但依然是两个独立的类，对象所属类型检查结果自然为false。 自定义类加载器 首先，定义一个类加载器MyClassLoader.java public class MyClassLoader extends ClassLoader { // 类加载器的名称 private String name; // 类存放的路径 private String classpath = \"E:/\"; MyClassLoader(String name) { this.name = name; } MyClassLoader(ClassLoader parent, String name) { super(parent); this.name = name; } @Override public Class\u003c?\u003e findClass(String name) { byte[] data = loadClassData(name); return this.defineClass(name, data, 0, data.length); } public byte[] loadClassData(String name) { try { name = name.replace(\".\", \"//\"); System.out.println(name); FileInputStream is = new FileInputStream(new File(classpath + name + \".class\")); byte[] data = new byte[is.available()]; is.read(data); is.close(); return data; } catch (Exception e) { e.printStackTrace(); } return null; } } 定义待加载的类: public class TestObject { public void print() { System.out.println(\"hello ClassLoader\"); } } 定义测试类 public class Test { public static void main(String[] args) throws InstantiationException, IllegalAccessException, ClassNotFoundException { // 新建一个类加载器 MyClassLoader cl = new MyClassLoader(\"myClassLoader\"); // 加载类，得到Class对象 Class\u003c?\u003e clazz = cl.loadClass(\"com.szysky.TestObject\"); // 得到类的实例 TestObject test= (TestObject) clazz.newInstance(); test.print(); } } 可以正常输出语句. ","date":"2016-11-16","objectID":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/:2:9","tags":["面试整理"],"title":"面经之Java篇","uri":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/"},{"categories":null,"content":"双亲委派模型 从虚拟机的角度来讲，只存在两种不同的类加载器 启动类加载器（Bootstrap ClassLoader）。使用C++语言实现（针对HotSpot虚拟机而言），是虚拟机自身的一部分。 所有其他的类加载器。使用Java语言实现，独立于虚拟机外部，并且全部继承自抽象类java.lang.ClassLoader 从Java程序员角度来看，类加载器还可以划分的更细致一点，绝大部分Java程序都会使用到以下3种系统提供的类加载器： 启动类加载器 扩展类加载器 应用程序类加载器 启动类加载器 这个类加载器将存放在\u003cJAVA_HOME\u003e\\lib目录中的，或者被-Xbootclasspath参数所指定路径中的，并且是虚拟机识别的（仅按文件名识别，如：rt.jar，名字不符合的类库即使放在lib目录中也不会被加载）类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给引导类加载器，那直接使用null代替即可，如java.lang.ClassLoader.getClassLoader()方法所示： @CallerSensitive public ClassLoader getClassLoader() { ClassLoader cl = getClassLoader0(); if (cl == null) return null; SecurityManager sm = System.getSecurityManager(); if (sm != null) { ClassLoader.checkClassLoaderPermission(cl, Reflection.getCallerClass()); } return cl; } 扩展类加载器(Extension ClassLoader) 这个类加载器由sum.misc.Launcher$ExtClassLoader实现，它负责加载\u003cJAVA_HOME\u003e\\lib\\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。 应用程序类加载器（Application ClassLoader 这个类加载器由sum.misc.Launcher$AppClassLoader实现。由于这个类加载器是ClassLoader中的getSystemClassLoader()方法的返回值。所以，一般也称它为系统类加载器。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。 双亲委派模型 如下图所示，这种类加载器之间的层次关系，称为类加载器的双亲委派模型。 双亲委派模型要求： 除了顶层启动类加载器以外，其余的类加载器都应当有自己的父类加载器。 这里类加载器之间的父子关系一般不会以继承的关系来实现，而是都使用组合关系来复用父加载器的代码。它并不是一个强制性的约束模型，而是Java设计者推荐给开发者的一种类加载器实现方式。 双亲委派模型工作过程 如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。 使用双亲委派模型来组织类加载器之间的关系，有一个显而易见的好处就是： Java类随着它的类加载器一起具备了一种带优先级的层次关系 例如：类java.lang.Object，它存放在rt.jar之中，无论哪一个类加载器要加载这个类，最终都是委派给处于模型顶端的启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。相反，如果没有使用双亲委派模型，由各个类加载器自行去加载的话，如果用户自己编写了一个称为java.lang.Object的类，并放在ClassPath中，那系统中将出现多个不同的Object类，Java类型体系中最基础的行为也就无法保证，应用程序也将变得一片混乱。 实现双亲委派模型的代码都集中在java.lang.ClassLoader的loadClass()方法中，逻辑清晰易懂： 先检查是否已经被加载过，若没有加载，则调用父加载器的loadClass()方法 若如加载器为空，则默认使用启动类加载器作为父加载器 如果父加载失败，抛出ClassNotFoundException异常之后，再调用自己的findClass()方法进行加载 以下是ClassLoader的loadClass()方法： @Override protected Class\u003c?\u003e loadClass(String name, boolean resolve) throws ClassNotFoundException { Class\u003c?\u003e c = findLoadedClass(name); if (c == null) { try { if (parent != null) { c = parent.loadClass(name, false); }else{ c=findBootstrapClassOrNull(name); } } catch (ClassNotFoundException e) { //如果父类加载器抛出ClassNotFoundException， //说明父类加载器无法完成加载请求 } if(c==null){ //在父类加载器无法加载的时候 //再调用本身的findClass方法进行类加载 c=findClass(name); } } if(resolve){ resolveClass(c); } return c; } ","date":"2016-11-16","objectID":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/:2:10","tags":["面试整理"],"title":"面经之Java篇","uri":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/"},{"categories":null,"content":"对象创建 内存分布 访问定位 对象在JVM中是如何创建、如何布局以及如何访问的。讨论这个问题需要限定在具体的虚拟机和集中在某一个内存区域上才有意义。我们这个所说的是Sun的HotSpot虚拟机的Java堆内存区域，深入探讨HotSpot虚拟机在Java堆中对象的分配、布局和访问全过程。 对象的创建 在语言层面上，创建对象（例如克隆、反序列化）通常仅仅是一个new关键字而已，而在虚拟机中，对象（文中探讨的对象限于普通对象，不包括数组和Class对象等）的创建又是怎样一个过程呢？ new指令开始: 虚拟机遇到一个new指令时，首先去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，需要先执行相应的类加载过程。参考类加载的五个过程。 为对象分配内存: 在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定（下一节介绍如何完全确定）。为对象分配空间的任务等同于把一块确定大小的内存从Java堆中划分出来 划分空间: 假设Java堆中内存是绝对规整的，所有用到的内存在一边，空闲的内存在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离，这种分配方式成为“指针碰撞”。如果Java堆中的内存并不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，此时：虚拟机就必须维护一个列表，记录上那些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录，这种分配方式称为“空闲列表”。选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此，在使用Serial、ParNew等带Compact过程的收集器时，系统采用的分配算法是指针碰撞，而使用CMS这种基于Mark_sweep算法的收集器时，通常采用空闲列表。 划分的线程安全: 除如何划分可用空间外，还有另外一个需要考虑的问题是对象创建在虚拟机中是非常频繁的操作，即使是仅仅修改一个指针所指向的位置，在并发情况下是线程不安全的，可能出现正在给对象A分配内存，指针还没有来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案： 对分配内存空间的动作进行同步处理——实际上虚拟机采用CAS配上失败重试的方式保证更新操作的原子性； 把内存分配动作按照线程划分在不同的内存空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer ，TLAB）。哪个线程要分配内存，就在哪个线程的TLAB上分配，只有TLAB用完并分配新的TLAB时才需要同步锁。虚拟机是否使用TLAB，可以通过-XX:+/-UseTLAB参数来设定。 内存空间初始化为零值: 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。 这一步操作保证了对象的实例字段在Java代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型对应的零值。 接下来，虚拟机要对对象进行必要的设置，例如：这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中。根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。上面工作都完成后，从虚拟机的角度来看，一个新的对象已经诞生了，但从Java程序来说，对象创建才刚刚开始，所有的字段都还为零，需要进行一些初始化操作。 小结: 对象的创建过程如下: 虚拟机首先需要进行类加载检查 检查通过之后，根据类加载完成后确定的内存大小，为对象分配内存 接着，需要对分配到的内存空间都初始化为零值 然后，虚拟机要对对象设置一些基本信息，如对象是那个类的实例、对象的哈希码、对象的GC分代年龄信息、如何才能找到类的元数据信息等，到这里虚拟机创建对象的工作已经完成 最后，从程序的角度，我们还需要对对象进行初始化操作。 对象的内存布局 在HotSpot虚拟机中，对象在内存中存储的局部可以分为3块区域： 对象头（Header） 实例数据（Instance Data） 对齐填充（Padding） HotSpot虚拟机的对象头包括两部分信息 用于存储对象自身的运行时数据 哈希码（HashCode） GC分代年龄 锁状态标志 线程持有的锁 偏向线程ID 偏向时间戳 这部分数据长度在32位和64位的虚拟机中分别为32bit和64bit，官方称它为“Mark Word”。对象需要存储的运行时数据很多，其实已经超出了32位、64位Bitmap结构能够记录的限度。但是对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成为一个固定的数据结构以便在极小的空间存储尽量多的信息，它会根据对象的状态复用自己的存储空间。 类型指针，即对象指向它的类元数据的指针 对象头的另外一个部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例，并不是所有的虚拟机实现都必须在对象数据上保留类型指针（还有通过句柄的方式）。另外，如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定对象的大小，但是从数组的元数据中却无法确定数组的大小。 实例数据部分 接下来的实例数据部分是对象真正存储的有限信息，也是程序代码中所定义的各种类型字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。这部分的存储顺序会受到虚拟机分配参数（FieldAllocationStyle）和字段在Java源码中定义顺序的影响。 HotSpot虚拟机默认的分配策略为: longs/doubles、ints、shorts/chars、bytes/booleans、oop(Ordinary Object Pointers) 从分配策略中可以看出，相同宽度的字段总是被分配到一起。在满足这个前提的条件下，在父类中定义的变量会出现在子类之前。如果CompactFields参数值为true，那么子类之中较窄的变量也可能会插入到父类变量的空隙之中。 第三部分对齐填充并不是必然存在的， 也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，换句话说，就是对象的大小必须是8字节的整数倍。而对象头部分正好是8字节的倍数，因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。 对象的访问定位 建立对象是为了使用对象，我们的Java程序需要通过栈上的reference数据来操作堆上的具体对象。由于reference类型在Java虚拟机规范中只规定了一个指向对象的引用，并没有定义这个引用应该通过何种方式去定位、访问堆中的对象的具体位置，所以对象访问方式也是取决于虚拟机实现而定的。目前主流的访问方式有使用句柄和直接指针两种。如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。 如果是直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference中存储的直接就是对象地址。 这两种对象访问方式各有优势： 使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）是只会改变句柄中的实例数据指针，而reference本身不需要修改。 使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁。Sun HotSpot虚拟机采用的是第二种方式。 ","date":"2016-11-16","objectID":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/:2:11","tags":["面试整理"],"title":"面经之Java篇","uri":"/posts/%E9%9D%A2%E7%BB%8F%E4%B9%8Bjava%E7%AF%87/"},{"categories":null,"content":" 阅读《Android 编程实战》一书的抄书笔记 –\u003e 对应书籍第18章 ","date":"2016-10-08","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9812-%E8%BF%9C%E7%A8%8B%E8%AE%BE%E5%A4%87%E5%85%B6%E4%BD%99%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/:0:0","tags":["android","笔记"],"title":"《Android-编程实战》12-远程设备其余通信方式","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9812-%E8%BF%9C%E7%A8%8B%E8%AE%BE%E5%A4%87%E5%85%B6%E4%BD%99%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"Android中的连接技术 大多数Android设备都支持多种连接技术. 通常, 例如USB, 蓝牙, Wi-Fi. USB 使用API通过USB进行原始串行通信, 或者使用谷歌专门为访问Android设备硬件配件定义的Android开放配件协议(Android Open Accessory Protocol, AOAP). AOAP是通过配件开发套件(Accessory Development Kit, ADK)支持的. Bluetooth Android设备都支持经典蓝牙配置文件(Classic Bluetooth Protocol), 它适合更耗电的操作, 比如视频流. Android 4.3开始支持蓝牙低功耗以及蓝牙智能(Bluetooth Smart)技术, 它能够和支持GATT配置的设备进行通信(如心脏检测器,计步器以及其他低功率配件) Wi-Fi 比如需要更多数据密集型通信的场景, Android支持三种Wi-Fi操作模式: infrastructure(连接到一个接入点的的标准wifi), 网络共享(android设备充当其他设备wifi的接入点), WiFi-Direct这个模式比较有趣, 在一些新的设备可以和infrastructure模式进行并行工作. 允许应用程序建立对等的wifi网络, 而不需要专门的访问点. ","date":"2016-10-08","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9812-%E8%BF%9C%E7%A8%8B%E8%AE%BE%E5%A4%87%E5%85%B6%E4%BD%99%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/:1:0","tags":["android","笔记"],"title":"《Android-编程实战》12-远程设备其余通信方式","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9812-%E8%BF%9C%E7%A8%8B%E8%AE%BE%E5%A4%87%E5%85%B6%E4%BD%99%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"Android USB Android中USB相关的API位于android.hardware.usb包. 如果需要usb外设的了解可以查看官网文档的usb/accessory相关介绍. 在USB的设计中, 会有一个设备充当主机. 除了其他功能, 主机还可以给所连接的设备供电, 这就是不需要给USB鼠标添加额外的电池, 以及可以使用笔记本上的USB端口给智能手机充电的原因. Android设备也可以作为USB主机为外部设备充电, 这意味着可以把例如读卡器,指纹扫描,以及其他usb外设连接到手机设备上. 了解一下就好了如果需要更多, 参考资料 ","date":"2016-10-08","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9812-%E8%BF%9C%E7%A8%8B%E8%AE%BE%E5%A4%87%E5%85%B6%E4%BD%99%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/:2:0","tags":["android","笔记"],"title":"《Android-编程实战》12-远程设备其余通信方式","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9812-%E8%BF%9C%E7%A8%8B%E8%AE%BE%E5%A4%87%E5%85%B6%E4%BD%99%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"蓝牙低功耗 在Android 4.3开始支持蓝牙智能, 包括心率监视器, 活动跟踪器等蓝牙低功耗BLE设备的支持. 如果需要蓝牙低功耗比较感兴趣, 可以查看博客的android蓝牙系列 ","date":"2016-10-08","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9812-%E8%BF%9C%E7%A8%8B%E8%AE%BE%E5%A4%87%E5%85%B6%E4%BD%99%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/:3:0","tags":["android","笔记"],"title":"《Android-编程实战》12-远程设备其余通信方式","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9812-%E8%BF%9C%E7%A8%8B%E8%AE%BE%E5%A4%87%E5%85%B6%E4%BD%99%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"Android Wi-Fi Wi-Fi是Wi-Fi联盟管理的各种技术的统称. Wi-Fi Direct是运行在802.11n标准之上的额外技术. 使用该技术的设备不需要专门的连接点, 这点和蓝牙很相似, 不过Wi-Fi Direct使用高速的Wi-Fi进行通信. 但是, 即使设备都不再同一个Wi-Fi, 为了建立连接仍然需要发现它们. 发现意味着找到运行服务的设备的ip地址. Android已经内置了网络发现API, 支持标准的Wi-Fi(infrastructure)和Wi-Fi Direct, 可以让设备发现使用DNS-SD协议声明的服务. ","date":"2016-10-08","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9812-%E8%BF%9C%E7%A8%8B%E8%AE%BE%E5%A4%87%E5%85%B6%E4%BD%99%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/:4:0","tags":["android","笔记"],"title":"《Android-编程实战》12-远程设备其余通信方式","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9812-%E8%BF%9C%E7%A8%8B%E8%AE%BE%E5%A4%87%E5%85%B6%E4%BD%99%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"服务发现 Android提供了标准的发现机制, 允许开发者宣布自己的服务以及发现本地网络上的服务. 该实现包括两个标准: mDNS和DNS-SD. mDNS是一个多播协议, 使用UDP组播协议宣布和发现主机. DNS-SD是一个服务发现协议, 用于宣布和发现运行在远程主机(通常限于本地网络)的服务. 可以通过android.net.nsd包以及NsdManager使用这些功能. 以下代码可以来声明一个设备中的服务: /** * 声明设备中标准Wi-Fi的服务 */ private void announceService(){ NsdManager nsdManager = (NsdManager) getSystemService(NSD_SERVICE); NsdServiceInfo nsdServiceInfo = new NsdServiceInfo(); nsdServiceInfo.setPort(8081); nsdServiceInfo.setServiceName(\"wifi服务哦\"); nsdServiceInfo.setServiceType(\"_http._tcp.\"); nsdManager.registerService(nsdServiceInfo, NsdManager.PROTOCOL_DNS_SD, new NsdManager.RegistrationListener() { @Override public void onRegistrationFailed(NsdServiceInfo serviceInfo, int errorCode) { Log.e(TAG, \"onRegistrationFailed: \" ); } @Override public void onUnregistrationFailed(NsdServiceInfo serviceInfo, int errorCode) { Log.e(TAG, \"onUnregistrationFailed: \"); } @Override public void onServiceRegistered(NsdServiceInfo serviceInfo) { Log.e(TAG, \"onServiceRegistered: \" ); } @Override public void onServiceUnregistered(NsdServiceInfo serviceInfo) { Log.e(TAG, \"onServiceUnregistered: \" ); } }); } Note: 如果不给设置服务名, 那么会使用wifi网络中的设备IP地址. mDNS的服务类型必须是一个有效的类型. 再调用了注册方法后, NsdManager开始宣布在本地Wi-Fi上的服务, 当注册状态发生变化后会触发监听回调. 如果要发现一个服务, 使用同样的API实例: /** * 发现一个服务 */ private void discoverService(){ NsdManager nsdManager = (NsdManager) getSystemService(NSD_SERVICE); nsdManager.discoverServices(\"_http._tcp.\", NsdManager.PROTOCOL_DNS_SD, new NsdManager.DiscoveryListener() { @Override public void onStartDiscoveryFailed(String serviceType, int errorCode) { Log.d(TAG, \"onStartDiscoveryFailed: \"); } @Override public void onStopDiscoveryFailed(String serviceType, int errorCode) { Log.d(TAG, \"onStopDiscoveryFailed: \"); } @Override public void onDiscoveryStarted(String serviceType) { Log.d(TAG, \"onDiscoveryStarted: \"); } @Override public void onDiscoveryStopped(String serviceType) { Log.d(TAG, \"onDiscoveryStopped: \"); } @Override public void onServiceFound(NsdServiceInfo serviceInfo) { Log.d(TAG, \"onServiceFound\"); NsdManager nsdManager = (NsdManager) getSystemService(NSD_SERVICE); nsdManager.resolveService(serviceInfo, new NsdManager.ResolveListener() { @Override public void onResolveFailed(NsdServiceInfo serviceInfo, int errorCode) { } @Override public void onServiceResolved(NsdServiceInfo serviceInfo) { Log.w(TAG, \"主机: \"+serviceInfo.getHost() +\" 端口:\"+serviceInfo.getPort() ); } }); } @Override public void onServiceLost(NsdServiceInfo serviceInfo) { Log.d(TAG, \"onServiceLost: \"); } }); } 注意, 需要使用服务类型来搜索服务, 一旦服务的状态发生变化(发现和丢失某些东西, 启动和停止发现服务)都会收到回调. 如果需要解析更详细的信息, 通过NsdManager#resolverService()方法来解析. 解析成功会回调函数. 通过NsdManager使用网络发现服务可以在不强制用户手动输入IP地址的情况下和本地设备进行通信. 当要创建共享数据的应用或者建立一个本地多人游戏时, 这是一个选择项. ","date":"2016-10-08","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9812-%E8%BF%9C%E7%A8%8B%E8%AE%BE%E5%A4%87%E5%85%B6%E4%BD%99%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/:4:1","tags":["android","笔记"],"title":"《Android-编程实战》12-远程设备其余通信方式","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9812-%E8%BF%9C%E7%A8%8B%E8%AE%BE%E5%A4%87%E5%85%B6%E4%BD%99%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":"Wi-Fi Direct Wi-Fi Direct是Wi-Fi联盟802.11标准的一部分, 允许在设备间进行高速的Wi-Fi通信, 而不需要专门的接入点. 它基本上是一个采用Wi-Fi技术的对等协议. 所有运行2.3及后续版本的设备都支持Wi-Fi Direct, 但是知道Android 4.1以及网络服务发现API的引入, 开发人员才真正对Wi-Fi Direct变得感兴趣. 在运行Android 4.0或更高的版本的设备上, 通常可以并行地运行Wi-Fi Direct, 这意味着设备可以同时支持Wi-Fi Direct以及普通的Wi-Fi. 主要APIWifiP2pManager 来在一端设备创建并发布服务并监听变化, 另一端通过监听对等的设备并使用WifiP2pServiceRequest来搜索, 当搜索到可用符合的设备进行连接. 当两个设备建立连接, 服务端的注册的广播就会接收到通知. 并进行后续操作处理. 使用WiFi Direct最主要的原因是不需要现有的WIFI基础设施. 同时, 由于建立过程不需要额外的PIN码或者密码, 使用这种方式连接设备会很容易. ","date":"2016-10-08","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9812-%E8%BF%9C%E7%A8%8B%E8%AE%BE%E5%A4%87%E5%85%B6%E4%BD%99%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/:4:2","tags":["android","笔记"],"title":"《Android-编程实战》12-远程设备其余通信方式","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9812-%E8%BF%9C%E7%A8%8B%E8%AE%BE%E5%A4%87%E5%85%B6%E4%BD%99%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F/"},{"categories":null,"content":" 阅读《Android 编程实战》一书的抄书笔记 –\u003e 对应书籍第17章 ","date":"2016-10-08","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9811-%E7%BD%91%E7%BB%9C-web%E6%9C%8D%E5%8A%A1/:0:0","tags":["android","笔记"],"title":"《Android-编程实战》11-网络 Web服务","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9811-%E7%BD%91%E7%BB%9C-web%E6%9C%8D%E5%8A%A1/"},{"categories":null,"content":"Android上的网络调用 虽然Android同时支持TCP和UDP通信, 但应用程序的大部分网络调用都是建立在TCP之上的HTTP请求完成的. 网络操作的两个比较重要的规则: 永远不要在主线程做耗时操作 在Service而不是Activity中执行网络操作. 因为有很多情况下, 在Activity中执行网络操作, 很多时候需要考虑Activity快速切换的状态. 比如用户按了主屏幕键, 然后1秒后又回到了应用程序. ","date":"2016-10-08","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9811-%E7%BD%91%E7%BB%9C-web%E6%9C%8D%E5%8A%A1/:1:0","tags":["android","笔记"],"title":"《Android-编程实战》11-网络 Web服务","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9811-%E7%BD%91%E7%BB%9C-web%E6%9C%8D%E5%8A%A1/"},{"categories":null,"content":"HttpUrlConnection Android提供了两个用于HTTP通信的API. Apache的HttpClient和HttpUrlConnection. 两者都能提供相同的功能. 但是推荐HttpUrlConnection, 因为谷歌一直在对其维护. 比如透明的响应压缩, 响应缓存. Android 4.0(ICS)提供响应缓存功能, 所以如果要支持早期的版本, 开发者需要使用手动实现通过反射来初始化缓存. 如果应用最低支持4.0, 那么使用以下代码开启. HttpResponseCache httpResponseCache = HttpResponseCache.install(new File(getCacheDir, \"http\"), CACHE_SIZE); 为应用选择一个合适的缓存大小. 如果只获取少量的数据, 可以选择几兆大小的缓存. 缓存对应用程序是私有的, 所以相对来说是比较安全的. 比如说HTTP GET请求, 可以看事例代码 或者说上传文件 比如说传送图片或者其他文件到服务器, 由于Java API并没有提供一个可以直接上传文件的的方法. 使用HTTP发送数据涉及使用HTTP POST发送body中的数据. 而body需要设置一些特殊的格式, 并且还要正确地设置header字段. 如下: private static final long MAX_FIXED_SIZE = 5 * 1024 * 1024; private static final String CRLF = \"\\r\\n\"; /** * 使用HTTP POST往服务器发送文件 */ public int postFileToURL(File file, String mimeType, URL url) throws IOException { DataOutputStream requestData = null; try { long fileSize = file.length(); String fileName = file.getName(); // 创建一个随机边界符字符串 Random random = new Random(); byte[] randomBytes = new byte[16]; random.nextBytes(randomBytes); String boundary = Base64.encodeToString(randomBytes, Base64.NO_WRAP); // 配置请求设置 HttpURLConnection uc = (HttpURLConnection) url.openConnection(); uc.setUseCaches(false); uc.setDoOutput(true); // 设置可以发送数据 uc.setRequestMethod(\"POST\"); // 设置HTTP header uc.setRequestProperty(\"Connection\", \"Keep-Alive\"); uc.setRequestProperty(\"Cache-Control\", \"no-cache\"); uc.setRequestProperty(\"Content-Type\", \"multipart/form-data;boundary=\"+boundary); // 如果文件大于max_fixed_size, 使用分块流模式 if (fileSize \u003e MAX_FIXED_SIZE){ uc.setChunkedStreamingMode(0); }else{ uc.setFixedLengthStreamingMode((int)fileSize); } // 打开文件方便读取 FileInputStream fileIn = new FileInputStream(file); // 打开服务器连接 OutputStream out = uc.getOutputStream(); requestData = new DataOutputStream(out); // 开始写数据 // 首先写入第一个边界符 requestData.writeBytes(\"--\" +boundary + CRLF); // 让服务器知道文件名 requestData.writeBytes(\"Content-Disposition: form-data; name=\\\"\"+ fileName + \"\\\"; filename=\\\"\"+fileName + CRLF); // 文件的MIME类型 requestData.writeBytes(\"Content-Type: \"+mimeType + CRLF); // 循环读取本地文件, 并写入服务器 int bytesRead; byte[] buffer = new byte[8 * 1024]; while((bytesRead = fileIn.read(buffer)) != -1){ requestData.write(buffer, 0, bytesRead); } // 写入边界字符串, 表明已到文件结尾 requestData.writeBytes(CRLF); requestData.writeBytes(\"--\" +boundary +\"--\"+ CRLF); requestData.flush(); return uc.getResponseCode(); } catch (IOException e) { e.printStackTrace(); }finally { if (requestData != null){ requestData.close(); } return -1; } } 上面代码, 需要要知道如何使用边界字符串告诉服务器文件的开始和结束位置. 另外上面还通过检查文件的大小而决定是使用分块流模式(chunked streaming mode),还是使用固定长度流模式 . 对于分块流模式参数0表示系统的默认大小, 这是大多数程序在该模式下的大小. 分块基本上意味着数据分部分发送数据, 每一部分都附有该块大小. 分块能更有效地使用内存, 并较少oom异常的分享, 然而, 使用固定长度的数据流模式通常更快, 但它需要更多的内存. ","date":"2016-10-08","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9811-%E7%BD%91%E7%BB%9C-web%E6%9C%8D%E5%8A%A1/:1:1","tags":["android","笔记"],"title":"《Android-编程实战》11-网络 Web服务","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9811-%E7%BD%91%E7%BB%9C-web%E6%9C%8D%E5%8A%A1/"},{"categories":null,"content":"OkHttp和SPDY HTTP的一个大问题就是每个连接只允许一个请求和响应, 这迫使浏览器和其他客户端为了并行请求必须生成多个套接字socket连接. 虽然对于客户端连接问题就不那么大了, 但是如果是服务器端那么面临的状态就不同而语了. 在2009年, 谷歌开始着手更新HTTP协议来解决这些问题. 其结果就是SPDY协议, 它允许在一个套接字连接上发送多个HTTP请求. 该协议已成为下一代HTTP事实上的开放标准, 但它不会取代HTTP, 而是改良了如何通过网络请求和响应. 而HTTP IETF工作组日前已宣布即将开始HTTP 2.0的工作, 并使用SPDY协议作为起点. 如果同时开始客户端和服务端代码, 研究一下使用SPDY来代替常规的HTTP/1.1还是不错的, 因为SPDY能显著降低网络负载, 并能提高性能. 主流浏览器目前已经很好地支持SPDY, 并且已经有很多平台的实现版本, 启动就包括Android. 如果选择SPDY作为通信协议, 建议使用OkHttp, 它是Square公司开发的, 该库只是一个支持SPDY的新改进的HTTP客户端. 内部使用HttpUrlConnection接口. 当初始化OkHttpClient实例时, 它会初始化所有的东西, 比如连接池和响应缓存. 即使是普通的HTTP请求, 该实现也非常快, 使用OkHttp进行SPDY通信能显著提升网络调用的性能. ","date":"2016-10-08","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9811-%E7%BD%91%E7%BB%9C-web%E6%9C%8D%E5%8A%A1/:1:2","tags":["android","笔记"],"title":"《Android-编程实战》11-网络 Web服务","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9811-%E7%BD%91%E7%BB%9C-web%E6%9C%8D%E5%8A%A1/"},{"categories":null,"content":"Web Socket 运行标准的HTTP之上, 是HTTP的扩展. Web Socket允许在客户端和服务器端之前进行基于消息的异步通信. 首先客户端发送一个常规的HTTP GET请求, 该请求包含特殊的HTTP请求头, 表明客户端希望把连接升级为Web Socket连接. 如下当使用Web Socket时,客户端发送的请求示例: GET /websocket HTTP/1.1 Host: myserver.com Upgrade: websocket Connection: Upgrade Sec-WebSocket-Key: xxxxxxxxxxxxxxxxxx== Sec-WebSocket-Protocol: chat Sec-WebSocket-Version: 13 Origin: http://myserver.com 如果接收客户端的请求, 下面是服务器对请求的响应: HTTP/1.1 101 Switching Protocols Upgrade: websocket Connection: Upgrade Sec-WebSocket-Accept: xxxxxxxxxxxxxxxxxxx= Sec-WebSocket-Protocol: chat 客户端的请求头中的值并不是对每一种情况都有效, 而应根据Web Socket协议规范来计算. 通常情况下, 如果使用现成的Web Socket通信库, 开发者就不需要考虑这些情况. 当Web socket连接建立后, 双方可以给对方发送异步消息. 通信的消息可以是文本, 或者二进制, 通常数据量是很小的. 如果需要传输大的文件, 最好还是使用标准的Http. Web socket用于发送符合相对较小的通知. 关于使用, 可以使用Android中标准的Socket类来实现自己的Web Socket客户端, 但也可以使用现有的第三方库. 比如由Nathan Rajlich为Java实现的WebSocket. 可以看介绍. 另外, 这个库还包含了一个服务器的实现. ","date":"2016-10-08","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9811-%E7%BD%91%E7%BB%9C-web%E6%9C%8D%E5%8A%A1/:1:3","tags":["android","笔记"],"title":"《Android-编程实战》11-网络 Web服务","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9811-%E7%BD%91%E7%BB%9C-web%E6%9C%8D%E5%8A%A1/"},{"categories":null,"content":"网络和功耗 手机功耗, 一般手机中消耗第一应该是屏幕, 然后第二往往和网络流量有关. 智能手机的无线硬件如WiFi和蜂窝网络芯片都有内置省电功能, 他们能在网络流量不活跃时自动关闭连接, 并能把功耗降到一个非常低的水平. 当应用程序要发送数据或者等待接收输入数据和包时, 网络硬件将禁用省电模式, 以便能尽可能快速和有效地发送数据. ","date":"2016-10-08","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9811-%E7%BD%91%E7%BB%9C-web%E6%9C%8D%E5%8A%A1/:2:0","tags":["android","笔记"],"title":"《Android-编程实战》11-网络 Web服务","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9811-%E7%BD%91%E7%BB%9C-web%E6%9C%8D%E5%8A%A1/"},{"categories":null,"content":"一般准则 在请求网络前, 首先考虑用户目前是否确实需要这些数据. 其次考虑是否需要全部数据, 或者只是数据的前十条而已, 如果服务器也可以进行gzip压缩, 要记得打开透明压缩, 并选择数据的数据格式, 例如json. ","date":"2016-10-08","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9811-%E7%BD%91%E7%BB%9C-web%E6%9C%8D%E5%8A%A1/:2:1","tags":["android","笔记"],"title":"《Android-编程实战》11-网络 Web服务","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9811-%E7%BD%91%E7%BB%9C-web%E6%9C%8D%E5%8A%A1/"},{"categories":null,"content":"高效的网络轮询 网络轮询有几个缺点, 但是有时只能使用轮询来完成在线服务器的新数据的检查. 这时就别忘了AlarmManager这个API可以方便的进行轮询. ","date":"2016-10-08","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9811-%E7%BD%91%E7%BB%9C-web%E6%9C%8D%E5%8A%A1/:2:2","tags":["android","笔记"],"title":"《Android-编程实战》11-网络 Web服务","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9811-%E7%BD%91%E7%BB%9C-web%E6%9C%8D%E5%8A%A1/"},{"categories":null,"content":"服务器端推送 减少网络调用次数最好的解决办法就是使用服务器端推送. 这样可以让服务器主动通知客户端有新的数据需要检索. 服务器端推送可以有很多种方式, 它可以不直接连接互联网(比如监听短信), 也可以是长期保持获取的常规TCP套接字连接. ","date":"2016-10-08","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9811-%E7%BD%91%E7%BB%9C-web%E6%9C%8D%E5%8A%A1/:2:3","tags":["android","笔记"],"title":"《Android-编程实战》11-网络 Web服务","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9811-%E7%BD%91%E7%BB%9C-web%E6%9C%8D%E5%8A%A1/"},{"categories":null,"content":" 阅读《Android 编程实战》一书的抄书笔记 –\u003e 对应书籍第15章 ","date":"2016-10-04","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9810-%E9%9A%90%E8%97%8F%E7%9A%84android-api/:0:0","tags":["android","笔记"],"title":"《Android-编程实战》10-隐藏的Android API","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9810-%E9%9A%90%E8%97%8F%E7%9A%84android-api/"},{"categories":null,"content":"官方API和隐藏API SDK文档中的所有类, 接口, 方法以及常量都属于官方API. 虽然这些API通常能满足大多数应用的需求, 但开发者有时候需要访问更多的东西, 但却不知道如何在官方API中找到它们. Android SDK中包含了一个JAR文件(android.jar), 在编译代码的时候会引用它, 该文件位于\u003csdk root\u003e/platforms/android-\u003cAPI Level\u003e/目录. 不过这里面全是空类, 方法中所有的代码都被移除了, 只声明了public和protected的类. 构建Android平台时, SDK会包含该JAR文件. 通过检查每一个源文件, 并移除所有被@hide注解的域(常量), 方法和类, 在构建SDK时会生成方法体为空的android.jar文件. 这意味着仍然可以在运行的设备上方法这些符号, 但是在编译时却找不到. Android会自动隐藏某些API, 而不需要使用@hide注解. 这些API位于com.android.internal包中, 不属于android.jar文件, 但却包含大量供android平台使用的内部代码. android系统应用还包含一些其他隐藏API, 这些API通常提供没有包含在官方SDK中的系统ContentProvider信息. ","date":"2016-10-04","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9810-%E9%9A%90%E8%97%8F%E7%9A%84android-api/:1:0","tags":["android","笔记"],"title":"《Android-编程实战》10-隐藏的Android API","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9810-%E9%9A%90%E8%97%8F%E7%9A%84android-api/"},{"categories":null,"content":"发现隐藏API 寻找API最简单的方法是在Android源码中搜索他们. 但是Android源码非常多, 还好有几个在线网站已经对这些代码进行了索引, 并提供了搜索功能. AndroidXRef就是其中的一个. 大部分隐藏的API都位于frameworks项目, 所有android包中的API都可以在frameworks项目中找到, 该项目还包含大部分com.android.internal包中的API. ","date":"2016-10-04","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9810-%E9%9A%90%E8%97%8F%E7%9A%84android-api/:2:0","tags":["android","笔记"],"title":"《Android-编程实战》10-隐藏的Android API","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9810-%E9%9A%90%E8%97%8F%E7%9A%84android-api/"},{"categories":null,"content":"安全地调用隐藏API 对于需要编译时链接的API, 也就是接口, 类, 或者方法, 开发者有两个选择. 第一种修改SDK的JAR文件, 使之包含所有需要的类和接口, 并使用该SDK来编译应用程序. 另一种解决方案是使用Java反射API来动态查找要调用的类和方法. 两种方法都可以利弊. ","date":"2016-10-04","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9810-%E9%9A%90%E8%97%8F%E7%9A%84android-api/:3:0","tags":["android","笔记"],"title":"《Android-编程实战》10-隐藏的Android API","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9810-%E9%9A%90%E8%97%8F%E7%9A%84android-api/"},{"categories":null,"content":"从设备中提取隐藏API 要做到编译时链接隐藏API, 开发者首先要提取和处理设备中的库文件. 即可以从模拟器提取库文件, 也可以从设备中提取这些文件, 因为它们只是用来编译代码. 由于这个过程需要提取出大量文件, 建议单独创建一个空的工作目录. 另外可能要提取多个版本的库文件, 所以开发者还应为每个API级别创建一个工作目录. 这里会把设备的/system/framework目录全部拉取出来, 这些文件都是Android设备上基于Java的系统库, 他们是由Dalvik虚拟机加载的Dex优化文件. 下一步决定哪些文件包含隐藏API, 以便把它们转成可以在编译时使用的Java类文件. 大部分隐藏API都位于framework.odex文件, bouncycastle.odex文件包含了加密的库. 从Android 4.2开始, 原来位于framework.odex的几个隐藏API都放在了其他文件中. 例如Telephony类现在是可选的了(因为并不是所有的Android设备都支持电话), 可以在telephony-common.odex文件中找到它. 一旦知道需要转换的文件, 就可以下载Smali工具, 它能把优化后的Dex文件(.odex)转换为中间格式(.smali). 接下来使用dex2Jar工具再把这种中间格式转换回Java类文件. 修改SDK的错误处理 当使用前面介绍的隐藏API方法时, 很难确定抽取类的方法签名是否和用户设备中相应的方法签名匹配. 虽然修改后的SDK可能在开发用的设备上正常工作, 但是用户的设备制造商可能修改了这些隐藏API. 当这种情况发生时, 应用程序会抛出NoSuchMethodException或者ClassNotFoundException异常. 有几种方法可以处理种种情况. 可以结合使用反射来检测是否存在隐藏API. 推荐使用这种方式, 因为它结合了两种方法的优点. 另一种方法是简单地捕获异常, 防止应用程序崩溃. 不管使用哪一种方法, 都是要确保调用隐藏API的时候发生错误的处理. 最起码可以确保应用程序在测试过的设备上能正常工作. ","date":"2016-10-04","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9810-%E9%9A%90%E8%97%8F%E7%9A%84android-api/:3:1","tags":["android","笔记"],"title":"《Android-编程实战》10-隐藏的Android API","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9810-%E9%9A%90%E8%97%8F%E7%9A%84android-api/"},{"categories":null,"content":"使用反射调用隐藏API 使用Java中的反射API比修改Android SDK更安全, 因为它可以在调用隐藏API前检测它们是否存在. 但是, 由于所有隐藏API的绑定和调用都发生在运行时, 反射会比前面介绍的方法更慢. 使用反射调用隐藏API需要两步. 首先, 需要查找要调用的类和方法, 并把他们的引用存到Method对象中. 当持有了引用后, 接下来就可以调用对象的方法. 后面会演示了查找Wi-Fi网络共享的例子. ","date":"2016-10-04","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9810-%E9%9A%90%E8%97%8F%E7%9A%84android-api/:3:2","tags":["android","笔记"],"title":"《Android-编程实战》10-隐藏的Android API","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9810-%E9%9A%90%E8%97%8F%E7%9A%84android-api/"},{"categories":null,"content":"隐藏API的使用 ","date":"2016-10-04","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9810-%E9%9A%90%E8%97%8F%E7%9A%84android-api/:4:0","tags":["android","笔记"],"title":"《Android-编程实战》10-隐藏的Android API","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9810-%E9%9A%90%E8%97%8F%E7%9A%84android-api/"},{"categories":null,"content":"接收和阅读SMS Android中使用隐藏API最常见的例子是接收和阅读SMS, 虽然官方API包含了RECEIVE_SMS和READ_SMS这两个权限, 但实际执行的API却是隐藏的. 应用程序要想接收SMS必须声明使用RECEIVE_SMS权限, 并且实现BroadcastReceiver, 已处理收到的短信. 如下: // 清单文件 \u003cuses-permission android:name=\"android.permission.RECEIVE_SMS\"/\u003e \u003creceiver android:name=\".hideapi.SmsReceiver\"\u003e \u003cintent-filter\u003e \u003caction android:name=\"android.provider.Telephony.SMS_RECEIVED\"/\u003e \u003c/intent-filter\u003e \u003c/receiver\u003e public class SmsReceiver extends BroadcastReceiver { // Telephony.java 中隐藏的常量 public static final String SMS_RECEIVED_ACTION = \"android.provider.Telephony.SMS_RECEIVED\"; public static final String MESSAGE_SERVICE_NUMBER = \"+461234567890\"; private static final String MESSAGE_SERVICE_PREFIX = \"MYSERVICE\"; public void onReceive(Context context, Intent intent) { String action = intent.getAction(); if (SMS_RECEIVED_ACTION.equals(action)) { // 通过 pdus 获取SMS数据的隐藏键 Object[] messages = (Object[]) intent.getSerializableExtra(\"pdus\"); for (Object message : messages) { byte[] messageData = (byte[]) message; SmsMessage smsMessage = SmsMessage.createFromPdu(messageData); Log.e(\"haha\", \"收到消息来自: \"+smsMessage.getOriginatingAddress()+ \" 内容:\"+smsMessage.getMessageBody()); processSms(smsMessage); } } } // 只关心指定的电话号码 private void processSms(SmsMessage smsMessage) { String from = smsMessage.getOriginatingAddress(); if (MESSAGE_SERVICE_NUMBER.equals(from)) { String messageBody = smsMessage.getMessageBody(); if (messageBody.startsWith(MESSAGE_SERVICE_PREFIX)) { // TODO: 数据验证通过开始处理 Log.e(\"haha\", \"processSms: \"+messageBody); } } } } 上面利用广播监听Intent操作android.provider.Telephony.SMS_RECEIVED. 这个例子中唯一隐藏的部分就是Intent的action. 以及用来从Intent(\"pdus\")检索SMS数据的字符串. 要读取已经收到的SMS, 需要查询一个隐藏的ContentProvider, 并声明使用READ_SMS权限. android.provider包中的Telephony类提供了所有需要的信息. 使用该类最佳的方式是把它复制到自己的项目中, 并修改类的包结构. 由于Telephony类还包含其他隐藏类和方法的调用, 所以还必须删除或者重构这些调用, 以便能够编译代码. 取决于使用隐藏API的数量, 有时候简单复制一些常量声明而不是整个类就足够了. 阅读的部分就省略了, 除了某些特定方向的应用, 基本上应用是不会去读入用户的短信. ","date":"2016-10-04","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9810-%E9%9A%90%E8%97%8F%E7%9A%84android-api/:4:1","tags":["android","笔记"],"title":"《Android-编程实战》10-隐藏的Android API","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9810-%E9%9A%90%E8%97%8F%E7%9A%84android-api/"},{"categories":null,"content":"隐藏设置 Android设备有数百种不同的设置, 都可以通过Settings类访问, 除了为每个设置提供访问的值, Android还提供给了一些类Intent操作, 使他们可以打开特定的设置UI. 例如, 要启动飞行模式设置, 在创建Intent时可以使用Settings.ACTION_AIRPLANE_MODE_SETTINGS Settings类包含了一些隐藏的设置键和Intent操作, 当应用程序需要弄清楚设备的细节或者呈现一个特定系统设置的快捷方式时, 启动的一些常量值是非常方便的. ","date":"2016-10-04","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9810-%E9%9A%90%E8%97%8F%E7%9A%84android-api/:4:2","tags":["android","笔记"],"title":"《Android-编程实战》10-隐藏的Android API","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9810-%E9%9A%90%E8%97%8F%E7%9A%84android-api/"},{"categories":null,"content":" 阅读《Android 编程实战》一书的抄书笔记 –\u003e 对应书籍第14章 ","date":"2016-10-04","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9809-android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/:0:0","tags":["android","笔记"],"title":"《Android-编程实战》09-Android应用安全问题","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9809-android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"},{"categories":null,"content":"Android安全的概念 Android具备一个先进的安全模型来保护应用数据和服务不被其他应用访问. 每个应用都有自己的唯一ID来提供最基本的保护. 每个应用都经过它唯一的密钥签名, 这种机制是Android框架中的安全模型基础. 此外只有当其他应用在清单文件中显式声明了正确权限后, Android的权限系统才会和他们共享特定的组件. 应用也可以定义权限, 比如只有使用同一个密钥签名的应用才能使用它们. 最后Android的API提供了各种方法来验证签名, 验证调用进程的用户ID和使用强加密方案. ","date":"2016-10-04","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9809-android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/:1:0","tags":["android","笔记"],"title":"《Android-编程实战》09-Android应用安全问题","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9809-android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"},{"categories":null,"content":"签名和密钥 Android系统中运行的所有应用都要用密钥来签名, 包括Android系统本身. 可以用同一个密钥来对发布的所有应用进行签名, 但建议为各个应用单独创建一个密钥. 多个应用共享一个密钥通常是因为这些应用要直接访问彼此的数据, 或者设定权限时将保护等级改为signature 下面是一种为应用生成密钥的一个方式, 有一种比较好的方式是使用应用的包名作为别名传给-alias. $ keytool -genkey -v -keystore \u003ckeystore filename\u003e -alias \u003calias for key\u003e keyalg RSA -keysize 2048 -validity 10000 在生成新密钥时, keytool会让你输入一个密码. ","date":"2016-10-04","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9809-android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/:1:1","tags":["android","笔记"],"title":"《Android-编程实战》09-Android应用安全问题","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9809-android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"},{"categories":null,"content":"Android权限 要在Android中使用特殊权限功能, 只要在清单文件中加入一个uses-permission标记即可. 它会告诉系统你的应用需要该项权限, 并在安装时通知用户这项需求. Android中定义了五个保护等级: 常规normal, 危险dangerous, 同一签名signature, 同一签名或系统signatureOrSystem, 系统system. 除非特殊指定, 默认等级一般为常规. 用来告知系统有应用要用到这个权限的函数. 只有将权限设为危险时, 它才会在用户安装(通常是通过Google Play Store)前提醒用户. 同一签名保护等级要求应用使用跟定义该权限的应用相同的同一证书来签名. 这对设备制造商来说非常有用, 因为他们可以定义只有跟系统使用同一证书签名的应用才能使用的权限. 这样, 设备制造商就可以像他们使用受保护的系统服务的设备发布新应用. 同一签名或系统 以及 系统这两个等级会告诉Android系统, 应用必须驻存在设备的系统分区上, 这样才能使用该权限. 这个功能最常见的例子是预装在系统分区上的Google应用. 这些应用可以使用许多常规应用无法企及的权限, 即使他们用的是Google的签名而不是设备制造商的. 也可以添加属性android:permissionFlags=\"costsMoney\" 它会告诉用户使用此权限的应用会产生费用, 例如要用到发短信的功能的应用. 只要应用提供了可能会给用户带来费用的API, 那就应该用带有此标记的权限来保护该API. ","date":"2016-10-04","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9809-android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/:1:2","tags":["android","笔记"],"title":"《Android-编程实战》09-Android应用安全问题","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9809-android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"},{"categories":null,"content":"保护用户数据 如果要创建安全的数据文件, 不被其他应用访问, 可以在应用数据目录中存储文件. 而不是外部存储中. 如下:演示在应用的数据目录中对一个文件进行数据追加 public static void appendStringToPrivateFile(Context context, String data, String fileName){ FileOutputStream out = context.openFileOutput(fileName, Context.MODE_APPEND | Context.MODE_PRIVATE); out.write(data.getBytes(\"UTF-8\")); out.close(); } 这里使用了两个标志位: MODE_APPEND 要写入的数据都被追加到文件的末尾, MODE_PRIVATE 该文件只允许你的应用访问, 这个标识位也是默认标志位. 当然这只是一种比较安全的方式, 但是如果存储非常敏感的信息, 最好再对文件进行一些加密处理. ","date":"2016-10-04","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9809-android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/:1:3","tags":["android","笔记"],"title":"《Android-编程实战》09-Android应用安全问题","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9809-android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"},{"categories":null,"content":"客户端数据加密 ","date":"2016-10-04","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9809-android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/:2:0","tags":["android","笔记"],"title":"《Android-编程实战》09-Android应用安全问题","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9809-android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"},{"categories":null,"content":"Android的加密API Android中的数据加密和解密API是基于Java SE的javax.crypto包中的API开始的. 实际的实现基于开源的Bouncy Castle加密API. 因此, 在开发Android应用时, 大多是使用Java SE的javax.cryptoAPI就可以. ","date":"2016-10-04","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9809-android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/:2:1","tags":["android","笔记"],"title":"《Android-编程实战》09-Android应用安全问题","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9809-android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"},{"categories":null,"content":"生成密钥 使用加密和解密函数时, 需要生成一个可根据用户输入(密码或其他安全方法)重新生成的安全且唯一的密钥. 下面的代码演示了如何为AES算法生成一个SecretKey salt是用于生成密钥的输入部分, 你需要记录下来. 在密码学中, 盐salt是用做加密算法中单向函数输入的一段随机数据. public static SecretKey generateKey(char[] password , byte[] salt) throws NoSuchAlgorithmException, InvalidKeySpecException { int iterations = 1000; int outputKeyLength = 128; SecretKeyFactory secretKeyFactory = SecretKeyFactory.getInstance(\"PBKDF2WithHmacSHA1\"); PBEKeySpec pbeKeySpec = new PBEKeySpec(password, salt, iterations, outputKeyLength); byte[] keyBytes = secretKeyFactory.generateSecret(pbeKeySpec).getEncoded(); return new SecretKeySpec(keyBytes, \"AES\"); } 这个密钥在后面会使用 ","date":"2016-10-04","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9809-android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/:2:2","tags":["android","笔记"],"title":"《Android-编程实战》09-Android应用安全问题","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9809-android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"},{"categories":null,"content":"加密数据 要加密数据, 必须先生成用于加密的作为Cipher输入的盐和初始化向量. 下面的代码会通过SecureRandom类生成一个长度为8字节的盐. 注意: 不需要人工给SecureRandom喂种子, 系统会自动帮你处理. 创建一个初始化向量, 初始化Cipher, 然后将明文加密成字节队列. 有了密文数据之后, 可以使用Base64工具类从这些字节生成一个普通的String对象. 并把初始化向量和盐用同样的方式追加上去, 并通过一个非Base64字符来分开. public static String encryptClearText(char[] password, String plainText) throws Exception { SecureRandom secureRandom = new SecureRandom(); int saltLength = 8; byte[] salt = new byte[saltLength]; secureRandom.nextBytes(salt); SecretKey secretKey = generateKey(password, salt); Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\"); byte[] initVector = new byte[cipher.getBlockSize()]; secureRandom.nextBytes(initVector); IvParameterSpec ivParameterSpec = new IvParameterSpec(initVector); cipher.init(Cipher.ENCRYPT_MODE, secretKey, ivParameterSpec); byte[] cipherData = cipher.doFinal(plainText.getBytes(\"UTF-8\")); return Base64.encodeToString(cipherData, Base64.NO_WRAP | Base64.NO_PADDING) + \"]\" + Base64.encodeToString(initVector, Base64.NO_WRAP | Base64.NO_PADDING) + \"]\" + Base64.encodeToString(salt, Base64.NO_WRAP | Base64.NO_PADDING); } 方法返回的结果就是加密后的密文字符串. 解密的时候使用同样的规则解密即可 ","date":"2016-10-04","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9809-android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/:2:3","tags":["android","笔记"],"title":"《Android-编程实战》09-Android应用安全问题","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9809-android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"},{"categories":null,"content":"解密数据 和加密基本相似, 取出加密的的数据部分. 代码如下: public static String decryptData(char[] password, String encodedData) throws Exception { String[] parts = encodedData.split(\"]\"); byte[] cipherData = Base64.decode(parts[0], Base64.DEFAULT); byte[] initVector = Base64.decode(parts[1], Base64.DEFAULT); byte[] salt = Base64.decode(parts[2], Base64.DEFAULT); Cipher cipher = Cipher.getInstance(\"AES/CBC/PKCS5Padding\"); IvParameterSpec ivParams = new IvParameterSpec(initVector); SecretKey secretKey = generateKey(password, salt); cipher.init(Cipher.DECRYPT_MODE, secretKey, ivParams); return new String(cipher.doFinal(cipherData), \"UTF-8\"); } 从上面方法可以了解到Cipher,初始化向量,SecretKey是如何通过输入的字符串重新生成的. 只要密码匹配, 就能够对数据进行解码和编码. ","date":"2016-10-04","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9809-android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/:2:4","tags":["android","笔记"],"title":"《Android-编程实战》09-Android应用安全问题","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9809-android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"},{"categories":null,"content":"设备管理API 关于这部分, 更多偏向于系统级别的开发. 例如对远程安全加固功能, 当丢失设备通过短信,锁定设备等. 所以此处不做记录. 如果有兴趣可以查看API文档Device Administration API ","date":"2016-10-04","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9809-android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/:3:0","tags":["android","笔记"],"title":"《Android-编程实战》09-Android应用安全问题","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9809-android%E5%BA%94%E7%94%A8%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/"},{"categories":null,"content":" 阅读《Android 编程实战》一书的抄书笔记 –\u003e 对应书籍第11章 ","date":"2016-10-03","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9808-%E9%AB%98%E7%BA%A7%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E5%8F%8A%E7%9B%B8%E6%9C%BA%E5%BA%94%E7%94%A8/:0:0","tags":["android","笔记"],"title":"《Android 编程实战》08-高级音频,视频及相机应用","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9808-%E9%AB%98%E7%BA%A7%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E5%8F%8A%E7%9B%B8%E6%9C%BA%E5%BA%94%E7%94%A8/"},{"categories":null,"content":"高级音频应用 Android音频API提供了一些高级功能, 开发者可以把他们集成到自己的应用中. 有了这些API, 就可以很容易的实现VoIP网络电话, 构建定制的流媒体音乐客户端, 实现低延迟的游戏音效. 此外, 还有提供文本到语音转换以及语音识别API, 用户可以直接使用音频和用户交互, 而不需要使用用户界面或者触控技术. ","date":"2016-10-03","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9808-%E9%AB%98%E7%BA%A7%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E5%8F%8A%E7%9B%B8%E6%9C%BA%E5%BA%94%E7%94%A8/:1:0","tags":["android","笔记"],"title":"《Android 编程实战》08-高级音频,视频及相机应用","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9808-%E9%AB%98%E7%BA%A7%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E5%8F%8A%E7%9B%B8%E6%9C%BA%E5%BA%94%E7%94%A8/"},{"categories":null,"content":"低延迟音频 Android有四个用来播放音频的API(算上MIDI那么就是5个)和三个用来录音的API. 接下里会简要介绍这些API. 音频播放API 音频播放默认使用MediaPlayer. 该类适合播放音乐或者视频, 既能播放流式资源(比如在线网络收音机), 也可以播放本地文件. 每个MediaPlayer都有一个关联的状态机, 需要在应用程序中跟踪这些状态. 开发者可以使用MediaPlayer类的API在自己的应用中嵌入音乐或者视频播放功能, 而无需额外处理或者考虑延迟问题. 第二种是SoundPool类, 它提供了低延迟的支持, 适合播放音效和其他比较短的音频, 比如可以使用SoundPool播放游戏声音. 但是, 它不支持音频流, 所以不适合那些需要实时音频流处理的应用如VoIP. 第三种是AudioTrack类, 它允许把音频流缓冲到硬件中, 支持低延迟播放, 甚至适合流媒体场景. AudioTrack通常能提供足够低的延迟, 可在VoIP或类似应用中使用. 下面代码展示如何在VoIP应用中使用AudioTrack public class AudioTrackDemo { private final AudioTrack mAudioTrack; private final int mMinBufferSize; public AudioTrackDemo() { // 确定音频流的最小缓冲区和大小 mMinBufferSize = AudioTrack.getMinBufferSize(16000, AudioFormat.CHANNEL_OUT_MONO, AudioFormat.ENCODING_PCM_16BIT); mAudioTrack = new AudioTrack(AudioManager.STREAM_VOICE_CALL, 16000, AudioFormat.CHANNEL_OUT_MONO, AudioFormat.ENCODING_PCM_16BIT, mMinBufferSize * 2, AudioTrack.MODE_STREAM); } public void playPcmPacket(byte[] pcmData){ if (mAudioTrack != null \u0026\u0026 mAudioTrack.getState() == AudioTrack.STATE_INITIALIZED){ // 判断是否处在播放状态 if (mAudioTrack.getPlaybackRate() != AudioTrack.PLAYSTATE_PLAYING){ mAudioTrack.play(); } mAudioTrack.write(pcmData, 0, pcmData.length); } } // 设置停止 public void stopPlayback(){ if (mAudioTrack != null){ mAudioTrack.stop(); mAudioTrack.release(); } } } 对这个类进行一下整理, 首先从构造函数开始. 最开始需要确定音频流的最小缓冲区大小. 要做到这一点, 需要知道采样率, 数据是单声道还是立体声, 以及是否使用8位或者16位PCM编码. 然后以采样率和采样大小作为参数调用AudioTrack.getMinBufferSize(), 该方法会以字节形式返回AudioTrack实例的最小缓冲区大小 接下来, 根据使用正确的参数创建AudioTrack实例, 第一个参数为音频的类型, 不同的应用使用不同的值. 对于VoIP这种应用来说使用STREAM_VOICE_CALL, 而对流媒体音乐应用则使用STREAM_MUSIC. 对于参数2,3,4会根据使用场景而有所不同. 这些参数跟别表示采样率, 立体声/单声道, 采样大小. 一般而言, 一个VoIP会使用16kHz的16位单声道, 而常规的音乐CD可能采用44.1kHz的16位立体声. 16位立体声采样率需要更大的缓冲区以及更多的数据传输, 但是音质会更好. 所有的Android设备都支持PCM以8kHz,16kHz,44.1kHz的采样率播放8位或者16位的立体声. 缓冲区大小参数应该是最小缓冲区大小的倍数, 实际取决于具体的需求, 有时网络延迟等因素也会影响缓冲区大小. 注意: 任何时候都应该避免使用空的缓冲区, 因为可能导致播放出现故障 最后一个参数决定只发送一次音频数据MODE_STATIC还是连续发送数据流MODE_STREAM. 第一种情况需要一次发送整个音频剪辑. 对于持续发送音频流的情况, 可以发送任意大小块的PCM数据, 处理流媒体音乐或者VoIP通话时可能会使用这种方式. 2. 录音API 说道录制音频(也可能是视频), 首先要考虑的API是MediaRecorder. 和MediaPlayer类似, 需要在应用代码中跟踪MediaRecorder类的内部状况. 由于MediaRecorder只能把录音保存在文件中, 所以他不适合录制流媒体. 如果需要录制流媒体, 可以使用AudioRecorder, 它和之前描述的AudioTrack非常相似. 链接代码演示了如何创建AudioRecorder实例录制16位单声道16kHz的音频采样 其实和AudioTrack的创建过程非常给你相似, 在使用VoIP或者类似应用时可以很方便地把他们结合起来. ","date":"2016-10-03","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9808-%E9%AB%98%E7%BA%A7%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E5%8F%8A%E7%9B%B8%E6%9C%BA%E5%BA%94%E7%94%A8/:1:1","tags":["android","笔记"],"title":"《Android 编程实战》08-高级音频,视频及相机应用","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9808-%E9%AB%98%E7%BA%A7%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E5%8F%8A%E7%9B%B8%E6%9C%BA%E5%BA%94%E7%94%A8/"},{"categories":null,"content":"OpenSL ES 前面说了3播放API和2个录制API. 还有最后一个API OpenSL ES, 它同时支持播放和录制. 该API是科纳斯组织(Khronos Group)的一个标准, 这个组织还负责OpenGL API OpenSL ES提供了低级别的音频硬件访问和低延迟特性来处理音频播放和录制. 虽然Android中其他音频API都有方便的Java API, 但是OpenSL ES目前仅支持在Android NDK中使用本地C代码访问. = =!!! 到这里能力受限, 无法实现出效果...所以此章抄书就此太监. 后续包括OpenGL 串联Surface用于视频MediaPlayer的渲染层或者相机处理把预览画面的流连接到纹理流, 并实施处理画面实现现实AR应用等. ","date":"2016-10-03","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9808-%E9%AB%98%E7%BA%A7%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E5%8F%8A%E7%9B%B8%E6%9C%BA%E5%BA%94%E7%94%A8/:1:2","tags":["android","笔记"],"title":"《Android 编程实战》08-高级音频,视频及相机应用","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9808-%E9%AB%98%E7%BA%A7%E9%9F%B3%E9%A2%91-%E8%A7%86%E9%A2%91%E5%8F%8A%E7%9B%B8%E6%9C%BA%E5%BA%94%E7%94%A8/"},{"categories":null,"content":" 阅读《Android 编程实战》一书的抄书笔记 –\u003e 对应书籍第9章 ","date":"2016-10-02","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9807-%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%B4%E6%98%8E/:0:0","tags":["android","笔记"],"title":"《Android 编程实战》07-序列化说明","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9807-%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%B4%E6%98%8E/"},{"categories":null,"content":"数据存储的介绍 谈到数据数据存储通常会使用持久化, 而用序列化描述数据是如何表现其存储状态的. 如果没有数据的持久化, 那么数据还能在RAM中保持其状态, 一旦相关进程结束数据就会消失. 实现数据的持久化通常涉及性能, 延迟, 数据大小和复杂度等因素的这种. 例如, 快速的数据读取往往会导致较慢的写入. 序列化就是关于数据如何组织的, 同时包括在持久化状态和内存中. ","date":"2016-10-02","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9807-%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%B4%E6%98%8E/:1:0","tags":["android","笔记"],"title":"《Android 编程实战》07-序列化说明","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9807-%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%B4%E6%98%8E/"},{"categories":null,"content":"Android持久化选项 Android中提供了两种现成的方法, 分别是: 偏好文件(preference files): 使用XML格式, 通过SharePreferences类提供接口 数据库(sqlite): 通常被包装成ContentProider组件. 通常选项, 应用配置属性用preferences files来存储; 数组表格,或者Java表示的一些数据用数据库进行存储; 而一些二进制数据, 例如图片通常当做常规文件来存储在本地. ","date":"2016-10-02","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9807-%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%B4%E6%98%8E/:2:0","tags":["android","笔记"],"title":"《Android 编程实战》07-序列化说明","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9807-%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%B4%E6%98%8E/"},{"categories":null,"content":"Preferences file 这些文件存储在应用程序的内部目录中, 其结构只允许存储键值对. 创建SharePreferences对象最简单的方式是使用PreferenceManager.getDefaultSharedPreferences()方法, 它会返回应用程序默认的偏好对象. 这种方式的便利是系统会自动管理偏好文件名. 如果需要多个偏好文件那么要使用Context.getSharedPreferences()方法, 它允许开发者自由命名文件. 如果只是创建Activity相关的偏好文件, 可以使用Activity.getPreference()方法, 他会在调用时得到Activity的名字. getDefaultSharePreferences()创建的偏好文件名是由包名+_preferences组成的. 其内部支持的存储值类型有int, float, long, boolean, String以及Set\u003cString\u003e对象. 键名必须是一个有效的字符串. 如果需要文件修改并提交存储 首先需要获得Editor实例, 他提供了相应的PUT方法, 以及用于提交修改的方法. 在Android 2.3之前, 通过使用commit()方法把修改同步提交到存储设备中. 但在2.3之后, Editor类提供了用于异步执行写操作的apply()方法. 因为要尽可能地避免主线程执行阻塞操作, 所以apply()相对来说比commit()更好. 如果需要对偏好值被修改的时候可以收到通知 那么可以通过注册一个回调函数, 每当apply()和commit()方法时都会触发该监听器. 通过对SharedPreferences的实例调用registerOrSharedPreferenceChangeListener()方法来添加内容改变回调. ","date":"2016-10-02","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9807-%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%B4%E6%98%8E/:3:0","tags":["android","笔记"],"title":"《Android 编程实战》07-序列化说明","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9807-%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%B4%E6%98%8E/"},{"categories":null,"content":"用户选项和设置用户界面 Android提供一套现成的Activity和Fragment类针对用户更改应用程序的选项和设置, 使得创建这类用户界面非常简单容易PreferenceActivity和PreferenceFragment. 但! 是! 感觉没啥用处, 基本应用都会按照自己的ui风格进行设计. 知道一下就行 ","date":"2016-10-02","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9807-%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%B4%E6%98%8E/:3:1","tags":["android","笔记"],"title":"《Android 编程实战》07-序列化说明","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9807-%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%B4%E6%98%8E/"},{"categories":null,"content":"ContentProvider注意事项 ","date":"2016-10-02","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9807-%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%B4%E6%98%8E/:4:0","tags":["android","笔记"],"title":"《Android 编程实战》07-序列化说明","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9807-%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%B4%E6%98%8E/"},{"categories":null,"content":"Android数据库设计 关系数据库的设计通常通过数据库规范化完成. 该过程使用一些范式规则来减少数据库中的依赖和冗余. 有许多数据库范式, 但在大多数情况下, 只有前三个是相关的. 如果一个数据库设计满足了前三个范式, 可以认为它是规范化的. 由于面向的对象为android应用. 有可能不一定在表中尽可能多的使用外键, 虽然使用外键可以更好的减少空间的占用, 但是相对于开发中操作多表的困难度也就相应的提高. 所以需要权衡一下. ","date":"2016-10-02","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9807-%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%B4%E6%98%8E/:4:1","tags":["android","笔记"],"title":"《Android 编程实战》07-序列化说明","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9807-%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%B4%E6%98%8E/"},{"categories":null,"content":"创建和升级数据库 建议总是使用ContentProvider组件包装SQLite数据库. 通过这种方式, 可以只在一个地方管理的数据库调用, 还可以使用一些现成的数据库工具类. ","date":"2016-10-02","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9807-%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%B4%E6%98%8E/:4:2","tags":["android","笔记"],"title":"《Android 编程实战》07-序列化说明","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9807-%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%B4%E6%98%8E/"},{"categories":null,"content":"查询方法说明 查询数据库(通常会调用ContentResolver.query())会调用ContentProvider.query()方法. 在实现查询方式时必须解析传入的Uri以决定执行哪个查询, 并且还要检查所有传入的参数是否正确. 编写数据库查询要把WHERE语句中较简单的比较放在前面. 这样会加快查询, 因为其可以尽早决定要包含的信息. ","date":"2016-10-02","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9807-%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%B4%E6%98%8E/:4:3","tags":["android","笔记"],"title":"《Android 编程实战》07-序列化说明","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9807-%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%B4%E6%98%8E/"},{"categories":null,"content":"数据库事务 每次在SQLite数据库执行一条SQL语句都会执行一次数据库事务操作. 除非是自己专门管理事务, 否则每条语句都会自动创建一个事务. 因为大多数ContentProvider调用最终都只会生成一条SQL语句, 这种情况下几乎没有必要手动处理事务. 但是如果应用程序将执行多条SQL语句, 比如一次插入很多条记录, 记得总是自己管理事务. ContentProvider类提供了两个事务管理的方法: ContentProvider.bulkInsert()和ContentProvider.applyBatch() 相比与普通的insert()快了很多. 事务的语义很简单. 首先调用SQLiteDatabase.beginTransaction()开始一个新的事务. 当成功插入所有记录之后调用SQLiteDatabase.setTransactionSuccessful(), 然后使用SQLiteDatabase.endTransaction()结束本次事务. 如果某条数据插入失败, 会抛出SQLiteException, 而之前的所有插入都会回滚, 因为在成功之前没有调用过setTransactionSuccessful() bulkInsert()虽然会提高数据插入性能, 但是此方法只使用插入操作 如果要在一次事务中执行多次update()或者delete()语句, 必须实现ContentProvider.applyBatch()方法. 接收一个ContentProviderOperation集合.内部循环集合通过调用apply()在事务内部实现操作. 该API是为ContactsProvider等较复杂的ContentProvider设计的, 他们有许多连接的表, 每个都有自己的Uri. 另外如果要批量插入多个表, 该API也可以使用. ","date":"2016-10-02","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9807-%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%B4%E6%98%8E/:4:4","tags":["android","笔记"],"title":"《Android 编程实战》07-序列化说明","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9807-%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%B4%E6%98%8E/"},{"categories":null,"content":"序列化数据 如果要在Intent上传输数据或者和另外一台设备共享数据, 需要把数据转化成接收端能识别的格式, 并且还要适于在网络上传输. 这种技术称为序列化(serialization) 序列化是从内存中取出数据并把其写到文件(或者其他输出)中, 是的以后能读取完全相同的数据称为反序列化. android内部使用了Parcelable接口来处理序列化工作, 但它不适合在文件上持久存储或者在网络上传输数据. ","date":"2016-10-02","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9807-%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%B4%E6%98%8E/:5:0","tags":["android","笔记"],"title":"《Android 编程实战》07-序列化说明","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9807-%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%B4%E6%98%8E/"},{"categories":null,"content":"JSON JSON是JavaScript Object Notation的缩写, 是JavaScript标准的一个子集. 这种格式很适合表示非二进制数据的. 例如一下JSON数据: [ { \"name\":\"张三\" \"id\" :\"1\" \"sex\" :\"男\" }, { \"name\":\"张三\" \"id\" :\"1\" \"sex\" :\"男\" }, { \"name\":\"张三\" \"id\" :\"1\" \"sex\" :\"男\" } ] 这里说一下另一个API作为了解, 通过获得输入输出流利用JsonReader和JsonWriterAPI进行. 相比较直接把一个流中的全部内容读取为一个String中, 然后传给JSONArray的构造函数, 使用JsonReader会消耗更少的内存, 并且相对来说会更快. 直接使用JSON API 现在也不常用, 想了解看一下实例代码 ","date":"2016-10-02","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9807-%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%B4%E6%98%8E/:5:1","tags":["android","笔记"],"title":"《Android 编程实战》07-序列化说明","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9807-%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%B4%E6%98%8E/"},{"categories":null,"content":"Gson介绍 JSONObject和JSONArray类使用起来虽然很方便, 但是他们也有一定的局限性, 并且通常会消耗更多不必要的内存. 同样, 如果有多个不同类型的对象, 使用JsonReader和JsonWriter需要编写比较多的代码. 所以如果需要更高级的JSON数据序列化和反序列化方法, 可是使用Gson Gson允许把简单的Java对象转换成JSON, 反之亦然. 所以常做的就是生成一个JavaBean对象, 提供set/get并转换成json对象. ","date":"2016-10-02","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9807-%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%B4%E6%98%8E/:5:2","tags":["android","笔记"],"title":"《Android 编程实战》07-序列化说明","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9807-%E5%BA%8F%E5%88%97%E5%8C%96%E8%AF%B4%E6%98%8E/"},{"categories":null,"content":" 阅读《Android 编程实战》一书的抄书笔记 –\u003e 对应书籍第8章 ","date":"2016-09-29","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9806-%E9%87%8D%E8%AF%86-broadcastreceiver/:0:0","tags":["android","笔记"],"title":"《Android 编程实战》06-重识 BroadcastReceiver","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9806-%E9%87%8D%E8%AF%86-broadcastreceiver/"},{"categories":null,"content":"BroadcastReceiver Android中发送广播事件最常用的方式是通过Content.sendBroadcast()方法给BroadcastReceiver发送Intent对象. 许多标准系统事件都被定义成操作字符串, 并可以在Intent类的API文档中查看. 例如, 如果需要在用户连接或者断开充电器的时候收到通知, 可以使用Intent中定义的两个广播操作: ACTION_POWER_DISCONNECTED和ACTION_POWER_CONNECTED. 举例: 例如监听手机充电状态改变的广播 首先派生出一个BroadcastReceiver的子类.复写onReceiver()方法. 如下 public class ChargerConnectedReceiver extends BroadcastReceiver { public ChargerConnectedReceiver() { } @Override public void onReceive(Context context, Intent intent) { String action = intent.getAction(); if (Intent.ACTION_POWER_CONNECTED.equals(action)){ Toast.makeText(context, \"手机充电啦\", Toast.LENGTH_SHORT).show(); }else if (Intent.ACTION_POWER_DISCONNECTED.equals(action)){ Toast.makeText(context, \"手机不充电了\", Toast.LENGTH_SHORT).show(); } } } 然后需要注册广播, 告诉系统在当哪一个action动作发生的时候需要回调我们自定的接收者的onReceive()方法. 这里有两种方法, 静态注册和动态注册. 静态注册 在清单文件中声明这个广播组件, 并设置intent-filter即可 \u003creceiver android:name=\"broadcast.ChargerConnectedReceiver\"\u003e \u003cintent-filter\u003e \u003caction android:name=\"android.intent.action.ACTION_POWER_CONNECTED\"/\u003e \u003caction android:name=\"android.intent.action.ACTION_POWER_DISCONNECTED\"/\u003e \u003c/intent-filter\u003e \u003c/receiver\u003e 动态注册 一般情况动态注册都是在Activity中的onCreate()和onResume()同时出现的. 例如: public class ChargerConnectedActivity extends Activity { private ChargerConnectedReceiver chargerConnectedReceiver; @Override protected void onResume() { super.onResume(); // 生成对于广播的 intent过滤条件 IntentFilter intentFilter = new IntentFilter(); intentFilter.addAction(Intent.ACTION_POWER_CONNECTED); intentFilter.addAction(Intent.ACTION_POWER_DISCONNECTED); chargerConnectedReceiver = new ChargerConnectedReceiver(); registerReceiver(chargerConnectedReceiver, intentFilter); } @Override protected void onPause() { super.onPause(); unregisterReceiver(chargerConnectedReceiver); } } 如果只在应用程序处于运行或活动状态时才关心广播事件时, 可以选择在代码中注册广播. 这样可以让应用程序消耗更少的资源; 如果在清单文件中声明, 则每当有事件发生时, 广播接收器都会启动, 因此会消耗更多资源. ","date":"2016-09-29","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9806-%E9%87%8D%E8%AF%86-broadcastreceiver/:1:0","tags":["android","笔记"],"title":"《Android 编程实战》06-重识 BroadcastReceiver","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9806-%E9%87%8D%E8%AF%86-broadcastreceiver/"},{"categories":null,"content":"本地BroadcastReceiver 如果只是在应用程序进程内发送和接收广播, 那么可以使用LocalBroadcastManager而不是更常用的Context.sendBroadcast()方法. 这种方法更高效, 因为不需要跨进程管理操作, 也不需要考虑广播通常涉及的安全问题. 标准IPA中没有包含LocalBroadcastManager类, 但是可以在支持包(support_V4)中找到. 下面演示如何使用: public static final String LOCAL_BROADCAST_ACTION = \"localBroadcast\"; private BroadcastReceiver mLocalReceiver; // 注册本地广播 private void initLocalBroadcast() { LocalBroadcastManager instance = LocalBroadcastManager.getInstance(getApplicationContext()); IntentFilter intentFilter = new IntentFilter(LOCAL_BROADCAST_ACTION); mLocalReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { Toast.makeText(getApplicationContext(), \"本地广播接收到\", Toast.LENGTH_SHORT).show(); } }; instance.registerReceiver(mLocalReceiver, intentFilter); } // 发送本地广播 findViewById(R.id.btn_send).setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { LocalBroadcastManager instance = LocalBroadcastManager.getInstance(getApplicationContext()); // 上面定义的通电状态action Intent intent = new Intent(LOCAL_BROADCAST_ACTION); instance.sendBroadcast(intent); } }); 在应用程序内部使用本地广播来广播消息和状态也非常方便. 本地广播比标准的全局广播更高效和安全, 因为它不会把数据泄露给其他应用程序. 切记要和正常的接收器一样, 在对应的方法中要移除注册, 否则可能会有内存泄漏. ","date":"2016-09-29","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9806-%E9%87%8D%E8%AF%86-broadcastreceiver/:1:1","tags":["android","笔记"],"title":"《Android 编程实战》06-重识 BroadcastReceiver","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9806-%E9%87%8D%E8%AF%86-broadcastreceiver/"},{"categories":null,"content":"普通广播和粘性广播 广播分为两种类型: 普通广播和有序广播. 普通广播会以异步方式发送给所有的接收者, 并且没有指定的接收顺序. 该方式更加高效, 但是缺少有序广播额一些高级功能, 比如不能发送结果反馈. 有序广播按照特定的顺序分发, 每次只发给一个接收者, 开发者可以在清单文件中设置接收者的intent-filter标签的android:priority属性来控制广播的接收顺序. 有序广播还有另外一个特性: 通过使用abortBroadcast(), setResultCode()和setResultData()方法, 接收者可以把结果回传给广播, 或者终止广播的分发, 这样Intent就不会传递给下一个广播接收者. 有序广播由Context.sendOrderedBroadcast()发起, 在接收者的onReceive()回调中, 通过isOrderedBroadcast()来判断该广播是否是有序广播. 如果是, 可以通过上面setXxxx()方法设置要传递下去的数据. 日常开发很少需要在自己的应用程序发送有序广播, 但如果要跟其他应用程序通信(比如插件), 有序广播就有用途. 在Android系统中, 有序广播最常见的场景就是监听传入的短信(隐藏API)的一部分. 后面篇幅会说. ","date":"2016-09-29","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9806-%E9%87%8D%E8%AF%86-broadcastreceiver/:1:2","tags":["android","笔记"],"title":"《Android 编程实战》06-重识 BroadcastReceiver","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9806-%E9%87%8D%E8%AF%86-broadcastreceiver/"},{"categories":null,"content":"粘性广播 粘性广播(sticky broadcast) 是一个普通广播的变体, 它和普通广播有细微的区别. 粘性广播在使用Context.sendStickyBroadcast()发送Intent之后, 该Intent还会\"继续保留\", 允许之后匹配由该Intent新注册的广播接收者, 并发送Intent.(查看验证代码) 粘性广播的一个例子是Intent.ACTION_BATTERY_CHANGED, 它用来指示设备中电池电量的变化. 另一个列子是Intent.ACTION_DOCK_EVENT, 用来只是设备是否放在了底座. 更多的粘性广播请参考google文档. 下面的代码展示如何 private void myRegisterBattery(){ // 构建广播接收者要接收的action IntentFilter intent = new IntentFilter(); intent.addAction(Intent.ACTION_BATTERY_CHANGED); intent.addAction(Intent.ACTION_BATTERY_OKAY); intent.addAction(Intent.ACTION_BATTERY_LOW); // 创建监听 BroadcastReceiver broadcastReceiver = new BroadcastReceiver() { @Override public void onReceive(Context context, Intent intent) { if (isInitialStickyBroadcast()) { Log.e(\"sususu\", \"这是一个粘性广播\"); } else { Log.e(\"sususu\", \"这是不是粘性广播\"); } } }; // 注册接收者 registerReceiver(broadcastReceiver, intent); } 该方法在广播全系统的状态时特别有用, 如果你需要发送粘性广播, 那么请添加权限在清单文件中\u003cuses-permission android:name=\"android.permission.BROADCAST_STICKY\"/\u003e权限, 并使用Context.sendStickyBroadcast()发送粘性广播. 对于粘性广播一定要慎用, 因为它比普通广播更消耗资源. ","date":"2016-09-29","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9806-%E9%87%8D%E8%AF%86-broadcastreceiver/:1:3","tags":["android","笔记"],"title":"《Android 编程实战》06-重识 BroadcastReceiver","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9806-%E9%87%8D%E8%AF%86-broadcastreceiver/"},{"categories":null,"content":"定向广播 普通广播的另一个变体是定向广播(directed broadcast). 定向广播使用过了intent-filter的一个特性, 通过在Intent设置ComponentName来显示指定接收者. 它把注册接收者的类名和包名结合在了一起. 如下: Intent intent = new Intent(); intent.setComponent(new Component(packName, className)); sendBroadcast(intent); 这个例子只会指定的class类的广播接收者才可以收到广播, 即便其他接收器也注册了相同的Intent操作. 注意:使用定向广播需要同时知道接收者的包名和类名.. 使用场景很少. ","date":"2016-09-29","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9806-%E9%87%8D%E8%AF%86-broadcastreceiver/:1:4","tags":["android","笔记"],"title":"《Android 编程实战》06-重识 BroadcastReceiver","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9806-%E9%87%8D%E8%AF%86-broadcastreceiver/"},{"categories":null,"content":"启动和禁用广播接收器 如果广播接收者在清单文件中注册的, 还有另外一种减少对系统负载的影响的方法. 通过PackageManager, 开发者可以启动和禁用应用程序的组件, 这在用户比如在应用设置更改后使用此方法即可. 代码如下: /** * 设置组件 * @param setClass 要设置改变的组件 * @param isEnable true为启用, false为禁用 */ public void setComponentEnable(boolean isEnable, Class setClass){ PackageManager pm = getPackageManager(); // 构建要改变组件的Component ComponentName componentName = new ComponentName(getApplicationContext(), setClass); pm.setComponentEnabledSetting(componentName, isEnable ? PackageManager.COMPONENT_ENABLED_STATE_ENABLED : PackageManager.COMPONENT_ENABLED_STATE_DISABLED, PackageManager.DONT_KILL_APP); } 记住, 这里仅适用静态注册就是清单文件上注册, 不支持动态注册的会抛出异常, 并且这里接收的class同样适用于Activity, Service, ContentProvider. 其本质就是改变在清单文件中组件标签的\u003candroid:enable='true/false'\u003e. 关于setComponentEnabledSetting()方法的最后一个参数PackageManager.DONT_KILL_APP的使用. 这回防止平台杀死应用, 如果不设置该值平台默认会杀死应用. 可以用在应用程序启动图标的切换, 比如,开发者可以在安装应用程序后只显示设置Activity界面, 在设置完成之后使用该方法把启动图标隐藏 ","date":"2016-09-29","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9806-%E9%87%8D%E8%AF%86-broadcastreceiver/:1:5","tags":["android","笔记"],"title":"《Android 编程实战》06-重识 BroadcastReceiver","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9806-%E9%87%8D%E8%AF%86-broadcastreceiver/"},{"categories":null,"content":"系统广播Intent Android API定义了许多不同的系统广播事件. 例如电池电量变化, 是否连接了设备电源. 并且还有一些可能会用到的广播, 但是action并没有在API中公开, 所以后面的篇幅也会对一些隐藏的API进行一定记录.这里说一下常用的系统事件 自动启动应用程序 关于自启动这个问题在国内比较蛋疼, 由于各种厂商对ROM的修改, 各式各样. 目前为我自己的实验是只有Google Nexus4可以直接声明BOOT_complete重启的广播, 魅族4,三星S6都无法做到重启可以监听到重启广播. 需要对应用通过手机提供的应用管理, 把自启动开启才可以达到预期的效果. 这里尝试的做法是注册监听重启广播的接收, 添加权限\u003cuses-permission android:name=\"android.permission.RECEIVE_BOOT_COMPLETED\"/\u003e, 添加\u003cmanifest\u003e标签的内属性android:installLocation=\"internalOnly\"确保应用正确安装到内存储位置. 广播的监听的对应action:android.intent.action.BOOT_COMPLETED 还有一个应用程序包替换的时候的广播, 例如升级android.intent.action.MY_PACKAGE_REPLACED 用户状态和屏幕状态 虽然当按下关机键和锁屏键会触发屏幕熄灭, Activity会调用对应的焦点失去或者获取的回调. 但是如果服务Service需要注意此动作的时候, 我们通过屏幕的状态广播来监听这是很方便的. 相关广播action action.intent.action.SCREEN_OFF action.intent.action.SCREEN_ON action.intent.action.SCREEN_PRESENT 开启和关闭设备屏幕时, 系统会分别发送Intent.ACTION_SCREEN_ON和Intent.ACTION_OFF广播事件. 当用户解锁屏幕时系统会发送Intent.ACTION_USER_PRESENT广播事件. 网络和连接变化 大多数Android设备都支持两种类型的网络: 蜂窝网络和Wi-Fi网络. 如果应用程序过度依赖网络操作, 开发者可能要在蜂窝网络中推迟数据的传输, 知道设备连接到Wi-Fi网络; 否则, 如果使用3G, LTE之类的移动网络传输可能会产生相当可观的流量. 连接的相关广播和网络相关的广播分别由不同的API负责. 每当有通用的网络连接变化发生时, 比如从Wi-Fi切换到移动数据, 系统就会发送ConnectivityManager.CONNECTIVITY_ACTION广播, 接下来可以使用Context.getService()方法来检索ConnectivityManager服务, 它允许开发者获取当前网络的更多信息. 然而, 要获取当前网络更细粒度的信息, 开发者还需要监听来自TelephonyManager和WifiManager的广播事件. TelephonyManager允许查询移动数据连接的类型, WiFiManager允许检索WiFi连接状态并访问和WiFi相关的不同ID(SSID是wifi名称和BSSID对应mac地址) 以下代码会检测设备是否连接到了预先设置的某一个WiFi. 使用此方法可以有效地和服务器或者只是支持特定的Wi-Fi的媒体进行通信. \u003c!-- 检查wifi广播--\u003e \u003creceiver android:name=\"broadcast.CheckForHomeWifi\"\u003e \u003cintent-filter\u003e \u003c!--监听wifi的连接状态是否连接上一个有效无线路由--\u003e \u003caction android:name=\"android.net.wifi.WIFI_STATE_CHANGED\" /\u003e \u003c!--监听wifi的打开和关闭, 和wifi具体的连接不关心--\u003e \u003caction android:name=\"android.net.wifi.STATE_CHANGE\" /\u003e \u003c/intent-filter\u003e \u003c/receiver\u003e 如果只需要关心wifi的开启, 和wifi连接到某一个路由, 那么这两个广播监听足够了. @Override public void onReceive(Context context, Intent intent) { // 需要判断的路由名字 对应ssid String name = \"\\\"ziroom502\\\"\"; // 1.首先判断wifi是否开启, 并连接 NetworkInfo networkInfo = intent.getParcelableExtra(WifiManager.EXTRA_NETWORK_INFO); if (networkInfo != null \u0026\u0026 networkInfo.getState().equals(NetworkInfo.State.CONNECTED)) { // 2.再判断连接的wifi的具体信息 WifiInfo WifiInfo = intent.getParcelableExtra(WifiManager.EXTRA_WIFI_INFO); if (WifiInfo != null \u0026\u0026 name.equals(WifiInfo.getSSID())) { Log.d(\"sususu\", \"连接到指定wifi\"); } else { Log.d(\"sususu\", \"连接到其他wifi\"); } } } 这是一个简单的初步判断, 如果需要结合手机连接判断, 结合下面的另一个监听, 整合起来就差不多了. 这个监听来自ConnectivityManager的变化, 并确定当前连接的是否为移动数据网络. 如果收到移动数据, 接下来在使用TelephonyManager检查是否在使用3G或者LTE网络. 监听广播的清单文件 \u003c!--判断手机连接--\u003e \u003creceiver android:name=\"broadcast.WhenOn3GorLTE\"\u003e \u003cintent-filter\u003e \u003c!--此广播监听, 网络连接的设置包括wifi和数据的打开和关闭--\u003e \u003caction android:name=\"android.net.conn.CONNECTIVITY_CHANGE\" /\u003e \u003c/intent-filter\u003e \u003c/receiver\u003e public class WhenOn3GorLTE extends BroadcastReceiver { private static final String TAG = WhenOn3GorLTE.class.getSimpleName(); @Override public void onReceive(Context context, Intent intent) { String action = intent.getAction(); if (ConnectivityManager.CONNECTIVITY_ACTION.equals(action)){ boolean noConnectivity = intent.getBooleanExtra(ConnectivityManager.EXTRA_NO_CONNECTIVITY, false); if (noConnectivity){ Log.e(TAG, \"没有连接\" ); }else{ int networkType = intent.getIntExtra(ConnectivityManager.EXTRA_NETWORK_TYPE, ConnectivityManager.TYPE_DUMMY); if (networkType == ConnectivityManager.TYPE_MOBILE){ checkfor3GorLte(context); }else{ Log.i(TAG, \"不是移动连接\"); } } } } /** * 当前如果移动数据开启, 那么显示出移动数据的连接类型 */ private void checkfor3GorLte(Context context){ TelephonyManager telephonyManager = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE); switch (telephonyManager.getNetworkType()){ case TelephonyManager.NETWORK_TYPE_HSDPA: Log.d(TAG, \"连接类型: NETWORK_TYPE_HSDPA\"); break; case TelephonyManager.NETWORK_TYPE_HSPA: Log.d(TAG, \"连接类型: NETWORK_TYPE_HSPA\"); break; case TelephonyManager.NETWORK_TYPE_HSPAP: Log.d(TAG, \"连接类型: NETWORK_TYPE_HSPAP\"); break; case TelephonyManager.NETWORK_TYPE_HSUPA: Log.d(TAG, \"连接类型: NETWORK_TYPE_HSUPA\"); break; case TelephonyManager.NETWORK_","date":"2016-09-29","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9806-%E9%87%8D%E8%AF%86-broadcastreceiver/:1:6","tags":["android","笔记"],"title":"《Android 编程实战》06-重识 BroadcastReceiver","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9806-%E9%87%8D%E8%AF%86-broadcastreceiver/"},{"categories":null,"content":" 阅读《Android 编程实战》一书的抄书笔记 –\u003e 对应书籍第7章 ","date":"2016-09-28","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9805-%E9%87%8D%E8%AF%86-ipc/:0:0","tags":["android","笔记"],"title":"《Android 编程实战》05-重识 IPC","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9805-%E9%87%8D%E8%AF%86-ipc/"},{"categories":null,"content":"Binder简介 Android有一个强大的功能, 就是能够在不同应用程序之间进行通信. 绝大部分的实现都是由Binder IPC(Inter-Process Communication)进行处理的. Android中的Binder有着悠久的历史. 最终它的名字叫做OpenBinder, 是Be公司开发的Be操作系统(BeOS). 后来被移植到Android平台, 并且进行了重写以支持应用程序间的IPC. 基本上Binder提供了在不同执行环境间绑定功能和数据的特性. Binder非常适合在Android应用程序间进行通信, 因为每个Android应用程序都运行在自己的Dalvik虚拟机里, 而每个虚拟机又是独立的运行环境. 在2009年, Linux社区就谷歌选择Binder而非选择dbus的原因有过很长时间的争论, 因为在此之前Linux内核一直使用dbus来实现IPC机制. 最开始开发Android时, Binder成了IPC的最佳选择, 如今它已成为Android系统的一个组成成分. Linux中的dbus机制也用在许多的Android设备上, 特别是为无线接口层(Radio Interface Layer, RIL)通信以及Android 4.3以后的蓝牙通信. 但大部分IPC还是Binder. 使用Binder IPC进行通信时, 两个应用程序使用内核驱动来传递消息(如下图), 除了发送消息, Binder还提供了其他功能, 比如识别远程调用者(进程ID和用户ID), 以及当远程进程被烧死(link-to-death)时发送通知. 例如, 当系统Service(通过WindowManager管理Android所有窗口)为每个应用保持一个Binder引用时会调用这些附加函数, 当应用窗口关闭时会收到link-to-death通知. Binder通信遵循客户端-服务端模式, 客户端使用客户端代理来处理与内核驱动程序的通信. 在服务器端, Binder框架维护了一系列Binder线程. 内核驱动会使用服务端的Binder线程把消息从客户端代理分发个接收对象. 这一点需要特别注意, 因为当通过Binder接收Service调用时, 他们并不会运行在应用程序的主线程上, 这样一来, 客户端连接远程Service的连接就不会阻塞应用的主线程. ","date":"2016-09-28","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9805-%E9%87%8D%E8%AF%86-ipc/:1:0","tags":["android","笔记"],"title":"《Android 编程实战》05-重识 IPC","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9805-%E9%87%8D%E8%AF%86-ipc/"},{"categories":null,"content":"Binder地址 使用Binder通信时, 客户端需要知道远程Binder对象的地址. 然而, Binder的设计要求只有实现类(比如要调用的Service)才知道该地址. 开发者使用Intent解析来进行寻址. 客户端使用action 字符串或者组件名(componentName)来构造Intent对象, 然后使用它初始化于远程应用程序的通信. Intent只是实际Binder地址的抽象描述, 为了能够建立通信, 还需要翻译成实际的地址. ServiceManager是一个特殊的Binder节点, 它运行在Android系统服务内, 管理所有的地址解析, 是唯一一个有全局地址的Binder节点. 因为所有的Android组件都是用Binder进行通信, 所以它们需要使用ServiceManager进行注册. 客户端要想和Service或者其他组件进行通信, 需隐式地通过Intent查询ServiceManager来接收Binder地址. ","date":"2016-09-28","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9805-%E9%87%8D%E8%AF%86-ipc/:1:1","tags":["android","笔记"],"title":"《Android 编程实战》05-重识 IPC","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9805-%E9%87%8D%E8%AF%86-ipc/"},{"categories":null,"content":"Binder事务 在Android中, **事务(transaction)**是指一个进程发送数据到另一个进程. 在Binder上开启事务首先会在客户端调用IBinder,transact(), 然后Service收到Binder.onTranscat()方法回调. 如下演示了在客户端如何使用IBinder引用向服务端执行自定义的Binder事务 public String performCustomBinderTransaction(IBinder binder, String arg0, int arg1) throws RemoteException { Parcel request = Parcel.obtain(); Parcel response = Parcel.obtain(); // 组装请求数据, 要发送到服务端的 request.writeString(arg0); request.writeInt(arg1); // 执行事务 binder.transact(IBinder.FIRST_CALL_TRANSACTION, request, response, 0); // 从响应中读取结果 String result = response.readString(); // 释放资源, 以便循环利用 request.recycle(); response.recycle(); return result; } 而服务端会实现一个继承Binder类, 通过onTransact()来接收客户端的数据, 如下 public class ServerBinder extends Binder { @Override protected boolean onTransact(int code, Parcel data, Parcel reply, int flags) throws RemoteException { // return super.onTransact(code, data, reply, flags); // 开始读取客户端发送的请求数据 String arg0 = data.readString(); int arg1 = data.readInt(); // 处理接收结果, 并生成返回的数据 String result = buildResult(arg0, arg1); // 把结果写入想用Parcel reply.writeString(result); // 成功后返回true return true; } private String buildResult(String arg0, int arg1){ String result = null; // ...这里省略业务逻辑, 以后可自行添加 return result; } } 如上, 因为属于作为远程服务端中实现自定义的Binder对象时没有使用AIDL. 所以这里需要自己处理onTransact()方法. 上面两个代码通过Binder IPC进行的同步双向调用. 也可在客户端执行单项的调用, 只需在客户端发送事务的方法进行相应更改即可, 如IBinder.transact()方法调用中把标识位设置为FLAG_ONEWAY, 这样就可以把第二个Parcel参数设置为null. 单项调用会提供更好的性能, 因为只需对一个Parcel对象进行编解码操作. 当然这里只是让其了解一下流程, 当真正实现进程间通信, 或者提供其他应用调用的API的时候不会直接操作这种底层的方式在两个程序之间执行事务, 而是使用对这种事务进行进一步封装的AIDL或者Messenger等. 而对于更细粒度地控制数据如何应用间发送, 使用底层binder操作事务这是正确的. ","date":"2016-09-28","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9805-%E9%87%8D%E8%AF%86-ipc/:1:2","tags":["android","笔记"],"title":"《Android 编程实战》05-重识 IPC","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9805-%E9%87%8D%E8%AF%86-ipc/"},{"categories":null,"content":"Parcel Binder事务通常会传递事务数据, 这种数据被称为Parcel(包裹). Android中的Parcel和Java SE中序列化对象类似, 不同之处在于, 开发者需要使用Parcelable接口实现对象的编解码工作. 该接口定义了两个编写Parcel对象的方法, 以及一个静态的不可被复写的Creator对象, 该对象用来从Parcel中读取相应的对象. ","date":"2016-09-28","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9805-%E9%87%8D%E8%AF%86-ipc/:1:3","tags":["android","笔记"],"title":"《Android 编程实战》05-重识 IPC","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9805-%E9%87%8D%E8%AF%86-ipc/"},{"categories":null,"content":"link to death Binder的另一个特点, 允许客户端在Service终止的时候收到通知. 这就被称为link to death. Binder的IBinder.linkToDeath()方法实现了该机制. 当客户端在onServiceConnected()方法中收到IBinder对象, 它可以用实现了IBinder.DeathRecipient接口的参数调用linkToDeath()方法. 因为Android可能在资源不足的(RAM)时被系统杀死, 在客户端注册远程被终止的监听通知会很有用. /* * ClassDescription: 无实际意义, 只为演示如何使用IBinder注册link-to-death */ public class LinkToDeathSample extends Service { private static final String TAG = LinkToDeathSample.class.getSimpleName(); /** * 对客户端提供注册方法 */ private void notifyRemoteServiceDeath(IBinder iBinder ){ try { iBinder.linkToDeath(new MyLinkToDeath(), 0); } catch (RemoteException e) { e.printStackTrace(); } } class MyLinkToDeath implements IBinder.DeathRecipient{ @Override public void binderDied() { // 处理远端binder被杀死的情况 } } @Nullable @Override public IBinder onBind(Intent intent) { return null; } } 也可以调用IBinder.pingBinder()检查远端的Binder进程是否处于活动状态. 如果结果为true, 表明远端的进程处于活跃可用的状态. 如果绑定到的是Service那么就不需要监听了, 因为断开连接时总会是伴随着ServiceConnection.onServiceDisconnected()函数被回调. 但是, 如果使用其他方式接受Binder对象, 该方法可能就有用处了. ","date":"2016-09-28","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9805-%E9%87%8D%E8%AF%86-ipc/:1:4","tags":["android","笔记"],"title":"《Android 编程实战》05-重识 IPC","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9805-%E9%87%8D%E8%AF%86-ipc/"},{"categories":null,"content":"设计API 虽然大多数的应用都不需要为第三方应用提供API, 但是说不定哪一天领导就突发奇想的想要这个结果. 可以使用Service或者ContentProvider为第三方应用开发API. 这里先介绍使用Service提供API. 在后续的篇幅会展示如何使用ContentProvider. 当实现API是, 开发者还需要考虑的因素: 是否需要处理并发请求? 每次只处理一个客户端请求是否足够? API是否只包含一个或是很少的操作? 或者是一组更加复杂的方法? 这些问题的答案将决定实现远程API最合适的方法. 另一个问题考虑的细节是否与其他开发者分享该API? 或者只是用于自己的应用? 如果是第一种情况 , 可以考虑构建一个库工程, 使用易于使用的Java API包装客户端的实现. 如果只是自己使用API, 那么可以使用Messenger或者AIDL, 下面我们将针对这两个使用展开. ","date":"2016-09-28","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9805-%E9%87%8D%E8%AF%86-ipc/:2:0","tags":["android","笔记"],"title":"《Android 编程实战》05-重识 IPC","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9805-%E9%87%8D%E8%AF%86-ipc/"},{"categories":null,"content":"AIDL 在软件工程中, 接口定义语言(Interface Definition Language,IDL)已经成为通用的术语. 是用来描述软件组件接口的特定语言. 在Android中, 该IDL被称为Android接口定义语言(AIDL). 它是纯文本文件, 使用Java类似语法编写. 但是, 编写Java接口和编写AIDL文件还有所有不同: 首先, 对所有的非原始数据类型参数, 需要指定如下三种类型方向指示符之一:in, out, inout.in类型方向指示符只用于输入, 客户端不会看到Service对对象的修改. out类型表明输入对象不包含相关的数据, 但会由Service生成相关的数据. inout类型是上面两种类型的结合. 切记只使用需要的类型, 因为每种类型都有相应的消耗. 所有用于通信的自定义都需要创建一个AIDL文件, 用来声明该类实现了Parcelable接口. 整理一下步骤: 首先创建AIDL文件, 为了客户端和服务端后续的使用. 参考链接 注意: 在IMyApiInterfaceV1.aidl文件中对CustomData进行了手动的import导入, 并且当作为参数传递的时候使用了方向指示符,因为只有原始数据类型才不需要方向指示符,因只调用其值.(有一个CustomData在下次参考链接中可以看到, 应该属于这一个步骤的) 然后对客户端服务端进行代码实现. 参考链接. 现在客户端就可以利用Binder调用远程的服务实现的IBinder方法. **注意:**一旦客户端实现了代码, 那么就不要在修改或者移除AIDL文件中的方法. 可以在文件末尾添加新的方法, 因为AIDL编译器会为每一个方法生成标识符, 所以不能修改现存的方法, 否则不能向后兼容老版本. 这个方法使用AIDL的缺点就是如上. 解决方案中的一种方法就是提供Java包装类, 并以库工程或者.jar文件的形式发布一遍使用. 后续会说道. 现在可以考虑是否需要对客户端进行回调. 如果需要,那么相同的步骤创建AIDL接口文件. 并在客户端实现接口文件. 在服务端使用的AIDL文件中添加新的方法, 这个方法用来在服务端注册一个客户端回调. 客户端的回调通过方法的参数传入, 并在客户端获取远程服务端的Binder对象进行注册方法调用.参考链接 关于客户端实现AIDL文件的时候, 在使用了oneway关键字, 这会告诉AIDL编译器该接口只是单向通信. 对调用者(本类中的Service)的响应不是必须的. 这样做会轻微的性能提升. 例如: package com.szysky.note.ipc.aidl; import com.szysky.note.ipc.aidl.CustomData; oneway interface IMyAidlCallback { void onDataUpdated(in CustomData[] data); } 到这里, 说明了两个应用之间传输Binder对象, 而不需要使用ServiceManager注册它. 由于只有客户端和Service知道Binder的地址, 因此它可以作为一种高效的IPC安全机制. ","date":"2016-09-28","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9805-%E9%87%8D%E8%AF%86-ipc/:2:1","tags":["android","笔记"],"title":"《Android 编程实战》05-重识 IPC","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9805-%E9%87%8D%E8%AF%86-ipc/"},{"categories":null,"content":"Messenger 使用Messenger进行远程通信, 有时会更简单, 当然使用场景是Service不需要支持并发操作时就可以选择使用Messenger信使来跨进程通信. Messenger使用Handler执行每个传入的消息, 所有的客户端的调用按顺序运行在同一个线程上. 服务端的实现: 在onCreate()中构建Messenger, 然后在onBind()中返回Binder对象. 当Messenger接收到消息的时候, 它可以使用在replyTo成员变量里的Messenger对象响应客户端都请求.参考链接 客户端的实现: 为了可以在服务端响应回来数据, 在onCreate()方法中, 同样构建一个Messenger作为客户端的信使. 然后在onResume()进行服务绑定, 在ServiceConnection#onServiceConnected()回调中通过获取的IBinder来还原出服务端的Messenger. 然后就可以调用其send(Message)方法向远程发送消息. 当然参数中的Message需要新建一个. 如果要做到回应客户端那么使用Message.replyTo=本地Messenger实例, 这样就可以在客户端构建的Messenger时传入的Handler.callback()接收处理.参考链接 这种方法和IntentServiec很相似, 但本例没有使用Intent, 而是使用Message触发Handler的操作. 此外, Messenger实现异步通信很方便, 并且也不需要使用BroadcastReceiver. ","date":"2016-09-28","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9805-%E9%87%8D%E8%AF%86-ipc/:2:2","tags":["android","笔记"],"title":"《Android 编程实战》05-重识 IPC","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9805-%E9%87%8D%E8%AF%86-ipc/"},{"categories":null,"content":" 阅读《Android 编程实战》一书的抄书笔记 –\u003e 对应书籍第五,六章 ","date":"2016-09-26","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9804-%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C-service/:0:0","tags":["android","笔记"],"title":"《Android 编程实战》04-手势操作进阶, 重识Service","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9804-%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C-service/"},{"categories":null,"content":"设计自定义视图 ","date":"2016-09-26","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9804-%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C-service/:1:0","tags":["android","笔记"],"title":"《Android 编程实战》04-手势操作进阶, 重识Service","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9804-%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C-service/"},{"categories":null,"content":"View的声明周期 View也有自己的声明周期. 该生命周期并不直接和展示它的Fragment或者Activity相连, 相反它和显示它的窗口状态以及渲染循环相关 当视图被添加到View层级结构中时, 第一个被回调的函数是View.onAttachedToWindow(), 这标志着它现在可以加载所需的资源了. 构建自定义视图时, 开发者应该重载该方法, 并在该方法中加载所有资源并初始化视图所需的依赖. 基本上所有的耗时的初始化都应该放在这个方法内. 还要一个匹配的回调名为View.onDetachedFromWindow(), 从View层次结构中移除视图时调用这个方法. 在这里需要关注的是需要显示清理的操作, 比如所有被加载的资源, 启动的Service, 或者其他依赖. 视图被添加到View层次结构中之后, 它会经过一个循环, 该循环首先计算动画, 接下来会一次回调View.onMeasure(), View.onLayout(), View.onDraw()等方法. ","date":"2016-09-26","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9804-%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C-service/:1:1","tags":["android","笔记"],"title":"《Android 编程实战》04-手势操作进阶, 重识Service","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9804-%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C-service/"},{"categories":null,"content":"多点触控 先看下图效果: 贴一下实现的主要代码: @Override protected void onDraw(final Canvas canvas) { super.onDraw(canvas); // 绘制已经完成过的手势事件的所有path路径 // 如果不循环绘制, 那么当一个触控点到达了up事件之后, 那么这个触控点从down到up的事件的轨迹将会消失. for (Path completedPath : mCompletedPaths) { canvas.drawPath(completedPath, mFingerPaint); } // 绘制当前触摸屏上的触摸事件正在进行的轨迹 (down ~ up) for (Path fingerPath : mFingerPaths) { if (fingerPath != null){ canvas.drawPath(fingerPath, mFingerPaint); } } } @Override public boolean onTouchEvent(MotionEvent event) { // 获得当前触摸屏上的触摸个数 int pointerCount = event.getPointerCount(); int cappedPointerCount = pointerCount \u003e MAX_FINGERS ? MAX_FINGERS : pointerCount; // 获得当前触摸事件对象所在系统保存队列中的位置 int actionIndex = event.getActionIndex(); // 获得当前触摸事件的动作类型, 这里包括 MotionEvent.ACTION_POINTER_DOWN, MotionEvent.ACTION_POINTER_UP 多点触控按下和多点触控抬起(对应数值5, 6) int action = event.getActionMasked(); // 此值返回此触摸事件存在时刻的唯一标识id. int pointerId = event.getPointerId(actionIndex); // 检查是否收到按下或者抬起的动作 if ((action == MotionEvent.ACTION_DOWN || action == MotionEvent.ACTION_POINTER_DOWN) \u0026\u0026 pointerId \u003c MAX_FINGERS ){ // 当有新的触摸事件开始的时候, 就使用这个事件的标识id来当下标创建一个Path对象存储起来 mFingerPaths[pointerId] = new Path(); // 注意虽然在down事件中, actionIndex和pointerId会保持一致, 但最好使用触摸事件所在的队列位置来获取坐标 mFingerPaths[pointerId].moveTo(event.getX(actionIndex), event.getY(actionIndex)); }else if ((action == MotionEvent.ACTION_UP || action == MotionEvent.ACTION_POINTER_UP) \u0026\u0026 pointerId \u003c MAX_FINGERS){ // 这里的pointerId和actionIndex不一定保持一致!! 所以一定要正确使用这个两个来获取 mFingerPaths[pointerId].setLastPoint(event.getX(actionIndex), event.getY(actionIndex)); mCompletedPaths.add(mFingerPaths[pointerId]); mFingerPaths[pointerId].computeBounds(mPathBounds, true); invalidate((int) mPathBounds.left, (int) mPathBounds.top, (int) mPathBounds.right, (int) mPathBounds.bottom); mFingerPaths[pointerId] = null; } int tempIndex = 0; // 这里主要是move事件时候进行的动态绘制实现 for (int i = 0; i \u003c cappedPointerCount; i++) { // 保证滑动事件不丢失 while(mFingerPaths[tempIndex] == null){ tempIndex++; if (tempIndex \u003e 4){ return true; } } if (mFingerPaths[tempIndex] != null){ // 通过数组的下标也就是触摸事件的唯一标识id获得队列中的位置 int index = event.findPointerIndex(tempIndex); // 对从down事件或者上一次移动事件的Path进行lineTo移动. mFingerPaths[tempIndex].lineTo(event.getX(index), event.getY(index)); mFingerPaths[tempIndex].computeBounds(mPathBounds, true); invalidate((int) mPathBounds.left, (int) mPathBounds.top, (int) mPathBounds.right, (int) mPathBounds.bottom); tempIndex++; } } } 以上是伪代码, 如果想需要完整类,点击此链接到github查看 这里在进行解释说明一下: 每次时间发生改变的时候onTouchEvent(MotionEvent)都会被回调. 并且MotionEvent会保存当前时间点的所有触摸点的事件. 举例一个场景: 当三个手指同时按下 首先系统内部有一个保存当前多点触摸事件的集合,由于跟进源码后发现方法调用的是本地方法,所以只能从出现的规律可以反推出这个集合应该是一个队列.从以下结果也可以看出. 虽然三个手指同时按下, 但是会依次触发onTouchEvent()回调. 也就是说会走三遍此回调. 当第一个触摸事件发生down时. 系统会创建保存一个事件对象并给这个对象的pointerID赋一个0的值并放到队列的首部, 这时当多点触控的第二个触摸事件按下的时候. 系统会遍历队列中的触摸事件的pointerID,如果队列第一个对象的pointerID不等于0那么就插入在这个对象的头部,如果等于继续下一个元素,如果下一个对象的pointerID为1(就是顺序递增的效果)那就继续遍历下一个元素,如果不是那就插入到这个元素也就是第二个元素对象的首部, 依次类推. 当插入后, 插入元素的所在队列的位置当做第二个触控点事件的pointerID; 当第三个多点触控发生时, 还是会重复上面的插入规则, 这个时候会遍历到已经存在的两个触摸对象其pointerID是从0开始的递增,所以这个触摸事件放到这个队列的尾部, 也就是第三个触控事件的pointerID=3. 这也就是同一个时间段,不会存在相同的pointerID的原因 为什么要这么麻烦的说这个? 因为当多点触控的时候不弄仅通过getX()或者getY()来取得最后一个坐标点,这个方法只是返回这个队列中的第一个元素的坐标点, 而处理多点的时候我们应该知道具体是队列总的哪一个事件触发并获取其值需要getActionIndex()获得触发事件对象的位置,然后通过getX(actionIndex)才能获取真正的发生变化的触摸点, 而且我们自己在本地记录的出现过得Path路径轨迹进行存储整理. 所以我们需要一个唯一标示来区分不同的触控点进行后续的操作 而获取这个触控的事件的队列虽然在插入的时候会保证返回的所在队列的位置和其pointerID一致, 但是在连续抬起事件队列删除的元素时候有序队列元素的位置会变化, 就会导致这两个值有所不同, 请看下图 上图和实现代码中有一个getActionIndex()获得的ActionIndex的int值.这个值表示触发事件对象所在系统保存的所有还在运行的事件的队列的位置. 当我们知道是一个队列的时候规律也就不难推出move事件的时候, 此值不会发生改变. 但是当down和up事件的时候会动态变化. 因为队列前面元素的变化会导致后边的元素. 这里可能我说的有点啰嗦, 如果看不懂解释可以去上面的连接地址down下代码, 观察输出日志即可. Android中的MotionEvent类是所有pointer相关的操作的核心类, pointer意味着手指, 手写笔, 电脑鼠标或者一个外部的触摸板. ","date":"2016-09-26","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9804-%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C-service/:1:2","tags":["android","笔记"],"title":"《Android 编程实战》04-手势操作进阶, 重识Service","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9804-%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C-service/"},{"categories":null,"content":"PointerCoordinates 这个知识点只做了解, 因为关于触摸压力值并不是真正的支持, 有的是由按下面积和或者获得的值就是恒定的. MotionEvent对象包含pointer的所有信息. 不同类型的的输入设备, 手指, 鼠标等都能生成pointer, 所以MotionEvent不仅包含x,y坐标. Android API支持所有Linux内核定义的输入设备. 因为不同设备的输入参数可能不同, 所以pointer被设计成有多个坐标轴. 最常用的就是坐标轴xy. 但也有描述其他信息的坐标轴, 比如压力, 距离, 方向等. 另外MotionEvent类不仅支持生成pointer坐标的输入设备, 还支持游戏控制相关的坐标轴信息以及诸如节流阀, 方向舵, 倾斜, 滚轮之类的输入来源. ","date":"2016-09-26","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9804-%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C-service/:1:3","tags":["android","笔记"],"title":"《Android 编程实战》04-手势操作进阶, 重识Service","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9804-%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C-service/"},{"categories":null,"content":"旋转手势 Android API中有两个工具类能帮助开发者检测各种手势, GestureDetector类和ScaleGestureDetector类. 第一个类支持一些简单的触控手势: 比如长按, 双击, 快速滑动. 第二个类能检测类似于地图所用的双指缩放手势, 以及图片的放大手势等. 类似这样的效果: 代码就不贴了, 有兴趣类链接地址 ","date":"2016-09-26","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9804-%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C-service/:1:4","tags":["android","笔记"],"title":"《Android 编程实战》04-手势操作进阶, 重识Service","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9804-%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C-service/"},{"categories":null,"content":"OpenGL ES 虽然可以使用SDK提供的部件, 或者使用自定义的视图来构建大部分的Android应用, 但有时需要更底层和更高性能的图形API. 主要用于游戏. OpenGL ES(嵌入式子系统)很适合. Android系统最高支持OpenGL ES 3.0版本主要取决于硬件和android版本. Android 4.3支持最新的3.0标准. Android已经在标准UI框架中使用OpenGL ES 2.0来启动硬件加速, 但是并没有对开发者开放. 而3.0完全向后兼容2.0的. 所以如果使用3.0可以放心使用. 如果想要了解Android上的OpenGl, 可以在官网,这里跳转到Google介绍openGL ","date":"2016-09-26","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9804-%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C-service/:1:5","tags":["android","笔记"],"title":"《Android 编程实战》04-手势操作进阶, 重识Service","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9804-%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C-service/"},{"categories":null,"content":"重识Service ","date":"2016-09-26","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9804-%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C-service/:2:0","tags":["android","笔记"],"title":"《Android 编程实战》04-手势操作进阶, 重识Service","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9804-%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C-service/"},{"categories":null,"content":"何时并如何使用Service Android文档关于Service组件的描述如下: Service组件表示在不影响用户的情况下执行耗时的操作或者提供给其他应用使用的功能. 即使使用Service还是需要把耗时的任务放到一个独立的线程中, 那为什么还有服务的出现? 因为Service和Activity有着不同的生命周期, 对比起来Service更适合管理耗时的操作. 那么耗时操作的定义, 其实建议把所有和用户界面无关的操作都放到后台线程去执行. 因为UI线程需要保持高度响应来与用户进行交互. 所以应尽可能排除掉一切可以不影响用户界面响应速度的操作. ","date":"2016-09-26","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9804-%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C-service/:2:1","tags":["android","笔记"],"title":"《Android 编程实战》04-手势操作进阶, 重识Service","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9804-%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C-service/"},{"categories":null,"content":"Service类型 用来执行和用户输入无关的操作. 例如音乐播放器能够在用户从前台退出应用的情况下还能继续播放音乐. 或者例如即时通讯应用, 在用户退出前它要一直保持运行并接收消息. 直接由用户触发 比如照片共享应用, 用户拍完照后, 应用使用Intent把照片发送给Service(更准确地说是使用指向本地的Uri). 接下来Service启动并解析Intent里的数据, 最后在后台线程中上传该照片. 当操作完成后系统会自动停止Service. ","date":"2016-09-26","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9804-%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C-service/:2:2","tags":["android","笔记"],"title":"《Android 编程实战》04-手势操作进阶, 重识Service","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9804-%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C-service/"},{"categories":null,"content":"Service的创建和销毁 service有两个必定会调用的生命回调周期onCreate()和onDestroy() onCreate():做一些初始化例如初始化新的Handler对象, 获取系统服务, 注册广播, 以及执行service操作需要的其他初始化工作. 请注意这个生命周期可是运行主线程的,如果要执行耗时操作需要使用AsyncTask,Handler等方法 onDestroy():所有的清理工作都应该在onDestroy()方法完成, 特别的, 需要停止所有已经启动的HandlerThread对象, 并且注销之前注册的广播. 同样, 此回调也是运行在主线程中, 所以清理工作同样放在单独线程. ","date":"2016-09-26","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9804-%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C-service/:2:3","tags":["android","笔记"],"title":"《Android 编程实战》04-手势操作进阶, 重识Service","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9804-%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C-service/"},{"categories":null,"content":"启动Service Service的启动方式有两种: 通过Content.startService()或者Content.bindService(). 这里先说startService()方法: 当以启动模式打开Service时, 参数中的Intent必须匹配Service定义的intent-filter. (也可以显示地使用Service的ComponentName而不再定义intent-filter). 该方法不提供任何对Service()的引用, 但它在执行基于消息的触发操作方面很有用. 该方法适合执行由用户触发并且运行时间不确定的操作, 比如上传照片或者向服务器发送状态更新. 它在为其他应用提供简单的接口方便也很有用. 当时用启动模式打开服务的时候, Service#onStartCommand()方法会被调用, 并收到发送给Service的Intent. 该方法返回一个整型常量, 用来告诉系统如何处理Service的重启操作. 这是Service比较复杂的部分, 所以最起码要记住以下三种返回值(真正返回不止3种): START_STICKY: 代表当系统由于某些原因关闭Service时(通常是由于内存不足). Service会被重新启动. 然而当系统重新启动Service时, onStartCommand()参数中的Intent会被置为null, 请注意这一点. 使用START_STICKY返回值的一个典型例子就是音乐播放器. START_NOT_STICKY: 表示Service不会再系统关闭之后重新启动. 这在使用Service执行一次性操作的时候特别有用, 比如上传的东西到服务器. 如果Service在完成任务前就被系统关闭了, 它不应该再尝试重复之前的操作. START_REDELIVER_INTENT: 它和START_STICKY基本一样, 不过当系统重启Service时, onStartCommand()会收到Service被销毁之前接收到的最后一个intent. 接着说onStartCommand()这个回调方法的一共有三个返回值: intent: 根据前面讲解返回值的时候可以看出在某些特定情况下, 该参数可能会为null. 标志位: 标识本次启动请求, 可能的值为0, START_FLAG_RETRY, START_FLAG_REDELIVERY. startId: 如果多次调用onStartCommand()且需要安全地停止Service, 此参数会有用. ","date":"2016-09-26","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9804-%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C-service/:2:4","tags":["android","笔记"],"title":"《Android 编程实战》04-手势操作进阶, 重识Service","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9804-%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C-service/"},{"categories":null,"content":"绑定Service 绑定模式这是使用Content.bindService(). 被绑定的Service会一直运行, 知道所有绑定的客户端都断开后才会停止. 在同一个应用进程中绑定Service只需获取Service对象的的引用, 并调用对象相应的方法即可. 这种方式成为本地binder. 如下代码: 只贴出核心代码: /** * 实现一个bindService模式的, 简单演示方法被调用的服务类 */ public class LocalService extends Service { public void doBackgroundOperation(){ Toast.makeText(getApplicationContext(), \"定义服务方法被调用\", Toast.LENGTH_SHORT).show(); } @Override public IBinder onBind(Intent intent) { return new LocalBinder(); } public class LocalBinder extends Binder{ public LocalService getService(){ return LocalService.this; } } } // 在Activity中进行强转即可 serviceConnection = new ServiceConnection() { @Override public void onServiceConnected(ComponentName name, IBinder service) { mService = ((LocalService.LocalBinder)service).getService(); // 通过mService就可以调用服务的内部方法, 注意这只是在应用内部, 不可以跨进程 } @Override public void onServiceDisconnected(ComponentName name) { mService = null; } }; ","date":"2016-09-26","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9804-%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C-service/:2:5","tags":["android","笔记"],"title":"《Android 编程实战》04-手势操作进阶, 重识Service","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9804-%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C-service/"},{"categories":null,"content":"保持活跃 当服务已经启动, 并且应用程序在前台运行(当前正在展示应用的某个Activity), 那么该Service会是最后一个被杀死. 然而一旦用户离开了发起服务的应用, 那么此服务也就不再是前台应用, 有可能会被杀死. 所以如果需要在应用不处于前台活动状态下仍然保持Service在前台运行, 则可以调用Service.startForeground(). (当应用程序更新可以使用Notification通知配合服务来完成) 系统会试图尽可能长地保持Service处于活动和运行状态. 只有当资源耗尽, 通常是没有足够内存(RAM), 才有可能会去停止Service. 当是我们应该在开发中假设这种情况会随时发生. ","date":"2016-09-26","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9804-%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C-service/:2:6","tags":["android","笔记"],"title":"《Android 编程实战》04-手势操作进阶, 重识Service","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9804-%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C-service/"},{"categories":null,"content":"停止服务Service 一旦Service启动, 它会尽可能长时间运行. 根据启动方式的不同, 系统会在系统资源不足杀死Service后重启. 当Service再次启动时, 可能会出现一些意想不到的结果, 所以适当的停止服务就显得很重要. 绑定模式: 此模式下服务会一直运行到没有客户端连接为止. 但有一种例外情况, 即最后连接的客户端调用了Service.startForeground()时还会保持Service的运行, 所以需要在适当的时候调用Service.stopForeground() 启动模式: 只能通过Service.stopSelf()或者Content.stopService()来停止Service. 这标志着需要停止和移除service. 而重新启动Service的唯一方式是显示调用Content.startService()或者Content.bindService(). 注意, 当通过startService()启动服务时, 不管调用多少次onStartCommand()(即调用Content.startService()不会叠加), 调用Service.stopSelf()或者Content.stopSelf()一定会停止服务. ","date":"2016-09-26","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9804-%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C-service/:2:7","tags":["android","笔记"],"title":"《Android 编程实战》04-手势操作进阶, 重识Service","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9804-%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C-service/"},{"categories":null,"content":"后台运行的IntentService 普通的服务的生命周期回调都是触发在主线程上. 如果需要处理耗时操作那么需要把耗时操作移动到一个单独的线程中. IntentService 由于Handler在android中的处理消息的便利, 和Service分离与UI线程无关的代码. 所以google提供了一个名为IntentService的工具类, 它在Service中包装了一个处理后台线程的Handler. 开发者只需要继承该类, 实现onHandlerIntent()方法, 并添加希望Service能够接收的action. onHandlerIntent()方法运行在自己线程, 并不一定是主线程. 并且每次只能处理一个Intent,当处理结束之后服务也就自动关闭. 可以通过不同的action组装成intent, 也可以给intent附加信息, 用以在服务中区分不同的动作请求. 当多次通过startService()调用服务的时候, 每次调用的Intent会被保存到队列中, 所以该类能确保任意时间只会有一个intent会被处理. 知道队列为空, 那么服务也就随之消失. 并行问题 IntentService虽然方便好用, 并且能够顺序处理同一时间内的多个请求. 但是正因为是串行的处理模式, 可能我们有的时候更需要并行更快的处理完成.如果是这样, 那我们就使用线程池来处理. 可以在AsyncTask中使用Executor并行地执行操作. 但是AsyncTask的特点是比较适合执行运行时间至多几面的操作, 如果要执行比较耗时的操作. 可以使用ExecutorService使用Executors.newCacheThreadPool(). ","date":"2016-09-26","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9804-%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C-service/:2:8","tags":["android","笔记"],"title":"《Android 编程实战》04-手势操作进阶, 重识Service","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9804-%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C-service/"},{"categories":null,"content":"对Service的通信 前面记录了何时使用, 如何执行. 那么接下来接说一下对服务的通信. 一般有两种: Content.StartService()会把Intent分发给Service.onStartCommand()方法,可以在该方法中触发后台操作, 然后通过广播或者其他方式再把结果分发给调用组件. Content.bindService()方法可以获得Binder对象, 使用它可以直接调用Service对象. 使用Intent进行异步消息的传递 如果想要知道服务中处理的结果, 只需要采用发送广播的进行通知调用者即可. 总结一下这种的优缺点: 优点: Android提供了线程的机制, 而不需要开发者自己构建复杂的组件间消息处理系统. 开发者只需要声明表示异步消息的action. 并在响应的组件中注册这些广播. 即便Service属于其他应用或者运行在一个单独的进程中, 该方法同样有效. 缺点: 通知的结果受限于Intent. 此外这种方式不适合在IntentService和Activity之间进行大规模快速更新的操作, 比如更新进度条, 因为这会阻塞系统. 如果确定需要实现此功能那么可以使用bindService. 本地绑定的Service进行的交互 当Service提供的接口太过复杂, 很难用Intent消息机制解决, 而普通的Java方法又可以很好的解决这个问题; 另一个使用绑定本地Service的原因是可以在Service中给Activity提供更为复杂的回调. 因为那些耗时的操作必须放到Service的后台线程, 所以Service的大部分回调应该是异步的. 实际的调用触发后台操作立即返回, 一旦操作完成, Service使用回调接口来通知Activity响应的执行结果. ","date":"2016-09-26","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9804-%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C-service/:2:9","tags":["android","笔记"],"title":"《Android 编程实战》04-手势操作进阶, 重识Service","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9804-%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C-service/"},{"categories":null,"content":" 阅读《Android 编程实战》一书的随记笔记 –\u003e 第二章 ","date":"2016-09-21","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9802-android%E4%B8%8A%E7%BC%96%E5%86%99%E9%AB%98%E6%95%88java/:0:0","tags":["android","笔记"],"title":"《Android 编程实战》02-Android上编写高效Java","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9802-android%E4%B8%8A%E7%BC%96%E5%86%99%E9%AB%98%E6%95%88java/"},{"categories":null,"content":"Dalvik Java和Java SE 在Android设备上运行的VM成为Dalvik. 适用于CPU和内存受限的移动设备. Java SE和Dalvik Java存在一些差异, 这些差异主要体现在虚拟机上. Java SE: 使用了栈机设计 Dalvik : 使用了基于寄存器的机器的设计 Android SDK中个有一个dx工具, 它会把Java SE栈机器的字节码转换成基于寄存器的Dalvik机器字节码, 这个步骤平时是由AS自动完成的. 虽然基于寄存器的虚拟机最多可以比基于栈的虚拟机快32%, 但这只限于执行解释代码的虚拟机. 在Android 2.2之前, Dalvik虚拟机都是纯解释性的. 之后才引入了JIT编译器. JIT编译 也称即时编译或者动态编译. 它在执行前把字节码翻译成本地代码, 这样的两个好处: 消除了那些纯解释性虚拟机的开销 它能对本机代码执行优化, 这通常是静态编译代码无法做到的. 另一个区别是: Dalvik在开机时会启动一个zygote的进程, 该进程会创建第一个Dalvik实例, 由这个实例创建所有其他的实例. 当应用程序启动的时候, zygote进行会收到一个创建新虚拟机实例的请求, 并给该应用程序创建一个新进程. 对于两个方向的API也不是一模一样, 比方说Android移除了Java SE中Swing/AWT包. 因为Android有自己的UI框架. 还有一些例如RMI, CORBA,JMX等. ","date":"2016-09-21","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9802-android%E4%B8%8A%E7%BC%96%E5%86%99%E9%AB%98%E6%95%88java/:1:0","tags":["android","笔记"],"title":"《Android 编程实战》02-Android上编写高效Java","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9802-android%E4%B8%8A%E7%BC%96%E5%86%99%E9%AB%98%E6%95%88java/"},{"categories":null,"content":"优化Android上的Java代码 1.更安全的队列 例如如果需要实现一个生产者/消费者模式, 关于所使用的管理存储的集合可能需要选择队列(LinkedList)并且具体的存取操作要套上synchronize防止并发问题. 但是如果通过LinkedBlockingQueue就可以实现上面的手动编写的步骤. 对于做同样的事情但是更快的实现方法,我们没有例如不去使用 其实在JDK1.5之后, 提供了java.util.concurrent包, 这个包不仅有相关的类, 此外还包含信号量, 锁, 以及对单个变量进行原子操作的类. 2.更好的锁 对于Java提供的synchronize关键字允许创建线程安全的代码块和方法. synchronize关键字虽然便于使用, 但也很容易滥用, 对性能造成损耗. 当需要区分读数据和写数据时, synchronize也不是最有效的. public class ReadWriteLockDemo { /** * 控制读写操作并发的锁 */ private final ReentrantReadWriteLock mLock ; private String mName; public ReadWriteLockDemo(){ mLock = new ReentrantReadWriteLock(); } public void setPersonData(String name){ // 获取写操作的锁 ReentrantReadWriteLock.WriteLock writeLock = mLock.writeLock(); try { // 获取 写锁使用权, 其余线程需要操作只有在写锁被关闭才可以 writeLock.lock(); mName = name; }finally { // 释放 写锁使用权 writeLock.unlock(); } } public String getName(){ ReentrantReadWriteLock.ReadLock readLock = mLock.readLock(); try { readLock.lock(); return mName; }finally { readLock.unlock(); } } // 省略其余实现 } 上面代码允许多个并发线程对数据进行只读方法, 并确保同一时间只有一个线程写入数据. ","date":"2016-09-21","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9802-android%E4%B8%8A%E7%BC%96%E5%86%99%E9%AB%98%E6%95%88java/:2:0","tags":["android","笔记"],"title":"《Android 编程实战》02-Android上编写高效Java","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9802-android%E4%B8%8A%E7%BC%96%E5%86%99%E9%AB%98%E6%95%88java/"},{"categories":null,"content":"管理和分配内存 Java的自动内存管理有效消除了开发过程中的许多问题. 不再需要记住为每个创建的对象进行手动释放对象内存. 当时同时也需要付出一定的性能代价. 自动垃圾收集器会和程序并行运行. 垃圾回收器会一直运行, 并检查是否有可以回收的内存. 这种行为意味着应用程序进程会和垃圾收集器竞争CPU时间,即使垃圾回收器不会运行太长时间,但是也是一种性能损失. 虽然我们不能抛弃这中垃圾收集方式, 但是可以有效的控制, 例如: 减少对象分配 如果可以不要在循环内部创建对象, 在循环的外部创建对象, 并复用此对象. 减少对象的生成造成的空间开辟, 和无用对象的回收. ","date":"2016-09-21","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9802-android%E4%B8%8A%E7%BC%96%E5%86%99%E9%AB%98%E6%95%88java/:3:0","tags":["android","笔记"],"title":"《Android 编程实战》02-Android上编写高效Java","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9802-android%E4%B8%8A%E7%BC%96%E5%86%99%E9%AB%98%E6%95%88java/"},{"categories":null,"content":"Android中的多线程 确保不再UI线程做耗时操作, 这基本已经印在Android开发的脑袋里了. 那么如何知道一个方法是否在主线程执行? Android文档指出, 默认情况下, 应用的所有组件都运行在同一个进程和线程中(主线程). 更确切点的说三个组件(Activity, Service, Broadcast, Application)的所有回调基本上所有的onXXXX()这种命名的方法都是运行在主线程的. 那么什么样的代码在主线程执行才是安全的? 只有那些必须在主线程执行的方法才能放在主线程中. 其他一切操作都应该放在另一个单独的线程中执行. 实际情况下, 那些不会耗时的操作也可以放在主线程中. 如何能确保在另一个单独的线程中执行文件, 数据库或者网络操作, 通常主线程会是安全的. 当然也要确保同一时间不会运行太多线程, 原因是CPU切换线程也会造成性能损失. ","date":"2016-09-21","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9802-android%E4%B8%8A%E7%BC%96%E5%86%99%E9%AB%98%E6%95%88java/:4:0","tags":["android","笔记"],"title":"《Android 编程实战》02-Android上编写高效Java","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9802-android%E4%B8%8A%E7%BC%96%E5%86%99%E9%AB%98%E6%95%88java/"},{"categories":null,"content":"Thread Thread类是Android中所有线程的基类, Java SE中也包含它. 如果要在线程中执行代码, 即可以创建一个继承, 也可以把实现Runnable接口的类对象传给Thread的构造函数. 对于这个基础的类, 尽量能不用就不用. 除非配合缓冲池, 不然频繁的创建新的线程开销很大. ","date":"2016-09-21","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9802-android%E4%B8%8A%E7%BC%96%E5%86%99%E9%AB%98%E6%95%88java/:4:1","tags":["android","笔记"],"title":"《Android 编程实战》02-Android上编写高效Java","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9802-android%E4%B8%8A%E7%BC%96%E5%86%99%E9%AB%98%E6%95%88java/"},{"categories":null,"content":"AsyncTask 这是Android中比较流行的一种, 因为使用简单,并且允许定义一个运行在单独线程中的任务, 并且提供了不同阶段的回调, 如doInBackground()会被回调在单独的线程. 而其余的三个回调都是被回调在主线程. 这都是为了让开发者可以把代码编写的重点放在实现的功能上, 而不是考虑是否应该避免系统级的问题发生. 使用AsyncTask创建的实例只能使用一次, 这也就意味着每次执行操作都新建一个实例对象. 虽然是个轻量级的类(实际的线程是由ExecutorService管理的), 但是不适合那些频繁的操作, 因为这会快速聚集需要垃圾回收的对象, 并最终导致应用程序的卡顿. 并且, AsyncTask不能对操作设置执行时间, 也无法间隔一段时间去执行操作. 它适合文件下载, 以及不会频繁发生或通过用户交互等类似情况的操作. 但是使用简单嘛. ","date":"2016-09-21","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9802-android%E4%B8%8A%E7%BC%96%E5%86%99%E9%AB%98%E6%95%88java/:4:2","tags":["android","笔记"],"title":"《Android 编程实战》02-Android上编写高效Java","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9802-android%E4%B8%8A%E7%BC%96%E5%86%99%E9%AB%98%E6%95%88java/"},{"categories":null,"content":"Handler 当需要更细粒度地控制一个单独的线程中执行操作的时候, Handler类会是一个很有用的工具. 该类允许准确地控制操作的执行时间. 还可以重复多次的使用. 执行操作的线程会一直运行, 直到被显示地终止. Loop会处理幕后的事情, 但是作为开发人员却很少和其打交道. 使用Handler类最常见的方式是发送Message. 当向后台线程传递数据和参数时, 这些消息对象简单,易于创建, 并且可以重用. Message对象通常是由它的共有整型成员变量what定义的. 还有两个名为arg1和arg2的整型成员变量, 他们用于创建低开销的的参数, 以及obj成员变量(可以存储任意单个对象的引用). 如果你需要存储更复杂的数据那么通过setData(Bundle)方法设置更复杂的数据. 发送消息 既可以使用Message#sendToTarget()也可以使用Handler#sendXXX()等方法. 如下 // 创建一个带有data参数的Message, 然后立刻把它发送到handler执行 Message.obtain(mHandler, FLAG_SYNC_DATA, data).sendToTarget(); // 立刻给handler发送一个空消息 mHandler.sendEmptyMessage(FLAG_SYNC_DATA); // 给handler发送一个空消息, 在30秒后执行 mHandler.sendEmptyMessageAtTime(FLAG_SYNC_DATA, 30 * 1000); // 给handler发送带有arguments和obj参数的消息, 并在10秒后执行 Message msg = mHandler.obtainMessage(FLAG_SYNC_DATA, 参数1, 参数2, data); mHandler.sendMessageDelayed(msg, 10 * 1000); 在创建Handler的时候构造函数传入Looper对象可以为Handler分配线程, 所以可以创建一个主线程消息的Handler, 避免使用runOnUiThread()这种丑陋缩进的代码并且还低效. 只要确保把消息发送给正确的handler即可. ","date":"2016-09-21","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9802-android%E4%B8%8A%E7%BC%96%E5%86%99%E9%AB%98%E6%95%88java/:4:3","tags":["android","笔记"],"title":"《Android 编程实战》02-Android上编写高效Java","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9802-android%E4%B8%8A%E7%BC%96%E5%86%99%E9%AB%98%E6%95%88java/"},{"categories":null,"content":"选择合适的线程 之前说过了三种在Android上创建和使用线程的方式, API中和线程相关的类还有ExecutorService和Loader. ExecutorService适合处理并行运行的多个任务, 这个非常适合编写相应多客户端的服务器应用. AsyncTask内部同样使用了ExecutorService处理多线程 三种中尽量少的直接使用Thread类, 大多数情况下推荐使用AsyncTask和Handler类, 具体使用哪一个取决于具体的需求. 如果不是很频繁地执行操作, 比如超过每分钟一次, 那么AsyncTask是个选择的对象. 如果需要安排操作时间或者需要快速间隔地执行操作, Handler是个更好的选择. 从长远的角度来看, Handler生成的代码较少, 而AsyncTask更容易使用. ","date":"2016-09-21","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9802-android%E4%B8%8A%E7%BC%96%E5%86%99%E9%AB%98%E6%95%88java/:4:4","tags":["android","笔记"],"title":"《Android 编程实战》02-Android上编写高效Java","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9802-android%E4%B8%8A%E7%BC%96%E5%86%99%E9%AB%98%E6%95%88java/"},{"categories":null,"content":" 阅读《Android 编程实战》一书的随记笔记 ","date":"2016-09-20","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E5%AE%8C%E5%96%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%92%8C%E4%BC%98%E5%8C%96/:0:0","tags":["android","笔记"],"title":"《Android 编程实战》01-完善开发环境和优化","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E5%AE%8C%E5%96%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%92%8C%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"Android SDK 进一步了解 SDK基本我们都是确保为最新的. 更新SDK最简单的方法就是命令行: $ android update sdk --no-ui 命令脚本在SDK安装目录的tools文件夹下. 对于之后对其例如tools, platform-tools, gradle的全局环境配置就不单独说明. 说一下mac下的配置/Users/yourname/文件夹下的bash_profile文件. 放入一下我的全局配置文件,可以作为格式参考,别忘了替换成你自己的电脑用户名. export PATH=\"/usr/local/mysql/bin:$PATH\" #添加mysql的全局开启关闭服务 export PATH=\"/usr/local/mysql/support-files:$PATH\" export PATH=${PATH}:/Users/suzeyu/Library/Android/sdk/tools export PATH=${PATH}:/Users/suzeyu/Library/Android/sdk/platform-tools export ANDROID_HOME=~/Library/Android/sdk # 设置ndk环境路径 export PATH=${PATH}:/Users/suzeyu/Library/Android/sdk/ndk-bundle #THIS MUST BE AT THE END OF THE FILE FOR SDKMAN TO WORK!!! export SDKMAN_DIR=\"/Users/suzeyu/.sdkman\" [[ -s \"/Users/suzeyu/.sdkman/bin/sdkman-init.sh\" ]] \u0026\u0026 source \"/Users/suzeyu/.sdkman/bin/sdkman-init.sh\" 当配置全局环境完成之后, 可以手动刷新全局环境, 让更改的操作立即生效. $ source ~/.bash_profile ","date":"2016-09-20","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E5%AE%8C%E5%96%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%92%8C%E4%BC%98%E5%8C%96/:1:0","tags":["android","笔记"],"title":"《Android 编程实战》01-完善开发环境和优化","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E5%AE%8C%E5%96%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%92%8C%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"adb工具 adb位于platform-tools文件夹. 可以使用$ adb help all查看可执行的操作. 一些常用的命令: adb devices 列出所有连接的Android设备和虚拟机 adb push \u003clocal\u003e \u003cremote\u003e 将电脑上的文件复制到设备 adb pull \u003cremote\u003e \u003clocal\u003e 将设备上的文件复制到电脑 如果存在多台设备,进行操作的时候需要选择某一个设备 通过-s \u003c指定serial number\u003e来确定连接哪一个设备. adb logcat查看日志 $ adb logcat MainActivity:* *:s 这条命令会开启日志输出, 并且只打印MainActivity标签的日志. *代表任何可能的值. 其格式\u003ctag\u003e:\u003cpriority\u003e, 而后面的*:s添加的特殊过滤用来过滤所有信息. 如果还想显示Android系统相关的日志以及由平台引起的应用程序异常可以加上AndroidRuntime:*参数. WiFi连接adb USB连接时最常用, 当不代表就是唯一途径. 也可以用WiFi通过TCP/IP连接来连接设备. 如果想要无线连接, 首先需要使用USB先连接电脑, 进行配置; 并且保证电脑和手机是处在同一WiFi环境下. 这是先决条件. (WiFi ip地址可以在手机设备网络连接查看). 然后命令即可 $ adb tcpip 5555 $ adb connect 192.168.1.104 $ adb devices #查看当前连接设备, 应该可以看见两个连接 说明一下,tcpip 5555会在TCP/IP模式下重启adb守护进程, 然后监听5555端口(adb默认端口). connect命令会使用电脑上的adb服务连接设备的IP地址. 然后拔掉usb查看设备应该会出现一个ip地址:端口序列名的设备. 你可以使用adb shell简单测试一下. adb守护进程会一直保持TCP/IP模式, 直到设备重新启动, 或者运行了adb usb, 该命令会重启USB守护进程. 当然有利就有弊, 首先不是所有设备都支持WiFi连接, 并且相比较usb调试. 速度方面明显比较慢. 在Android设备上执行命令 当在Android设备上运行shell时, am和pm命令会比较有用, 他们对应应用程序Application和包管理器Package Manager. 例如由一个外部Intent启动Service可以使用am命令手动发送Intent. $ adb shell am startservice -a \u003cintent action\u003e 同时也可以指定某一个具体的组件名. 也可以启动Activity或者发送Intent广播. 例如当开发过程中需要测试一个Service, 但是启动它的Activity还没有被创建, 这时候就可以使用命令. 包管理器是Android上的一个核心组件. 它用来管理设备上已安装的应用程序. 可以像使用Application Manager一样控制pm命令来使用. 比如允许开发者查看, 安装, 卸载已安装程序等. 还能检查这些应用的特性和应用权限. 例如: 查看已安装的程序 $ adb shell pm list packages 如果需要查看更多使用说明可以看官网说明adb使用说明 注意科学上网… ","date":"2016-09-20","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E5%AE%8C%E5%96%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%92%8C%E4%BC%98%E5%8C%96/:1:1","tags":["android","笔记"],"title":"《Android 编程实战》01-完善开发环境和优化","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E5%AE%8C%E5%96%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%92%8C%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"Gradle简单说明 随着AS的普及, 对于Gradle也将彻底替代Ant脚本. 和Ivy,Maven一样的模块化构建系统. 他结合了Ant的灵活以及Maven中的依赖管理. Gradle使用了Groovy领域的专用语言, 可以更清楚地描述配置项, 不用再写复杂的XML构建脚本. 关于根目录的build.gradle文件. 中主要有三个区块: apply plugin: xxx // gradle应用哪种插件 buildscript{ // 告诉gradle使用哪个仓库去下载构建所用的插件以及依赖 ... } dependencies{ // 项目的依赖 ... } android{ // 项目的配置项 .. } 虽然可以直接在AS中构建项目, 同样也可以通过命令与构建系统交互. Gradle定义了一系列任务. 在项目根目录下输入如下命令即可列出可用的任务: $ ./gradlew tasks 如果需要从头开始构建一个应用程序, 只需要运行下面的命令: $ ./gradlew clean build ","date":"2016-09-20","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E5%AE%8C%E5%96%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%92%8C%E4%BC%98%E5%8C%96/:1:2","tags":["android","笔记"],"title":"《Android 编程实战》01-完善开发环境和优化","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E5%AE%8C%E5%96%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%92%8C%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"ProGuard优化和混淆代码好处 对代码混淆可以让反编译更加困难. 删除无用的代码能压缩生成更小的二进制dex文件 并且由于对方法名,成员变量等混淆可以提高相应的运行速度 由于ProGuard工具对Android代码进行了混淆, Gradle构建工具也支持该工具, 可在build.gradle文件的android块-\u003ebuildTypes块-\u003e添加对应代码. buildTypes { debug { } release { //混淆开关 minifyEnabled true //加载默认混淆配置文件 progudard-android.txt在sdk目录里面，不用管，proguard.cfg是我们自己配的混淆文件 proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro' } } ","date":"2016-09-20","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E5%AE%8C%E5%96%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%92%8C%E4%BC%98%E5%8C%96/:1:3","tags":["android","笔记"],"title":"《Android 编程实战》01-完善开发环境和优化","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E5%AE%8C%E5%96%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%92%8C%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"熟悉IDE ","date":"2016-09-20","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E5%AE%8C%E5%96%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%92%8C%E4%BC%98%E5%8C%96/:2:0","tags":["android","笔记"],"title":"《Android 编程实战》01-完善开发环境和优化","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E5%AE%8C%E5%96%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%92%8C%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"断点 当程序达到断点出, 可以检查此时的应用状态. 所有的作用域中的变量都会直接显示IDE的调试视图中. 并且可以改变当前作用域的变量值, 可不需要重启应用. 根据单步的不同跳入方法, 可以顺序执行, 自己定义的方法跳入, 系统提供的方法跳入, 鼠标垫跳入.等可以追踪到不容易发现的问题. ","date":"2016-09-20","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E5%AE%8C%E5%96%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%92%8C%E4%BC%98%E5%8C%96/:2:1","tags":["android","笔记"],"title":"《Android 编程实战》01-完善开发环境和优化","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E5%AE%8C%E5%96%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%92%8C%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"lint静态代码分析 编写代码总会伴随着错误发生, 即使经验丰富的人也不过是把错误发生的概率降低. 但是不能杜绝. 针对这种问题就出现了编写单元测试来检测方法代码. 但是编写的单元测试也不可能覆盖所有的情况. 所以有时候可能需要其他的方式来检测. 例如静态代码分析 功能: lint工具会检查性项目中的源文件, 包括XML和Java. 它还会查找缺失元素,结构不良的代码,问呗使用的变量等. 在AS中高亮显示的代码表示代码要修正. 可以将鼠标移动到此处会显示更多细节. 问题: 虽然lint可以很强大的检测一些错误, 但有时候可能我们并不想让其显示警告, 例如如果缺少了推荐代码, 由于某些原因使用了过时代码, 但是毫无办法并且确认程序是不会发生错误的, 这个时候是就可以压制lint的警告. java文件: 可以使用@SuppressLint注解, 把需要一直的警告当做参数 xml文件: 需要引入lint命名空间(xmlns:tools=\"http://scheme.android.com/tools\"), 然后在需要抑制警告的时候添加tools:ignore=\"WarningName\" ","date":"2016-09-20","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E5%AE%8C%E5%96%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%92%8C%E4%BC%98%E5%8C%96/:2:2","tags":["android","笔记"],"title":"《Android 编程实战》01-完善开发环境和优化","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E5%AE%8C%E5%96%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%92%8C%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"重构代码 IDE内置了多种重构任务. 重构涉及命名, 移动变量,方法,类, 修改方法签名, 封装字段等等. 在AS中将光标放在需要修改的代码处, 然后从Refactor菜单中进行后续具体的操作 提取常量: (Extract Constant). 可以快速的将一个变量替换成常量. 修改方法签名: 方法签名定义了方法的修饰符, 返回类型, 名称, 参数. 从代码提取方法: 保持方法的内容不要过多, 并且方法的目的明确.这是一种好的习惯. 可以选中一段代码块然后执行Extract Method(抽取方法)来提取出一段代码重构为一个方法. 此后如果有需要还可以修改方法签名(Change Method Signature)来进行处理. … 更多的选项可以自己去手动实践. 当熟练之后, 对于代码编写速度是一个不错的提升. ","date":"2016-09-20","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E5%AE%8C%E5%96%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%92%8C%E4%BC%98%E5%8C%96/:2:3","tags":["android","笔记"],"title":"《Android 编程实战》01-完善开发环境和优化","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E5%AE%8C%E5%96%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%92%8C%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"手机上的开发者选项 这里稍微介绍一下关于开发者选项里面的一些功能. 不锁定屏幕(Stay Awake): 该选项可以在设备充电的时防止屏幕锁屏, 前提是用USB线和电脑连接. 这样就不需要由于等待时间过长, 手机自动锁屏. 启动USB调试: 这是使用adb连接设备和开发环境的先决条件. Allow Mock Location: 如果需要对位置相关开发, 可以使用此模式模拟(不同厂商可能不提供) 显示触摸操作(Shoe Touches)和指针位置(Pointer Location): 它们对编写需要手势或者多点触控界面等高级触摸开发调试比较有用处 Drawing(绘图): 可以让开发者获取视图反馈的设置项, 比如用户界面布局以及重绘的速度和频率. 可以为动画和过渡效果设置缩放参数. 也可以在调试的时候完全禁用他们. Android4.2中的一个新功能是允许模拟辅助显示屏. Monitoring(监控): 有些设置项对确保设备流畅运行非常有用. 大部分开发者通常使用的测试机为新款手机. 但是有些用户的的一些旧设备可能会出现一些高端机上不会发生的问题. 使用以下这些选项可以更早的定位这些问题. Strict Mode Enabled(严格检查模式): 在主线程执行一个很耗时的操作时设配屏幕会闪烁. Show CPU Usage(显示CPU使用情况): 性能比较, 可以跟踪程序的CPU使用率 Apps部分: 也可以作为模拟使用较差的CPU和低内存的设备行为. 不保留活动(Don't keep Activities): 可确保每次启动Activity都重新创建. 默认是只有内存不足的时候才会删除, 并且做到尽量保持activity处于活动状态. 后台进行限制(Background Process Limit): 可以更早的结束后台操作,和上面选项模拟的行为类似. 显示所有ANR(Show All ANRs): 当应用程序在后台崩溃时他会变得更加明显. 通常, 只有当前在前台运行的应用程序才会显示ANR ","date":"2016-09-20","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E5%AE%8C%E5%96%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%92%8C%E4%BC%98%E5%8C%96/:3:0","tags":["android","笔记"],"title":"《Android 编程实战》01-完善开发环境和优化","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98%E5%AE%8C%E5%96%84%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%92%8C%E4%BC%98%E5%8C%96/"},{"categories":null,"content":" 这本书属于入门, 有很多内容可以当做扩展来了解一些API, 并且有的时候可以适当的利用Google提供好的API来做一些高效开发节约时间成本. 原理东西本书偏少. 可以学习本书中的代码的编写风格, 书中代码都是采用MVC模型来编写的. 就写这么多, 下面开始整理一些小知识点. ","date":"2016-09-10","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E5%9B%9B-%E7%BB%84%E4%BB%B6%E7%AD%89/:0:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记四 组件等","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E5%9B%9B-%E7%BB%84%E4%BB%B6%E7%AD%89/"},{"categories":null,"content":"Message与Message Handler 消息Message 消息是Message类的一个实例. 包含好几个实例变量. 其中有三个需要在实现时定义. what 用户定义的int类型消息代码, 用来描述消息 obj 随消息发送的用户指定对象 target 处理消息的Handler Message的目标是Handler类的一个实例. Message在创建时, 会自动与一个Handler相关联. Message在准备处理状态下, Handler是负责让消息处理行为发生的对象. Handler 要处理消息以及消息指定的任务, 首先需要一个消息Handler实例. Handler不仅仅是处理Message的目标(target), 也是创建和发出Message的接口. Looper 拥有Message对象的收件箱, 所以Message必须在Looper上发布或读取. 基于Looper和Message的这种关系, 为了与Looper协同工作, Handler总是引用着它. 一个Handler仅于一个Looper相关联. 一个Message也仅于一个目标Handler相关联 多个Handler可能都关联一个Looper(这也意味着一个Handler的Message可能与另一个Handler的Message存在在同一个消息队列中) Looper拥有整个队列 Handler的使用 消息的目标Handler通常不需要手动设置. 一个比较理想的方式是调用Handler.obtainMessage()方法创建消息并传入其他消息字段, 然后该方法自动完成目标Handler的设置. 为避免创建新的Message对象, Handler.obtainMessage()方法会从公共循环池里获取消息. 因此相比重新创建, 这种复用的选择会更加高效. 一旦取得了Message就可以调用sendToTarget()方法将其发送给它的Handler. 然后Handler会将Message放置在Looper消息队列的尾部. Looper取得到消息队列中的特定消息后, 会将它发送给消息目标去处理. 消息一般是在目标的Handler.handleMessage()中进行处理的. 传递Handler HandlerThread能在主线程上完成任务的一种方式是, 让主线程将其自身的Handler传递给HandlerThread. 主线程是一个拥有Handler和Looper的消息循环. 主线程上创建的handler会自动与它的Looper相关联. 可以将主线程的handler传递给另一个线程. 传递出去的Handler与创建线程的Looper始终保持着联系. 因此任何已传出的Handler负责处理的消息都将在主线程的消息队列中处理. 关于AsyncTask AsyncTask 主要应用于那些短暂且较少重复的任务. 并且在Android 3.2时其内部进行了代码的改动. 改动之后的效果是AsyncTask不再为每一个AsyncTask的实例单独创建一个线程. 相反, 它使用了Executor在单一的后台线程上运行所有的AsyncTask的后台任务. 这意味着每个AsyncTask都需要排队逐个运行. (虽然可以通过特定的方法改变其内部的顺序调用, 但是或许应该想想是否有其他的更好的方式来选择) ","date":"2016-09-10","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E5%9B%9B-%E7%BB%84%E4%BB%B6%E7%AD%89/:1:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记四 组件等","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E5%9B%9B-%E7%BB%84%E4%BB%B6%E7%AD%89/"},{"categories":null,"content":"启动模式于新的Intent 启动模式决定了activity在收到新的intent时的启动方式. 启动模式 行为 standard 默认行为, 针对每一个收到的新Intent, 都会启动新的activity singleTop 如果activity实例已经处在回退栈的顶部, 则不重新创建新的activity, 而直接路由新的intent给现有的activity singleTask 在自身task中启动activity, 如果task中activity已经存在, 则清除回退站中该activity上的任何activity, 然后路由新的intent给现有的activity singleInstance 在自身task中启动activity, 该activity是task中唯一的activity, 如果任何其他activity从该task中启动, 他们都将启动到自己的task中. 如果task中的activity已经存在. 那么就路由新的intent给现有的activity 上面说到路由新的intent给现有的activity. 这个新的intent通过复写activity#onNewIntent()可以获得. ","date":"2016-09-10","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E5%9B%9B-%E7%BB%84%E4%BB%B6%E7%AD%89/:2:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记四 组件等","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E5%9B%9B-%E7%BB%84%E4%BB%B6%E7%AD%89/"},{"categories":null,"content":"使用SP实现轻量级数据存储 对于存储可以采用序列化对象并保存至外部存储设备的方式, 实现持久化存储. 然后对于轻量级数据的持久化可以使用shared preferences会更加简单高效. shared preferences本质上就是文件系统中的文件. 可使用SharedPreferences类对其进行读写. SharedPreferences实例使用起来更像一个键值对仓库如Bundle, 但它可以通过持久化存储保存数据. 键值对中的键为字符串. 而值是原子数据类型. 其本质上就是一种简单的XML文件. 但SharedPreferences类已屏蔽了读写文件的实现细节. 关于使用: 可以使用Context.getSharePreferences(String, int)方法. 然而在实际开发中, 由于sharedpreferences共享整个应用. 并不太关心获取的特定实例是什么. 这种情况下, 可以使用PreferenceManager.getDefaultSharedPreferences(Context), 该方法会返回具有私有权限与默认名称的实例. 而对于添加数据, 通过SP对象的edit()方法可以获得一个Editor实例, 通过这个实例, 就可将一组数据操作放入一个事务中, 添加之后. 通过Editor.commit()最终写入数据. ","date":"2016-09-10","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E5%9B%9B-%E7%BB%84%E4%BB%B6%E7%AD%89/:3:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记四 组件等","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E5%9B%9B-%E7%BB%84%E4%BB%B6%E7%AD%89/"},{"categories":null,"content":"后台服务 IntentService IntentService并不是Android提供唯一服务, 但却是最常用的. IntentService也是一个Content. 并能够响应intent. 服务的intent又称作命令. 每一条命令都要求服务完成某项具体的任务. IntentService逐个执行命令队列的命令. 接收到首个命令时, IntentService即完成启动, 并触发一个后台线程, 然后将命令放入队列. 随后IntentService继续按顺序执行每一条命令, 并同时为每一条命令在后台线程上调用onHandlerIntent()方法. 新进命令总是放置在队列尾部. 最后, 执行完队列中全部命令后, 服务也随即停止并被销毁. ","date":"2016-09-10","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E5%9B%9B-%E7%BB%84%E4%BB%B6%E7%AD%89/:4:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记四 组件等","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E5%9B%9B-%E7%BB%84%E4%BB%B6%E7%AD%89/"},{"categories":null,"content":"AlarmManager延迟运行服务 有时为了保证服务在后台的可用, 当没有activity在运行时, 需通过某种方式在后台执行一些任务. 比如说, 设置一个5分钟间隔的定时器. 一种实现方式是调用Handler的sendMessageDelayed()或者postDelayed()方法. 但如果用户离开了当前应用. 进程就会停止, Handler消息也会随之消亡, 因此该解决方案并不算可靠. 这样可以尝试使用AlarmManager. AlarmManager是可以发送Intent的系统服务. 那么如何告诉AlarmManager发送Intent呢? 使用PendingIntent. 利用PendingIntent打包Intent, 然后将其发送给系统中的其他部件, 如AlarmManager. 如下代码: public static void setServiceAlarm(Context context, boolean isOpen){ Intent intent = new Intent(context, 要打开服务的类名.class); PendingIntent pi = PendingIntent.getService(context, 0, intent, 0); AlarmManager alarmManager = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE); if (isOpen){ // 设置定时器 alarmManager.setRepeating(AlarmManager.RTC, System.currentTimeMillis(), 1000 * 15 , pi); }else{ alarmManager.cancel(pi); pi.cancel(); } } 如上代码中只要替换创建Intent指定的服务类名. 那么当调用了setServiceAlarm传递true那么. 会发现每隔15秒就会启动一次IntentService. 即使进程停止, AlarmManager依然会不断发送intent. 以反复启动服务. ","date":"2016-09-10","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E5%9B%9B-%E7%BB%84%E4%BB%B6%E7%AD%89/:5:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记四 组件等","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E5%9B%9B-%E7%BB%84%E4%BB%B6%E7%AD%89/"},{"categories":null,"content":"PendingIntent PendingIntent是一种token对象. 调用PendingIntentn.getService()方法获取PendingIntent时, 我们告诉操作系统: 要使用startService()方法发送这个intent. 随后调用PendingIntent对象的send()方法时, 操作系统会按照我们的要求发送原来封装的Intent. PendingIntent真正精妙之处在于, 将PendingIntent交给其他应用使用时, 它是代表当前应用发送token对象的. 另外PendingIntent本身存在于操作系统而不是token里, 因此实际上是我们在控制着它. 如果不顾及别人的感受, 也可以在交给别人一个PendingIntent对象后, 立即撤销它, 让send()方法什么也不做. 如果使用同一个intent请求PendingIntent两次, 得到的PendingIntent仍会是同一个, 我们可借此测试某个PendingIntent是否已存在, 或撤销已发出的PendingIntent 使用PendingIntent管理定时器 一个PendingIntent只能登记一个定时器, 可以通过AlarmManager.cancel(PendingIntent)方法来撤销PendingIntent的定时器, 然后撤销PendingIntent. 还有一种方式可以判断定时器激活与否, 既然撤销定时器也随即撤销了PendingIntent, 可通过检查PendingIntent是否存在, 来确认定时器是否激活. 具体实现, 传入PendingIntent.FLAG_NO_CREATE标记给PendingIntent.getService()方法即可, 该标记表示如果PendingIntent不存在则返回null. ","date":"2016-09-10","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E5%9B%9B-%E7%BB%84%E4%BB%B6%E7%AD%89/:6:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记四 组件等","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E5%9B%9B-%E7%BB%84%E4%BB%B6%E7%AD%89/"},{"categories":null,"content":"通知消息 Notification 如果服务需要与用户进行信息沟通, **通知消息(notification)**是一个不错的选择, 通知消息是指显示在通知抽屉上的消息条目, 用户可向下滑动屏幕读取. 发送通知消息, 首先需要创建一个Notification对象. notification需要使用构造对象完成创建. 一个比较完成的Notification应该具备如下: 首次显示通知消息时, 在状态栏上显示的ticker text. ticker text消失后, 在状态栏上显示的图标 代表通知信息自身, 在通知抽屉中显示的视图 用户点击抽屉中的通知信息, 触发PendingIntent 完成Notification对象的创建后, 可调用Notification系统服务的notify(int,Notification)方法发送它. ","date":"2016-09-10","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E5%9B%9B-%E7%BB%84%E4%BB%B6%E7%AD%89/:7:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记四 组件等","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E5%9B%9B-%E7%BB%84%E4%BB%B6%E7%AD%89/"},{"categories":null,"content":"服务的一些说明 non-sticky服务 IntentService是一种non-sticky服务. non-sticky服务在完成所有已有任务时停止. 为获得non-sticky服务, 应返回START_NOT_STICKY或者START_REDELIVER_INTENT. 通过调用stopSelf()或stopSelf(int)方法, 我们告诉Android任务已经完成. stopSelf()是一个无条件方法. 不管onStartCommand()方法调用多少次, 该方法总是会成功停止服务. IntentService使用的是stopSelf(int)方法. 该方法需要来自onStartCommand()方法的启动ID. 只要在接收到最新的启动ID后, 该方法才会停止服务. 返回的START_NOT_STICKY和START_REDELIVER_INTENT的具体不同是, 如果系统需要在服务完成任务之前关闭它, 则服务的具体表现会有所不同. START_NOT_STICKY型服务会被关闭. 而START_REDELIVER_INTENT型服务, 则会在可用资源不再吃紧时, 尝试再次启动服务. 所以根据操作与应用的重要程度, 进行选择. start_not_sticky是IntentService的默认行为. 通过setIntentRedelivery(true)来切换模式. sticky服务 sticky服务会持续运行, 直到外部组件调用Content.stopService(Intent)方法让其停止为止. 为启动sticky服务, 应返回START_STICKY. sticky服务启动后会持续运行, 直到某个组件调用Content.stopService(Intent)方法为止. 如因某种原因需终止服务, 可传入一个null intent给onStartCommand()方法实现服务的重启. sticky服务适用于长时间运行的服务, 如音乐播放器这种启动后一直保持运行状态, 直到用户主动停止服务. ","date":"2016-09-10","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E5%9B%9B-%E7%BB%84%E4%BB%B6%E7%AD%89/:8:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记四 组件等","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E5%9B%9B-%E7%BB%84%E4%BB%B6%E7%AD%89/"},{"categories":null,"content":"broadcast Intent Android设备中, 各种事件一直频繁的发生着. WIFI型号时有时无, 各种软件包获得安装, 电话的呼入呼出, 短信接收等. 许多的系统组件需要知道某些事件的发生. 为满足这样的需求, android提供了broadcast intent组件. 设备重启而重启的定时器 设备重启后, 那些持续运行的应用通常也需要重启. 通过监听具有BOOT_COMPLETED操作的broadcast intent, 可得知设备是否已完成启动. 如果要实现这个功能, 首先定义一个广播, 继承BroadcastReceiver. 并在清单文件中声明\u003creceiver\u003e并添加intent过滤器设置一个action. 因为要监听系统开机所以需要添加一个使用权限\u003cuses-permission android:name=\"android.permission.RECEIVE_BOOT_COMPLETED\"\u003e 于activity和服务不同, 在配置文件中声明的broadcast receiver几乎总是需要声明intent-filter. broadcast intent就是为发送信息给多个监听者而生. 但显示的intent只有一个receiver. 因此显示的broadcast intent很少见. 如何使用receiver broadcast receiver的存在很短暂, 因此它的作用也就受到限制, 例如无法使用任何异步API或登记任何的监听器, 因为onReceiver()回调一旦运行完, receiver也就不存在了. 而因为onReceiver()同样运行在主线程, 因此不可以执行耗时操作. 但是存在既有道理, 对于轻型任务代码的运行而言, receiver非常有用. 系统重启后, 定时运行的定时器也需要重置. 显示, 使用broadcast receiver处理这种小型任务再合适不过了(这里只是列举一个例子). 使用私有权限 使用动态广播接收存在一个问题, 即系统中的任何应用均可监听并触发我们的receiver. 对于这种情况应该避免. 有两种方案可以选择. 如果receiver声明在manifest配置文件里, 且仅限应用内部使用, 则可在receiver标签上添加android:exported=\"false\"属性. 这样系统中的其他应用就再也无法接触到该receiver. 另外也可以创建自己的使用权限. 通过在清单文件中添加一个\u003cpermission\u003e标签来完成. 例如 \u003cpermission android:name=\"com.suzeyu.android.TEST_PERMISSION\" android:protectionLevel=\"signature\"\u003e 这段代码使用了protection level签名, 定义了自己的定制权限. 权限本身只是一行字符串. 即使是自定义的权限, 也必须要在使用前获取它, 这是规则. 如果给定义的广播设置了权限, 那么在发送广播时(sendBroadcast), 和注册广播时. 和应用清单添加使用权限的声明. 3处需要注意. 深入了解protection level 自定义权限必须指定android:protectionLevel属性值, Android根据protectionLevel属性值确定自定义权限的使用方式. 权限的所选值有四种. 对于仅限应用内部使用的权限, 通常会选择signature安全级别. 关于四种可选值的特征如下: 可选值 用法描述 normal 用于阻止应用执行危险操作, 如访问个人隐私数据,联网传送数据等. 应用安装前, 用户可看到相应的安全级别, 但无需他们主动授权. android.permission.RECEIVE_BOOT_COMPLETED使用该安全级别. 同样, 手机振动也使用该安全级别. 虽然这些安全级别没有危险, 但最好让用户知晓可能带来的影响 dangerous normal安全级别控制以外的任何危险操作, 如访问个人隐私数据, 通过网络接口收发数据, 使用可监视用户的硬件功能等. 总之, 包括一切可能为用户带来麻烦的行为. 网络使用权限, 相机使用权限以及联系人信息使用权限都属于危险操作. 需要dangerous权限级别时, Android会明确要求用户授权 signature 如果应用签署了于声明应用一致的权限证书, 则该权限由系统授予. 否则, 系统则作相应的拒绝. 权限授予时, 系统不会通知用户. 它通常适应于应用内部. 只要拥有证书, 则只有签署了同样证书的应用才能拥有该权限, 因此可自由控制权限的使用. 这里我们使用它阻止其他应用监听到应用发出的broadcast. 不过如有需要, 可定制开发能够监听他们的专有应用 signatureOrSystem 类似于signature授权界别. 但该授权级别针对Android系统镜像中的所有包权限. 该授权级别用于系统镜像内应用间的通信, 因此用户通常无需关心 使用ordered broadcast接收结果 常规的Broadcast可同时被其他应用所接收. 而如果希望他们按照某种顺序依次运行, 或知道他们什么时候全部结束运行是无法做到的. 所以为了解决这种情况, 可使用有序broadcast intent实现双向通信. 有序广播允许多个广播接收者依序处理broadcast intent. 另外 通过传入一个名为result receiver的特别broadcast receiver, 有序广播还可以实现让广播的发送者接收到广播接收者发送的返回结果. 通过sendOrderedBroadcast(...)发送有序广播. 和常规的广播相比有序广播的参数还多出五个. 一次为: 一个result receiver; 一个支持result receiver运行的Handler; 结果代码初始值; 结果数据; 有序broadcast的结果附加内容 result receiver比较特殊, 只有在所有有序广播接收者结束运行后, 它才可以运行. 有序发送顺序是通过receiver的优先级作为依据. 关于优先级数值越高优先级越高. 如果要设置最后接收的接收者可以设定其优先级为**-999**(-1000及以下的值为系统保留值) receiver长时运行任务 如果不想受限于主线程的时间限制, 并希望broadcast intent可触发一个长时运行任务,有两种方式可以选择: 将任务交给服务去处理, 然后再通过broadcast receiver启动服务. 服务可以运行很久, 直到完成需要处理的任务. 同时服务可将请求放在队列中, 然后依次进行处理, 或按其自认为合适的方式管理全部任务请求. 使用BroadcastReceiver.goAsync()方法. 该方法返回一个BroadcastReceiver.PendingResult对象, 随后, 可使用该对象提供结果. 因此, 可将PendingResult交给AsyncTask去执行长时运行任务, 然后再调用PendingResult的方法相应broadcast goAsync()方法两个弊端: 不支持旧设备; 其次它不够灵活: 仍需快速响应broadcast. ","date":"2016-09-10","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E5%9B%9B-%E7%BB%84%E4%BB%B6%E7%AD%89/:9:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记四 组件等","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E5%9B%9B-%E7%BB%84%E4%BB%B6%E7%AD%89/"},{"categories":null,"content":"WebView 首先在xml布局中添加WebView控件, 没什么好说的. 接下来. 开始代码设置. 应该先完成三件事情. 指定WebView要打开的URL 启动JavaScript, JavaScript默认是禁用的. 最好启动以免不必要的错误. 覆盖WebViewClient类的shouldOverrideUrlLoading(WebView, String)方法. 并返回false. 例如: mWebView.getSettings().setJavaScriptEnabled(true); mWebView.setWebViewClient(new WebViewClient(){ @Override public boolean shouldOverrideUrlLoading(WebView view, String url) { return false; } }); mWebView.loadUrl(要加载的网址); 加载Url必须等到WebView配置完成之后. WebSetting是修改WebView配置的三种途径之一. 他还有一些其他可设置属性, 如用户代理字符串和显示文字大小. 配置WebViewClient. WebViewClient是一个事件接口, 通过提供自己实现的WebViewClient, 可响应各种渲染事件. 例如可检测渲染器何时开始从特定URL加载图片, 或决定是否需要向服务器重新提交POST请求. WebViewClient有多个方法可供覆盖, 其中大多数用不到. 然而必须覆盖其shouldOverrideUrlLoading()的默认方法. 当有新的URL加载到WebView时(如点击了某个链接),如果返回true那么有系统浏览器处理. 如果为false那么就是webview去加载. 使用WebChromeClient优化WebView的显示 如果说WebViewClient是响应渲染事件的接口, 那么WebChromeClient就是一个响应改变浏览器中装饰元素的事件接口, 包括JavaScript警告信息, 网页图标, 状态条架子啊,以及当前网页标题的刷新. 进度条和标题栏的更新都有各自的回调方法, 即onProgressChange()和onReceivedTitle() 方法. 处理WebView的设备旋转问题 由于WebView包含了太多的数据, 以至无法再onSaveInstanceState()方法保存所有数据. 对于一些类似的类如VideoView. Android文档推荐让activity自己处理设备配置的变更. 也就是说, 不销毁重建. 那么就要让activity不会因设备配置变更而发生重建动作,而是自己去处理配置更改后的问题. 那么就需要在清单文件中声明属性. android:configChanges=\"keyboardHidden|orientation|screenSize\" 这个属性加在activity标签内部表明, 如果因键盘开关, 屏幕方向改变, 屏幕大小改变而发生的设配配置更改, 那么activity应自己处理配置更改, ","date":"2016-09-10","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E5%9B%9B-%E7%BB%84%E4%BB%B6%E7%AD%89/:10:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记四 组件等","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E5%9B%9B-%E7%BB%84%E4%BB%B6%E7%AD%89/"},{"categories":null,"content":"LocationManager Android系统中的地理位置数据是由LocationManager系统服务提供的. 该系统服务向所有需要地理位置数据的应用提供数据更新. 更新数据的传送通常采用两种方式. 使用LocationListener接口 使用PendingIntent获取地理位置更新 LocationListener接口可能是最直接的一种方式. 通过onLocationChanged()方法, 该接口提供的信息有:地理位置数据更新, 状态更新, 以及定位服务提供者启停状态的通知消息. 如只需将地理位置数据发送给应用中的单个组件, 使用LocationListener接口会很方便. 通过实现LocationManager类的requestLocationUpdates()或者requestSingleUpdate()方法即可. 使用PendingIntent来获取地理位置数据更新, 实际是要求LocationManager在将来某个时点帮忙发送某种类型的Intent. 这样即使应用组件甚至整个应用进程都销毁了, LocationManager仍会一直发送intent, 直到要求它停止并按需启动新组件响应他们. 利用这种优势, 即使持续进行设备定位, 也可以避免应用消耗过多资源. LocationManager是通过Context.getSystemService(Context.LOCATION_SERVICE)来获得的. 通过调用其requestLocationUpdates(String, long, float, PendingIntent)数值参数为: 最小等待时间(ms); 最短移动距离(m); 之后定义接收定位数据的广播接收者, 为了保证无论前台还是后台都可以接收更新数据, 最好使用清单文件进行注册. 在onReceive()实现方法中. LocationManager打包了附加额外信息的intent. LocationManager.KEY_LOCATION_CHANGED键值可指定一个表示最新更新的Location实例. 通过这个实例可以获取到服务提供者名字以及相应的经纬度数据. 别忘了添加使用地理位置的权限. \u003cuses-permission android:name=\"android.permission.ACCESS_FINE_LOCATION\"\u003e 也可以通过LocationManag#getLastKnownLocation()获取最近地理位置信息. 如下: String provider = LocationManager.GPS_PROVIDER; Location lastKnown = mLocationManager.getLastKnownLocation(provider); ","date":"2016-09-10","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E5%9B%9B-%E7%BB%84%E4%BB%B6%E7%AD%89/:11:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记四 组件等","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E5%9B%9B-%E7%BB%84%E4%BB%B6%E7%AD%89/"},{"categories":null,"content":"SQLite本地数据库 Android内置了操作SQLite的Java前端, 该前端的SQLiteDatabase类负责提供Cursor实例形式的结果集. Android提供了一个帮助类, SQLiteOpenHelper类封装了一些存储应用数据的常用数据库操作, 如创建打开以及更新数据库等. 继承SQLiteOpenHelper通常要覆盖两个方法: onCreate(): 为新建数据库创建表结构 onUpgrade(): 可执行迁移代码, 实现不同版本间的数据库结构升级或转换. 通常还需要实现一个父类的构造函数. 为父类提供必要的初始化参数, 数据库文件名, 可选CursorFactory参数的null值, 以及数据库版本号. SQLiteOpenHelper类有两个访问SQLiteDatabase实例的方法: getReadableDatabase() 需要只读时使用 getWritableDatabase() 需要可写数据库时使用 这两种方法基本没有太大区别, 但在某种特定情况下, 如磁盘空间满了, 则可能无法获取可写数据库, 而只能获取到可读数据库. 查询SQLiteDatabase可返回描述结果的Cursor实例. Cursor将结果集看做是一系列的数据行和数据列, 但仅支持String以及原始数据类型的值 .(可使用CursorWrapper封装当前Cursor对象.下面说明) 使用CursorAdapter CursorAdapter类的构造方法需要一个Context, 一个Cursor, 一个整型flag. 为了提倡使用Loader, 大多数flag已经被废弃或存在一些问题. 因此可直接传入0. 需要实现两个方法: newView(...): 会返回一个代表cursor中当前数据行的View. 在这里需要创建一个View并返回供item视图显示做准备 bindView(...): 进行绑定数据 关于查询数据操作 // 通过where子句. 限制查询只能返回一条记录, 然后封装到RunCursor中并返回 Cursor wrapped = getReadableDatabase().query(TABLE_RUN, null, // All columns COLUMN_RUN_ID + \" = ?\", // look for a run ID new String[]{String.valueOf(id)}, // with the value null, // group by null, // having null, // order by \"1\" // limit 1 row ); 就给一个简单的例子. 了解一下查询方法的参数. ","date":"2016-09-10","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E5%9B%9B-%E7%BB%84%E4%BB%B6%E7%AD%89/:12:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记四 组件等","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E5%9B%9B-%E7%BB%84%E4%BB%B6%E7%AD%89/"},{"categories":null,"content":"Loader加载异步数据 Loader于LoaderManager Loader设计用于从数据源加载某类数据(如对象). 数据源可以是磁盘, 数据库, ContentProvider, 网络或者另一个进程. loader可在不阻塞主线程的情况下获取并发送结果数据给接收者. loader有三种内置类型: Loader, AsyncTaskLoader, CursorLoader. 作为基类Loader本身没有多大用处. 它定义了供LoaderManager与其他loader通讯时使用的API. AsyncTaskLoader是一个抽象Loader. 它使用AsyncTask将数据加载任务转移到其他线程中处理. 几乎所有创建的有用的loader类都是AsyncTaskLoader的子类 CursorLoader. 通过继承AsyncTaskLoader类, 它借助ContentResolver从ContentProvider加载Cursor LoaderManager管理着于loader间的所有通讯, 并负责启动, 停止和管理与组件关联的loader的生命周期方法. 在activity和fragment可通过getLoaderManager()方法返回一个实例并进行交互 要初始化Loader可使用initLoader(int, Bundler, LoaderCallbacks\u003cD\u003e)方法. 参数说明如下: 整数类型的loader标识符 Bundler参数(值可为空) 一个接口回调分别对应着创建, 完成, 重启的回调 如果要强制重启现有的loader, 可使用restartLoader()方法. 在明确知道或怀疑数据比较陈旧时, 通常使用该方法重新加载最新数据. 为什么使用loader而不直接使用AsyncTask 有一个比较好的理由: 因设备旋转等原因发生配置更改时, LoaderManager可保证组件的loader及其数据不会丢失. 如果使用AsyncTask加载数据, 配置发生改变时, 就必须亲自管理其生命周期并保存它所取得的数据. 虽然可以通过setRetainInstance(true)解决了这些麻烦的问题, 但某些场景下, 还是要亲自编写代码处理才可以. loader的设计目的就是要解决部分这样烦恼的问题. 配置发生改变后. 我们初始化一个已经完成数据加载的loader, 他会立即发送取得的数据, 而不是尝试再次获取数据. 而且无论fragment是否已保留, 他都是如此工作. 这样一来就无需考虑fragment带来的生命周期问题. 实现步骤 = =不想写了…. 就这样吧. ","date":"2016-09-10","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E5%9B%9B-%E7%BB%84%E4%BB%B6%E7%AD%89/:13:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记四 组件等","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E5%9B%9B-%E7%BB%84%E4%BB%B6%E7%AD%89/"},{"categories":null,"content":" 这本书属于入门, 有很多内容可以当做扩展来了解一些API, 并且有的时候可以适当的利用Google提供好的API来做一些高效开发节约时间成本. 原理东西本书偏少. 可以学习本书中的代码的编写风格, 书中代码都是采用MVC模型来编写的. 就写这么多, 下面开始整理一些小知识点. 关于Camera和SurfaceView的知识点练习都保存在仓库中的Criminal项目中. git地址 ","date":"2016-09-09","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%89-%E5%AA%92%E4%BD%93%E4%B8%8Eintent%E7%AD%89/:0:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记三 媒体与Intent等","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%89-%E5%AA%92%E4%BD%93%E4%B8%8Eintent%E7%AD%89/"},{"categories":null,"content":"MediaPlay播放音频 MediaPlayer是一个支持音频及视频文件播放的Android类. 可播放不同的来源(本地或网络流媒体).多种格式(WAV, MP3, MPEG-4, 3GPP等)的多媒体文件. 直接贴出代码 /** * Author : suzeyu * Time : 2016-09-07 上午10:17 * Blog : http://szysky.com * GitHub : https://github.com/suzeyu1992 * * ClassDescription : 主要用来管理MediaPlayer的实例, 和对该实例的播放和停止等功能 */ public class AudioPlayer { private MediaPlayer mPlayer; public void stop(){ if (mPlayer != null){ // 销毁, 否则MediaPlayer将一直占用着音频解码硬件及其他系统资源 mPlayer.release(); mPlayer = null; } } public void play(Context context){ // 防止过多的创建MediaPlayer实例, 第一步先销毁已经存在的 stop(); // 设置要播放的音频文件, 如果音频来自其他渠道如网络或者URI, 则使用其他的create(...)函数 mPlayer = MediaPlayer.create(context, R.raw.ss_small); mPlayer.start(); // 防止过多的创建MediaPlayer实例, 第二步设置监听, 存活时间为音频的时长 mPlayer.setOnCompletionListener(new MediaPlayer.OnCompletionListener() { @Override public void onCompletion(MediaPlayer mp) { // 音频播放完成 stop(); } }); } } 记得在res/raw/放置要播放的文件. 一个简便的播放就是这样.详细的查看官网的对于MediaPlayer的介绍 ","date":"2016-09-09","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%89-%E5%AA%92%E4%BD%93%E4%B8%8Eintent%E7%AD%89/:1:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记三 媒体与Intent等","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%89-%E5%AA%92%E4%BD%93%E4%B8%8Eintent%E7%AD%89/"},{"categories":null,"content":"播放视频 关于播放视频, Android提供了多种实现方式. 其一便是使用上面说到的MediaPlayer, 而我们需要做的只是设置在哪里播放即可. 在Android系统中, 快速刷新显示的可视图像(如视频)是在SurfaceView中显示的. 准确的说, 是在SurfaceView内嵌的Surface中显示的. 通过获取SurfaceView的SurfaceHolder可是实现在Surface上显示视频. 简单的说就是通过MediaPlayer.setDisplay(SurfaceHolder)方法, 将MediaPlayer类于SurfaceHolder关联起来即可. 通常来说直接使用VideoView实例来播放视频会更简单些, 不同于SurfaceView于MediaPlayer之间的交互, VideoView是与MediaController交互的, 这样可以方便地提供视频播放界面. 而VideoView是不接受ID资源的. 而只接受文件路径或者URI对象. 创建一个指向Android资源的URI, 可使用如下代码: Uri resourceUri = Uri.parse(\"android.resource://包名/raw/文件名称\"); 使用了android.resource格式, 用包名作为主机名, 资源文件类型与文件名称组成了一个路径用以创建URI.完成后就可以将其传给VideoView使用. ","date":"2016-09-09","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%89-%E5%AA%92%E4%BD%93%E4%B8%8Eintent%E7%AD%89/:2:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记三 媒体与Intent等","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%89-%E5%AA%92%E4%BD%93%E4%B8%8Eintent%E7%AD%89/"},{"categories":null,"content":"Camera与SurfaceView Camera: 提供了对设备相机硬件级别的调用. 相机是一种独占性资源: 一次只能有一个activity调用(如果你的应用没有释放相机资源,那么系统的相机也就无法调起使用) SurfaceView: 这是一种特殊的视图, 可直接将要显示的内容渲染输出到设备的屏幕上. 首先既然使用了相机那么就需要添加相机的使用权限 \u003c!--增加相机使用权限--\u003e \u003cuses-permission android:name=\"android.permission.CAMERA\"/\u003e \u003c!--指定应用使用的某项特色功能, 这个属性可以保证那些配备相机功能的设备才能看到发布在GooglePlay上的此应用--\u003e \u003cuses-feature android:name=\"android.hardware.camera\"/\u003e uses-feature对我们貌似没什么用处. 既然是拍照那么很多都是横屏的,所以清单文件中把所在的\u003cactivity\u003e设置横屏模式 \u003cactivity android:name=\".activity.CrimeCameraActivity\" android:screenOrientation=\"landscape\"/\u003e 开始了解相机使用 public static Camera open(int) public static Camera release() 这两个方法是管理Camera的方法. 最好用户可以与界面进行交互分别调用. 如onResume()和onPause() @Override public void onResume() { super.onResume(); // 0为打开后置摄像头, 如果没有后置摄像头那么就打开前置摄像头 mCamera = Camera.open(0); } @Override public void onPause() { super.onPause(); if(mCamera != null){ mCamera.release(); mCamera = null; } } 相机打开了现在轮到Surface,因为Camera的拍照需要它 SurfaceView类实现了SurfaceHolder接口. 首先我们先获取SurfaceHolder实例.(在Activity#onCreate或者Fragment#onCreateView()只要能保证布局已经加载就可以) /** * 对SurfaceView控件进行一些初始化和绑定客户端Camera */ private void initSurfaceView(View rootView) { mV_sfv_camera = (SurfaceView) rootView.findViewById(R.id.sfv_camera_display); SurfaceHolder holder = mV_sfv_camera.getHolder(); // setType设置只为兼容旧版本3.0之前,可以选择考虑是否需要 holder.setType(SurfaceHolder.SURFACE_TYPE_PUSH_BUFFERS); // 对SurfaceView的声明周期进行关联 holder.addCallback(new SurfaceHolder.Callback() { /** SurfaceView的视图层级结构被放在屏幕上时候被调用, 这里也是SurfaceView与客户端(Camera)进行关联的地方*/ @Override public void surfaceCreated(SurfaceHolder holder) { try { if (mCamera != null) { mCamera.setPreviewDisplay(holder); } } catch (IOException e) { Log.e(TAG, \"@@-\u003e Camera设置关联SurfaceView预览显示失败!\" ); } } /** Surface首次显示在屏幕上的时候被动调用的方法, 通过此参数可以知道Surface的像素格式以及他的宽高. 通过此方法可以通知Surface客户端, 有多大的绘制区域可以使用. */ @Override public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) { if (mCamera == null) return; // The surface has change size, update the camera preview size Camera.Parameters parameters = mCamera.getParameters(); Camera.Size size = getSupportedSize(parameters.getSupportedPreviewSizes(), width, height); // 设置图片尺寸大小 parameters.setPictureSize(size.width, size.height); mCamera.setParameters(parameters); try { // 开始在Surface上绘制 mCamera.startPreview(); }catch (Exception e){ // 如果开始预览绘制失败那么我们通过这里来释放相机资源 Log.e(TAG, \"@@-\u003e startPreview()启动失败, 准备释放相机资源!\" ); mCamera.release(); mCamera = null; } } /** SurfaceView从屏幕上移除时, Surface也随之被销毁, 通过客户端停止使用Surface*/ @Override public void surfaceDestroyed(SurfaceHolder holder) { if (mCamera != null){ mCamera.stopPreview(); } } }); } /** * 找出具有最大数目的像素的尺寸 */ private Camera.Size getSupportedSize(List\u003cCamera.Size\u003e sizes, int width, int height){ Camera.Size bestSize = sizes.get(0); int largestArea = bestSize.width * bestSize.height; for (Camera.Size s : sizes) { int area = s.width * s.height; if (area \u003e largestArea){ bestSize = s; largestArea = area; } } return bestSize; } SurfaceHolder是我们与Surface对象联系的纽带. Surface对象代表着原始像素数据的缓冲区. Surface对象也有生命周期: SurfaceView出现在屏幕上时, 会创建Surface; SurfaceView从屏幕上消失的时候,Surface随即被销毁. Surface不存在的时候, 必须保证没有任何内容要在它上面绘制. 不像其他视图一样, SurfaceView及其协同工作对象都不会自我绘制内容. 对于任何想要将内容绘制到Surface缓冲区的对象, 我们都称其为Surface的客户端. 比如这里的Camera 为了对应Surface各个生命周期, SurfaceHolder提供了另外一个接口SurfaceHolder.Callback来关联. 确定预览界面的大小 可能看到了surfaceChanged()的生命周期回调中设置了Camera实例的一个属性大小. 首先要知道相机的预览大小不能随意设置, 如果设置了不可接受的值有可能会出现崩溃. 所以我们应该先获取到设备相机所支持的预览尺寸大小. 通过Camera.Parameters类中的getSupportedPreviewSizes()就可以获取到相机的支持的预览尺寸列表. 这个方法返回的是一个List\u003cCamera.Size\u003e, 泛型Camera.Size每一个实例都封装了一个具体的图片宽高尺寸. 利用getSupportedSize()简便的比较方法可以达到选择一个最大的像素尺寸. 有可能你会需要先检测设备是否有前后相机 可以获取到PackageManager后, 调用hasSystemFeature(String)方法并传入表示设备特色功能的常量即可根据布尔值来判断. FEATURE_CAMERA常量代表后置相机, FEATURE_CAMERA_FRONT常量代表前置相机. 目前为止相机开启并渲染值Surface应该没问题了,下面就是利用Camera进行照片 主要逻辑就是从相机的实时预览中捕获一帧图像, 然后将其保存为JPEG格式的文件. 而要进行拍摄需要Camera#takePicture(Camera.shutterCallback shutter, Camera.PictureCallback raw, Camera.PictureCallback jpeg) shutterCallback 此回调里面的方法会在相机捕获图像的时候调用, 但此时图像数据还未处理完成. 第一个PictureCal","date":"2016-09-09","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%89-%E5%AA%92%E4%BD%93%E4%B8%8Eintent%E7%AD%89/:3:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记三 媒体与Intent等","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%89-%E5%AA%92%E4%BD%93%E4%B8%8Eintent%E7%AD%89/"},{"categories":null,"content":"隐式Intent 在Android系统中, 使用隐式Intent可以启动其他应用的activity. 在显示Intent中, 需要指定要启动的activity类. 操作系统会负责启动它. 而隐式Intent中, 只要描述清楚要完成的任务, 操作系统会找到合适的应用. 并在其中启动相应的activity. 典型的隐式Intent的组成 要执行的动作(action): 通常以Intent类中的常量进行表示. 例如要访问查看某个URL,可以使用Intent_ACTION_VIEW; 要发送邮件,可以使用Intent.ACTION_SEND 要发送的数据位置以及数据类型: 数据位置的话可能会是某个网页的URL,也可能是指向某个文件的URI, 或者指向ContentProvider中某条记录的某个内容URI; 数据类型这里指的是MIME形式的数据类型, 如text/html或者audio/mpeg3. 如果一个intent包含某类数据的位置, 那么通常可以从中推测出数据的类型. 可选类别(category): 如果action用于描述具体要做什么, 那么类别通常用来描述我们何时,何地或者说如何使用某个activity. android.intent.category.LAUNCHER类别表明, activity应该显示在顶级应用启动器中. 而android.intent.category.INFO类别表明,虽然activity向用户显示了包信息, 但它不应该显示在启动器中. 而在配置清单文件中的intent过滤器设置时 \u003caction\u003e: 告诉操作系统, activity能够处理指定的哪个action动作. \u003ccategory\u003e: 一般情况下都是要指定DEFAULT类别. 每发起隐式intent如果没有指定category那么系统都会默认的添加DEFALUT`类别. 操作系统进行隐式Intent寻找的时候, 是不需要使用数据(extra)来参与匹配规则的. 利用Intent选择器 比如打开一个视频文件的时候, 如果手机上有多个选择的话可能会弹出一个全部列表, 然后选择一个进行播放, 而之后会发现再也不会询问用户使用哪个视频播放软件进行播放. 对于这种情况有时候或许不需要, 这个时候就可以使用选择器来创建一个activity来展示可打开的软件, 每次都进行选择. 使用很简单. Intent intent = new Intent(); intent.setType(\"text/plain\"); intent.putExtra(Intent.EXTRA_TEXT, getCrimeReport()); intent.putExtra(Intent.EXTRA_SUBJECT, getString(R.string.crime_report_subject)); // 设置一个选择每一次都显示activity的选择器. // 这是重点 intent= intent.createChooser(intent, getString(R.string.send_report)); startActivity(intent); 通过createChooser()方法重新构建一个intent即可, 参数二传递的字符串是用来作为弹出的选择界面的标题. 再说一下获取联系人信息 如果要获取手机通讯录, 那么要指定action,并且要找指定获取位置; action对应的Intent.ACTION_PICK. 获取的位置为ContactsContract.Contacts.CONTENT_URI. 就是请求Android协助从手机联系人数据库获取某个具体联系人. 打开手机联系人代码 // 打开联系人Contract列表 // 这是通讯录应用将其权限临时给了本应用, 首先通讯录应用对联系人的数据库具有全部权限. 所以在通讯录应用 // 返回包含在Intent中的URI的时候, 他会添加一个Intent.FLAG_GRANT_READ_URI_PERMISSION标识, // 此标志向系统表示, 我们这个应用可以使用联系人数据一次. Intent intent = new Intent(Intent.ACTION_PICK, ContactsContract.Contacts.CONTENT_URI); // 检测是否有接收此Intent的应用 List\u003cResolveInfo\u003e resolveInfos = getActivity().getPackageManager().queryIntentActivities(intent, 0); if (resolveInfos.size() \u003e 0){ startActivityForResult(intent, REQUEST_CONTACT); }else{ Toast.makeText(getActivity().getApplicationContext(), \"无法打开Intent\", Toast.LENGTH_SHORT).show(); } 以上代码很容易懂, 并且做了一定的防错处理. 接下来就准备接收返回结果就可以在onActivityResult()中 if (requestCode == REQUEST_CONTACT){ // 打开联系人列表关闭后返回的逻辑 // 从intent取出URI, 该数据URI是一个指向用户所选联系人的定位符. Uri contactUri = data.getData(); // specify which fields you want you query to return values for // 指定在返回数据的时候所对应查找的字段 String[] queryFileds = {ContactsContract.Contacts.DISPLAY_NAME}; // perform query Cursor query = getActivity().getContentResolver().query(contactUri, queryFileds, null, null, null); if (query.getCount() == 0){ query.close(); return; } // 获取嫌疑人的姓名 添加到陋习记录中的suspect query.moveToFirst(); String suspect = query.getString(0); // 拿到了姓名 可以做后续的事情.... } 上面获得了一个Cursor, 因为已经知道Cursor只是包含一条记录, 所以将Cursor移动到第一条记录并获取它的字符串形式.就是姓名. 上面代码中有两句话是对可以响应的activity做检查. 通过PackageManager#queryIntentActivitys()返回集合的size大小来决定是否可以执行后续的操作. 打电话的隐式Intent 电话相关的Intent有两种 Intent.ACTION_DIAL: 选择联系人(得到号码发送一个tel:xxx数据uri)之后会停止到拨号界面等待用户手动呼叫 Intent.ACTION_CALL: 选择联系人(得到号码发送一个tel:xxx数据uri)之后会立即拨打出去. 而不会等待用户的手动拨打. ","date":"2016-09-09","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%89-%E5%AA%92%E4%BD%93%E4%B8%8Eintent%E7%AD%89/:4:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记三 媒体与Intent等","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%89-%E5%AA%92%E4%BD%93%E4%B8%8Eintent%E7%AD%89/"},{"categories":null,"content":"深入了解Intent 利用隐式的Intent可以创建一个启动器来替换系统默认的启动器应用. 例如这样: 展示出来手机上面的所有应用, 选择一个并可以打开, 有点丑, 你也可以设置上图片. 显示实现这个直接贴出代码. // 创建一个隐式Intent, 从PackageManager中获取匹配intent的activity列表 Intent intent = new Intent(Intent.ACTION_MAIN); intent.addCategory(Intent.CATEGORY_LAUNCHER); PackageManager pm = getActivity().getPackageManager(); List\u003cResolveInfo\u003e resolveInfos = pm.queryIntentActivities(intent, 0); Log.i(TAG, \"onCreate: 可以打开的数量:\"+resolveInfos.size()); // 进行排序 Collections.sort(resolveInfos, new Comparator\u003cResolveInfo\u003e() { @Override public int compare(ResolveInfo o1, ResolveInfo o2) { PackageManager pm = getActivity().getPackageManager(); // 按照名称进行排序 int result = String.CASE_INSENSITIVE_ORDER.compare(o1.loadLabel(pm).toString(), o2.loadLabel(pm).toString()); return result; } }); 首先利用PackageManager对Main/Launcher进行匹配, 这个没什么说的, 所有的应用都有一个启动入口就是这个. 可以得到所有应用的入口信息集合. 这里有一点需要了解: MAIN/LAUNCHERintent过滤器不能startActivity()这种方式发送的MAIN/LAUNCHER相匹配. 因为对于类别category为Launcher的时候, 系统是不希望你通过隐式Intent的方式去打开. 而是要你使用显示intent. 一般情况下隐式Intent打开的时候系统总是会给你添加category为default的类别. 所以可以认为隐式Intent打开的基本都是过滤器信息中类别包含为Default的类别的Intent. 而这一点在系统的入口activity过滤其中却无法得到保证. 定义了MAIN/LAUNCHER过滤器的activity是应用的主要入口, 它只关心作为应用主要入口点要处理的工作. 通常不关心自己是否属于默认的主要入口点, 因此,他也就不必包含CATEGORY_DEFAULT类别. 但好在我们可以通过隐式的MAIN/LAUNCHER查到匹配的activity集合信息, 而不需要先打开. 通过集合中的每个activity的ResolveInfo实例得到ActivityInfo我们也就可以得到包名, 类名. 那么就可以通过显示Intent打开! 如下代码 通过上面得到的集合, 随便获取一个resolveInof实例. ResolveInfo resolveInfo = (ResolveInfo) resolveInfos.get(0);; // 准备获取要打开activity的包名 类名等信息 ActivityInfo activityInfo = resolveInfo.activityInfo; if (activityInfo == null) return; // 创建显示Intent来打开Activity // 先指定一个action Intent intent = new Intent(Intent.ACTION_MAIN); intent.setClassName(activityInfo.applicationInfo.packageName, activityInfo.name); // 添加新任务标识给intent intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); startActivity(intent); 上面使用的是setClassName()方法, 这个方法可以自动创建组件名, 也可以自己通过类名和包名创建一个ComponentName, 然后使用setComponent()创建一个显示的intent. 上面还添加了一个FLAG, 主要的区别就是没有这个Flag的话, 那么打开的新应用的界面本质上是存在我们的应用任务栈中, 如果有那么就会在属于自己独立的任务中. 如下图, 在我们自己的应用打开同一个任务. 然后查看任务管理器. (前面为没有添加flag的) 至此, 现在这个应用可以得到手机的全部应用并可以做为展示列表. 但是还没完, 还差一点将我们这个应用作为设备主屏幕. 没有人愿意通过一个应用来启动另一个应用, 所以要做的就是替换Android主界面配置我们应用的启动activity再添加两个类别category, \u003cactivity android:name=\".NerdLauncherActivity\"\u003e \u003cintent-filter\u003e \u003caction android:name=\"android.intent.action.MAIN\" /\u003e \u003ccategory android:name=\"android.intent.category.LAUNCHER\" /\u003e \u003ccategory android:name=\"android.intent.category.HOME\"/\u003e \u003ccategory android:name=\"android.intent.category.DEFAULT\"/\u003e \u003c/intent-filter\u003e \u003c/activity\u003e ","date":"2016-09-09","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%89-%E5%AA%92%E4%BD%93%E4%B8%8Eintent%E7%AD%89/:5:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记三 媒体与Intent等","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%89-%E5%AA%92%E4%BD%93%E4%B8%8Eintent%E7%AD%89/"},{"categories":null,"content":"应用图标与任务重排 通过上面的获得的ResolveInfo.loadLable()方法, 可以获取各个activity的名称, 其中还有一个方法loadIcon()可以使用该方法为每一个应用加载显示图标. 关于任务重排, 需要使用ActivityManager系统服务, 该系统服务提供了当前运行activity, 任务以及应用的有用信息. 通过Activity.getSystemService(Activity.ACTIVITY_SERVICE)来获取ActivityManager然后调用ActivityManager实例的getRunningTasks()方法, 得到按照时间由近到久的排序的任务列表. 在调用moveTaskToFront()方法实现将任意任务切换到前台. 关于任务切换需要一些权限配置, 具体参考android文档. ","date":"2016-09-09","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%89-%E5%AA%92%E4%BD%93%E4%B8%8Eintent%E7%AD%89/:6:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记三 媒体与Intent等","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%89-%E5%AA%92%E4%BD%93%E4%B8%8Eintent%E7%AD%89/"},{"categories":null,"content":"进程和任务 进程: 是操作系统创建的供应用对象生存以及应用运行的地方. 包含了应用的全部运行代码和对象. 每一个activity实例都仅存在一个进程和一个任务中. 这也是进程与任务的唯一类似的地方. 任务: 只包含activity, 这些activity通常来自不同应用. activity赖以生存的任务和进程有可能会有所不同. 比如上面的深入了解Intentn中给出的图片参考. 可以发现. 当我没有指定new_task的时候, 新的应用打开的activity是和我们的应用在一个任务栈的. 这也就意味当后退的时候虽然看着只是界面的切换,但是实际上发生了进程间的切换 ","date":"2016-09-09","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%89-%E5%AA%92%E4%BD%93%E4%B8%8Eintent%E7%AD%89/:7:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记三 媒体与Intent等","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%89-%E5%AA%92%E4%BD%93%E4%B8%8Eintent%E7%AD%89/"},{"categories":null,"content":"XmlPullParser使用 XmlPullParser接口采用拉的方式从xml数据流中获取解析事件. Android内部也使用XmlPullParser接口来实例化布局文件. // 模拟一个xml字符串 String textXMLStr = \"\u003cschool\u003e\\n\" + \" \u003cclass name=\\\"1年级\\\"\u003e\\n\" + \" \u003cstudent name=\\\"张三\\\"/\u003e\\n\" + \" \u003cstudent name=\\\"李四\\\"/\u003e\\n\" + \" \u003c/class\u003e\\n\" + \"\\n\" + \" \u003cclass name=\\\"2年级\\\"\u003e\\n\" + \" 优班\\n\" + \" \u003cstudent name=\\\"张三\\\"/\u003e\\n\" + \" \u003cstudent name=\\\"李四\\\"/\u003e\\n\" + \" \u003c/class\u003e\\n\" + \"\\n\" + \"\u003c/school\u003e\"; // 利用xmlPullParser的工厂类创建出一个解析流对象 XmlPullParser xmlPullParser = XmlPullParserFactory.newInstance().newPullParser(); // 把要解析的xml格式的字符串设置到解析流对象中 xmlPullParser.setInput(new StringReader(textXMLStr)); // 准备开始解析 移动指针到第一个标签 int eventType = xmlPullParser.next(); // 如果标签类型不是结束文档标签标示, 那么就标示还有内容继续循环 while(eventType != XmlPullParser.END_DOCUMENT){ // 判断class标签 if (eventType == xmlPullParser.START_TAG \u0026\u0026 \"class\".equals(xmlPullParser.getName())){ String className = xmlPullParser.getAttributeValue(null, \"name\"); Log.e(\"sususu\",\"获得的class标签的名称属性为: \"+className ); } // 判断student标签 if (eventType == xmlPullParser.START_TAG \u0026\u0026 \"student\".equals(xmlPullParser.getName())){ String studentName = xmlPullParser.getAttributeValue(null, \"name\"); Log.e(\"sususu\",\"获得的student标签的属性: \"+studentName ); } // 移动指针到下一个标签 eventType = xmlPullParser.next(); } 运行结果: 代码中的注释已经很详细了, 不用再做解释. 有一点需要注意, 如果要获得便签的内容的话,那么别忘了考虑到空白字符或者换行符的也是存在的. ","date":"2016-09-09","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%89-%E5%AA%92%E4%BD%93%E4%B8%8Eintent%E7%AD%89/:8:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记三 媒体与Intent等","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%89-%E5%AA%92%E4%BD%93%E4%B8%8Eintent%E7%AD%89/"},{"categories":null,"content":" 这本书属于入门, 有很多内容可以当做扩展来了解一些API, 并且有的时候可以适当的利用Google提供好的API来做一些高效开发节约时间成本. 原理东西本书偏少. 可以学习本书中的代码的编写风格, 书中代码都是采用MVC模型来编写的. 就写这么多, 下面开始整理一些小知识点. 关于Fragment的知识点练习都保存在仓库中的Criminal项目中. git地址 ","date":"2016-09-08","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%BA%8C-fragment%E7%9A%84%E6%A6%82%E6%8B%AC/:0:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记二 Fragment的概括","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%BA%8C-fragment%E7%9A%84%E6%A6%82%E6%8B%AC/"},{"categories":null,"content":"Fragment的生命周期 fragment是一种控制器对象, activity可委派其完成一些任务. 通常这些任务就是管理用户界面. 受管理的用户界面可以是一整屏或是整屏的一部分. fragment的生命周期共有11种: onAttach() -\u003e onCreate() -\u003e onCreateView() -\u003e onActivityCreated() -\u003e onStart() -\u003e onResume() -\u003e onPause() -\u003e onStop() -\u003e onDestroyView() -\u003e onDestroy() -\u003e onDetach() Fragment的生命周期和Activity生命周期的最主要的区别就是, Activity的生命周期是由操作系统调用的, 而Fragment的生命周期是由托管的Activity调用的 ","date":"2016-09-08","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%BA%8C-fragment%E7%9A%84%E6%A6%82%E6%8B%AC/:1:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记二 Fragment的概括","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%BA%8C-fragment%E7%9A%84%E6%A6%82%E6%8B%AC/"},{"categories":null,"content":"Fragment的托管的方式 添加\u003cfragment\u003e标签到activity布局中. 并在name属性中指定一个fragment. 在activity代码中添加fragment. 方式1. 即布局fragment. 使用简单, 但是灵活性不够. 直接在xml中添加标签. 就等同于fragment及其视图于activity的视图绑定在了一起, 并且在activity的生命周期过程中无法切换fragment视图. 方式2. 事务管理动态添加. 这种方式可以在运行时控制fragment. 根据需求将fragment在某一个时刻添加到activity中. 也可以移除fragment, 用其他的fragment来替代. 下面的FragmentManager将稍微说明具体使用 ","date":"2016-09-08","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%BA%8C-fragment%E7%9A%84%E6%A6%82%E6%8B%AC/:2:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记二 Fragment的概括","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%BA%8C-fragment%E7%9A%84%E6%A6%82%E6%8B%AC/"},{"categories":null,"content":"Fragment#onCreate(Bundle) 这个方法看起来和Activity#onCreate()相似. 相似归相似说说不同之处. Fragment#onCreate()是公共方法,Activity#onCreate()是受保护的方法. 方法的权限不同, 因为Fragment可以被任何的Activity调用. Activity#onCreate()这个方法已经准备生成视图, 而Fragment#onCreate()却并没有要生成视图的动作. Fragment生成视图的方法是另一个生命周期onCreateView()方法. 这个方法会将生成的View返回给托管的activity. 相同之处, 同样像activity那样具有保存及获取状态的Bundle, 和onSaveInstanceState() ","date":"2016-09-08","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%BA%8C-fragment%E7%9A%84%E6%A6%82%E6%8B%AC/:3:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记二 Fragment的概括","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%BA%8C-fragment%E7%9A%84%E6%A6%82%E6%8B%AC/"},{"categories":null,"content":"FragmentManager及其事务 FragmentManager类负责管理fragment并将它们的视图添加到activity的视图层级结构中. 相当于连接这两个的桥梁. FragmentManager具体管理的是: fragment队列. fragment事务的回退栈. FragmentManager的获取 如果现在要动态添加一个fragment那么首先需要在activity中获取fragmentManager. 通过FragmentActivity#getSupportFragmentManager().这里调用的是支持库的FragmentActivity. 目前官方Android 24中使用的默认是AppCompatActivity这个扩展兼容类. 其实这个类就是FragmentActivity的子类. 当然如果你就是使用Activity那么就调用getFragmentManager()一样可以. 管理fragment的事务 FragmentManager管理者拿到了, 就可以开启事务做一些我们想做的事情. // 获得Fragment 的管理者对象 FragmentManager fm = getSupportFragmentManager(); // 先查找管理者中是否已经存在, 如果不存在就new一个 Fragment fragment = fm.findFragmentById(R.id.activity_main); if (fragment == null) { // 方法内部实现要进行添加Fragment的创建并返回 fragment = createFragment(); fm.beginTransaction() .add(R.id.activity_main, fragment) .commit(); } 首先利用了Fragment#findFragmentById()去fragment队列获取一个fragment. 如果有那么就不需要添加.如果没有重新进行事务添加. 为什么要这么做? (例如屏幕旋转, 虽然activity会被销毁重建, 但是FragmentManager会将Fragment队列保存下来. 这样当重启的时候就可以直接获取队列已经创建好的而不需要重复创建) 这段代码片段主要就是提交了一个fragment事务. fragment事务被用来添加,移除,附加,分离或替换fragment队列中的fragment. add()方法中首先指定activity的xml布局中的一个控件用来替换成被创建的fragment视图.然后参数2传入了要被添加的fragment ","date":"2016-09-08","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%BA%8C-fragment%E7%9A%84%E6%A6%82%E6%8B%AC/:4:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记二 Fragment的概括","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%BA%8C-fragment%E7%9A%84%E6%A6%82%E6%8B%AC/"},{"categories":null,"content":"ListFragment使用 是Fragment的子类, 并且内置了ListView提供给开发者快速创建列表的需求. 默认已经生成了一个全屏的ListView布局. 继承ListFragment派生出一个子类. (这个时候如果什么数据也不添加运行程序,会发现中间会有一个progressBar在一直旋转) 由于ListView已经存在. 所以按照我们平常的开发流程接下来就应该创建适配器,并添加到ListView. (这里使用快速的ArrayAdapter,也可以继承BaseAdapter来实现一些复杂的布局) // 创建系统预定义的实例 ArrayAdapter\u003cCrimeBean\u003e myAdapter = new ArrayAdapter\u003c\u003e(getActivity().getApplicationContext(), android.R.layout.simple_list_item_1, mCrimes); // 是ListFragment类提供的一个便利方法, 可以管理内置的listView设置adapter setListAdapter(myAdapter); 创建一个ArrayAdapter传入三个参数 参数一: 上下文. 直接获取托管的activity的全局上下文即可 参数二: ListView中的Item条目要显示的布局. 这里使用了系统提供的布局. 这个布局里面就是一个TextView. 参数三: 数据集合ArrayList. 可以看到上面生成的ArrayAdapter的泛型是CrimeBean.这个泛型就是根据传入的数据集合中的泛型所指定. 如果数据集合中添加的一个自定义类的实例,一定要复写类的toString()确定返回一个类的说明或者名称等. 不然如果数据集合填充的引用数据类型那么默认toString()会就会返回对象的地址值, 这对我们毫无用处(其实内部就是Adapter#getView()方法内进行每个子Item的数据填充的时候获取集合中对应的position的数据然后.toString()获取到字符串填充到TextView上) 最后通过内部提供绑定适配器的方法添加即可setListAdapter() 现在可以正常显示数据了. 添加点击事件 在ListFragment中提供了点击item事件的方法. 直接覆盖onListItemClick(...)即可. 在ListFragment通过getListAdater().getItem(int)即可获得adapter中对应数据集合中对象 如果需要自定义一个布局, 可以直接派生出一个ArrayAdapter的子类. 创建一个构造方法,和复写getView()方法即可, 不需要继承BaseAdapter要复写四个方法(这里看自己的实际需求来决定用那种适配器) /** * 定制list的列表项, 继承adapter 重写getView方法 */ private class MyCrimeAdapter extends ArrayAdapter\u003cCrimeBean\u003e{ public MyCrimeAdapter(ArrayList\u003cCrimeBean\u003e crimes) { // 由于这里不打算使用预定义的布局, 所以参数2传递了资源id为0, super(getActivity().getApplicationContext(), 0, crimes); } @NonNull @Override public View getView(int position, View convertView, ViewGroup parent) { ViewHolder holder ; // 这里省略布局实现的逻辑, 想实现什么就实现什么布局 return convertView; } } ","date":"2016-09-08","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%BA%8C-fragment%E7%9A%84%E6%A6%82%E6%8B%AC/:5:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记二 Fragment的概括","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%BA%8C-fragment%E7%9A%84%E6%A6%82%E6%8B%AC/"},{"categories":null,"content":"使用fragment argument 每个Fragment实例都可附带一个Bundle对象. 附加argument给Fragment调用Fragment.setArguments(Bundle)即可. 需要注意,附加的时机必须在fragment创建之后并且添加到activity之前 如果想要获取在托管的activity的intent中的值. 有两种方式. 当需要的时候就通过getActivity().getIntent() 利用argument在被托管前就给Fragment自己存储一些属性值. 还是第二种好一些. 我们可以在Fragment内部暴露一个方法如下: public static CrimeFragment newInstance(UUID crimeId){ Bundle bundle = new Bundle(); bundle.putSerializable(EXTRA_CRIME_ID, crimeId); CrimeFragment crimeFragment = new CrimeFragment(); crimeFragment.setArguments(bundle); return crimeFragment; } 这样当activity需要托管添加的时候只需要调用我们提供的方法就可以. 具体的封装动作对activity来说是透明的. activity只需要获取到intent的值在调用fragment#newInstance()传入即可. 相对于第一种更好的将数据管理在自己的所在区域. 并且也不像第一种那样比较依赖Activity. 获取argument getArguments()就可获得Bundle. ","date":"2016-09-08","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%BA%8C-fragment%E7%9A%84%E6%A6%82%E6%8B%AC/:6:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记二 Fragment的概括","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%BA%8C-fragment%E7%9A%84%E6%A6%82%E6%8B%AC/"},{"categories":null,"content":"fragment获取返回结果 在Fragment中同样可以使用startActivityForResult()和onActivityResult(). 虽然这两个方法和Activity很像, 但是如果你想设置setResult()那么请调用getActivity().setResult(). ","date":"2016-09-08","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%BA%8C-fragment%E7%9A%84%E6%A6%82%E6%8B%AC/:7:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记二 Fragment的概括","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%BA%8C-fragment%E7%9A%84%E6%A6%82%E6%8B%AC/"},{"categories":null,"content":"DialogFragment 是Fragment的子类, 和ListFragment一样内部封装了AlertDialog视图, 为按照Android开发原则, 统一利用FragmentManager来进行管理. 不同之处: 当设备旋转的时候独立配置的AlertDialog会在旋转之后消失, 而配置封装在fragment中的AlertDialog则不会消失. 这里实现目的是弹窗显示日期控件, 本身AlertDialog还有一个专门对日期操作的类DatePickerDialog.由于兼容性这里没有使用. 先总结一下实现对话框显示, 需要完成的任务: 派生出一个DialogFragment的子类. 创建AlertDialog 通过FragmentManager在屏幕上显示对话框. 第一步略过直接创建类继承就可以. 第二步通过复写onCreateDialog(Bundle)方法. 只需要创建一个AlertDialog返回即可, 系统会帮助你显示.如下: @NonNull @Override public Dialog onCreateDialog(Bundle savedInstanceState) { // 直接返回在Activity中创建Dialog的方式生成的对象 AlertDialog.Builder builder = new AlertDialog.Builder(getActivity()) .setTitle(\"标题\") .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { sendResult(Activity.RESULT_OK); } }) // 设置中间区域要显示的View , 可以实现自定义View传入 .setView(inflate); AlertDialog alertDialog = builder.create(); return alertDialog; } setTitle() 设置标题栏的文字. setView() 实现在标题栏于按钮之间显示传入的View对象. setPositiveButton() 设置一个对话框的按钮(Android中有3种对话框按钮可使用:positive按钮, negative按钮,neutral按钮. )旧版本里面positive按钮出现在最左端, 新版本系统则出现则最右边. AlertDialog.Builder.create() 返回已配置完成的AlertDialog实例, 完成对话框创建. 第三部就是显示对话框了. 和其他的fragment一样, DialogFragment实例也是由托管activity的FragmentManager管理者的. 通过DialogFragment的以下两个方法都可以. public void show(FragmentManager manager, String tag) public void show(FragmentTransaction transaction, String tag) String类型参数可唯一识别存放在FragmentManager队列中的DialogFragment. 可以按需选择使用FragmentManager还是FragmentTransaction. 如果传入FragmentManager参数, 则事务可自动创建并且提交. 代码例子如下: FragmentManager fm = getActivity().getSupportFragmentManager(); DatePickerFragment dialog = new DatePickerFragment; //派生出来的DialogFragment的子类 dialog.show(fm, DIALOG_DATE); ","date":"2016-09-08","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%BA%8C-fragment%E7%9A%84%E6%A6%82%E6%8B%AC/:8:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记二 Fragment的概括","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%BA%8C-fragment%E7%9A%84%E6%A6%82%E6%8B%AC/"},{"categories":null,"content":"Fragment之间的数据传递 对于activity之间或者基于fragment的activity之间的数据传递. 已经了解. 那么如果是同一个activity托管的不同fragment之间的传递应该如何处理,比如上面如何从DialogFragment点击按钮把数据发送给另一个fragment? 大体流程分为两步: 设置目标Fragment 传递数据给目标Fragment 在目标Fragment中对onActivityResult()进行数据接收处理 对应实现: 通过dialog.setTargetFragment(CrimeFragment.this, REQUEST_DATE); 设置弹出的AlertFragment要返回数据的目标Fragment后, 目标fragment和请求码有FragmentManager负责跟踪记录, 在需要的时候通过调用设置目标fragment的fragment中的getTargetFragment()和getTargetRequestCode()方法来获取. 设置信息都已经准备完毕, 现在只需要进行数据传递即可. 在要进行传递的起始Fragment中调用getTargetFragment()获取到目标(要传送的目标)Fragment. 用获取到的对象调用onActivityResult()即可, 参数分别是,请求码,结果码,和传递数据的intent 就很简单了, 和activity一样接收数据并处理即可. ","date":"2016-09-08","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%BA%8C-fragment%E7%9A%84%E6%A6%82%E6%8B%AC/:9:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记二 Fragment的概括","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%BA%8C-fragment%E7%9A%84%E6%A6%82%E6%8B%AC/"},{"categories":null,"content":"Fragment的保留问题 场景: 还是设配配置发生改变的时候,会出现Activity的重建. 那么如果Activity里面托管一个Fragment. 而这个Fragment的作用是在播放音乐. 并且在onDestroy()的时候会释放掉MediaPlayer对象, 那么即使使用onSaveInstanceState()来保存意外销毁的进度, 但仍然会发生卡顿. 解决: 可在Fragment#onCreate()方法中设置一个属性setRetainInstance(true) 方法说明 : Fragment中的retainInstance属性默认是为false. 这表明不会被保留. 因此设备旋转的时候. fragment会随着托管activity一起销毁并且重建. 如果设置了为true. 那么会进行保留, 已保留的fragment不会随着activity的异常重建而一起销毁. 而在activity重建之后再把自己原封不动的传递给新建后的activity. (和保留的fragment中的成员属性也是可以继续使用的.) 保留fragment的工作原理: 可以总结为可销毁重建fragment的视图,但无需销毁fragment自身. 当设备发生改变的时候, FragmentManager首先会销毁队列中的fragment的视图. 需要销毁重建的原因与activity重建的理由是完全一样的:新的配置可能需要新的资源来匹配,去查找是否有更合适的匹配资源可以利用不,则就需要重新创建视图. 当把视图都销毁掉以后, FragmentManager就会检查每个Fragment的retainInstance的属性值. 如果为false那么管理者就会销毁这个fragment的实例. 然后为使用新的设备配置, 新的activity的新的FragmentManager会创建一个新的fragment以及视图. 但是如果retainInstance的属性为true那么, fragment本身实例不会被销毁. 当新的activity创建后, 新的FragmentManager会找到被保留的fragment, 并重新创建它的视图. 有一个特殊的状态时发生Fragment的onDestroyView()声明周期之后的. 如果不被保留那么就会调用onDestroy()和onDetach(). 如果被保留那么就只会调用onDetach(). 此时此fragment没有任何的activity在托管它. 需要注意Fragment处于保留状态的时间非常短暂, 就是fragment脱离了旧的activity到重新附加给立即创建的新的activity之间一段时间 fragment必须同时满足两个条件才会进入保留状态: Fragment的setRetainInstance的属性为true. 因设备配置改变, 托管的activity正在销毁中. ","date":"2016-09-08","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%BA%8C-fragment%E7%9A%84%E6%A6%82%E6%8B%AC/:10:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记二 Fragment的概括","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%BA%8C-fragment%E7%9A%84%E6%A6%82%E6%8B%AC/"},{"categories":null,"content":" 这本书属于入门, 有很多内容可以当做扩展来了解一些API, 并且有的时候可以适当的利用Google提供好的API来做一些高效开发节约时间成本. 原理东西本书偏少. 不过可以学习本书中的代码的编写风格, 书中代码都是采用MVC模型来编写的. 就写这么多, 下面开始整理一些小知识点. ","date":"2016-09-07","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%80/:0:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记一 零散知识整理","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%80/"},{"categories":null,"content":"Activity的生命周期 有7种分别为: 除去onRestart()比较特殊一点的生命周期. 可以把activity认为分别在3种状态切换, 分别是运行, 暂停, 停止. ","date":"2016-09-07","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%80/:1:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记一 零散知识整理","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%80/"},{"categories":null,"content":"配置文件改变导致Activity重建,如屏幕旋转 设备配置(device configuration)是用来描述设备当前状态的一系列特征. 这些特征包括屏幕的方向, 手机语言, 屏幕的密度, 屏幕的尺寸, 键盘类型, 底座模式等 在开发中有时候需要为了匹配不同的设备配置, 我们会提供多套副本文件. 比如说: 图片放在不同的dpi密度的文件夹下; 适应手机的横竖屏创建不同的文件夹并编写不同展示风格的xml布局放入. 创建不同语言的strings文件. 来实现语言国际化 ….. 这里列举一下创建水平模式下加载另一个布局文件, 在res/资源文件夹下创建一个layout-land目录, 创建一个与layout文件夹中布局文件名称相同的xml. 然后编写想在横屏时候需要显示的布局. 其实当手机处于横屏的时候需要加载资源文件. 这个时候系统首先查找开发者是否创建对应横屏的文件夹就是layout-land,如果有. 那么继续查找资源ID所对应的文件是否存在. 如果存在那么就加载这个文件. 如果没有就从layout文件夹中加载默认的文件(layout文件夹优先级基本上是最低的) ","date":"2016-09-07","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%80/:2:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记一 零散知识整理","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%80/"},{"categories":null,"content":"异常重建时Activity的数据保存 由于本地手机的配置文件的改变, 如屏幕旋转造成了Activity的重建. 这个时候就会导致已经实例对象或者属性赋值全部丢失. 利用onSaveInstanceState(Bundle)一般会在onPause()之后被调用. 把要存储的数据添加到onSaveInstanceState()的参数类型为Bundle的参数中. 然后当销毁后的重建时, 会在onCreate()方法中会传回一个Bundle类型的对象. 可以取出. 如果不是异常销毁重建那么默认情况下onCreate()回调方法带回的Bundle类型的参数是为null的. ","date":"2016-09-07","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%80/:3:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记一 零散知识整理","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%80/"},{"categories":null,"content":"SDK版本小解和兼容处理 SDK最低版本: 当应用安装的时候, 手机会检测如果本身系统等级如果低于应用指定的最低版本那么应用无法安装. SDK目标版本 应用是设计给哪个API级别去运行的. 大多数情况下, 目标版本即最新发步的Android版本. SDK编译版本 Compile. 前两个是通知手机设备的. 而这个属性是告知Android Studio编译器使用哪一个SDK版本进行代码编译. 有时候我们可能会使用高版本的API. 但是有可能手机的版本会低于这个API的出现版本. 这个时候就需要在代码中进行逻辑判断分支. Build.VERSION.SDK_INT: 代表了当前运行的Android手机的版本号. 通过判断当前手机的版本号, 这样就可以针对不同的场景进行分支处理. ","date":"2016-09-07","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%80/:4:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记一 零散知识整理","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%80/"},{"categories":null,"content":"XML布局属性 样式,主题, 主题属性 **样式(style)**是xml资源文件, 含有用来描述组件行为和外观的属性定义的集合. 例如在res/valus/styles.xml中声明如下样式. \u003cstyle name=\"BigTextStyle\" \u003e \u003citem name=\"android:textSize\"\u003e20sp\u003c/item\u003e \u003citem name=\"android:layout_margin\"\u003e5dp\u003c/item\u003e \u003c/style\u003e 在以后的所有大的文字控件textView,button.都可以直接引入一个style属性. 当重复的属性越多, 使用的控件也越多, 这种好处是不言而喻的. 主题(theme) Android自带了一些供应使用的预定义平台主题. 例如: android:theme=\"@style/Theme.AppCompat.Light\". 引用主题属性: \u003cTextView android:layout_width=\"match_parent\" android:layout_height=\"wrap_content\" style=\"?android:listSeparatorTextViewStyle\"/\u003e 例如这样后, 你会发现textView会带有margin,字体颜色,加粗等一些属性. 这就在一些场合很方便的设置了一些属性. 并且也能达到我们看着不那么丑的需求. dp, sp dp (density-independent): 一般用于设置控件宽高和margin,padding. dp值代表的实际长度与手机的屏幕分辨率和屏幕尺寸没有直接关系,但是有间接关系. 是这样. 根据屏幕的分辨率和屏幕尺寸会得到一个屏幕的像素密度. 根据这个屏幕像素密度来决定1dp在当前设备代表着几个像素点. sp (scale-independent pixel): . 主要用于字体. 和dp相似会根据手机的密度来动态的选择对应的大小. 但是有一点不同. 这种像素会受手机字体的偏好设置而改变 布局参数 对于资源文件xml中标签的属性android:layout_width,android:layout_margin,android:text等等, 为什么有的属性前面有layout开头, 而有的没有呢. 其实名称以layout_来头的属性是作用于组件的父组件. 我们将这些属性统称为布局参数. 它们会告知父布局如何在内部安排自己的子元素. 而不以layout_开头的属性是作用于组件的. 组件生成时, 会调用某个方法按照属性即属性值进行自我配置. 外边距于内边距 根据上面的结论, 应该就可以看出layout_margin,padding这两个属性. 一个是作用父布局一个是作用在自己身上的. 所以在自定义ViewGroup的时候不仅要获取子孩子的宽高还要获取margin这样才能正确的布局. 而在自定义View的时候我们往往要兼顾到padding这个属性. 不然设置padding的属性就会无效果. ","date":"2016-09-07","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%80/:5:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记一 零散知识整理","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%80/"},{"categories":null,"content":"ViewPager简单介绍 ViewPager在某种程度上有点类似于AdapterView(ListView的超类). AdapterView需借助于Adapter才能提供视图. 所以同样的ViewPager也需要PagerAdapter的支持. ViewPager可能开发中用的很多. 在使用ViewPager作为一个fragment容器的时候. FragmentManager要求其容器视图必须具备id属性. 所以如果是代码中动态的创建ViewPager.那么别忘了设置id属性, 如下: protected void onCreate(@Nullable Bundle savedInstanceState) { super.onCreate(savedInstanceState); // 动态创建ViewPager并设置到setContent mViewPager = new ViewPager(getApplicationContext()); // 如果需要对Fragment进行托管, 那么要求其容器视图必须具备资源ID mViewPager.setId(R.id.vp_main); setContentView(mViewPager); } // 在res/values/ids.xml 没有可以新建一个,为了创建独立资源id \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cresources\u003e \u003citem name=\"vp_main\" type=\"id\"/\u003e \u003c/resources\u003e 这样就可以实现动态添加ViewPager并作为Fragment的容器了. 由于直接通过PagerAdapter派生出子类有很多场景步骤过于复杂. 我们可以根据具体作用场景来选择其子类来作为ViewPager的适配器.比如说FragmentStatePagerAdapter 实现很简单如下: 复写两个方法就可以 // 在fragment中的onCreate()中直接设置就可以 // 利用ViewPager的子类 FragmentStatesPagerAdapter可以简单的处理并是实现 // 当使用fragment 还有一个选择FragmentPagerAdapter 两者的区别是在卸载不再需要的fragment的时候有所不同 // FragmentPagerAdapter创建的fragment只是有销毁视图的动作, 没有将其从FragmentManager里面删除 FragmentManager fm = getSupportFragmentManager(); mViewPager.setAdapter(new FragmentStatePagerAdapter(fm) { @Override public Fragment getItem(int position) { //...相当于每个pager要展示的fragment. return crimeFragment; } @Override public int getCount() { // 返回Pager页的大小 return mCrimes.size(); } }); 可以看到当创建了FragmentStatePagerAdapter(..)传入了一个FragmentManager给其构造方法. 因为实际上FragmentStatePagerAdapter是我们的代理, 负责管理与ViewPager的对话并协同工作.代理需首先将getItem()方法返回的Fragment添加到Activity. 然后才能使用fragment完成自己的工作. 这也是需要传递fm的原因. 如果需要监听ViewPager的滑动事件 给ViewPager设置setOnPageChangeListener()注册一个回调监听, 里面有三个状态回调: onPageScrollStateChange: 告知当前页面所处的行为是什么. onPageScrolled: 告知当前显示的页面是哪个, 并且现在已经滑动导致的偏移距离是多少. onPageSelected: 告知页面滑向了哪里.可以得知是在数据集合中的第几个Pager被显示出来了 关于FragmentStatePagerAdapter与FragmentPagerAdapter 主要区别就是: 二者在卸载不再需要的fragment时,所采用的处理方式有所不同 FragmentStatePagerAdapter: 会销毁不需要的fragment. 事务提交后, 可将fragment从activity#FragmentManager中彻底移除. 而类名中的state表明: 在销毁Fragment时, 他会将其onSaveInstanceState()方法中的bundle信息保存下来. 当用户切换回来的时候, 保存实例状态可用于恢复生成新的fragment FragmentPagerAdapter: 对于不再需要的fragment, 其对应的FragmentManager则选择调用事务的detach(Fragment)方法. 而非remove(Fragment)方法. 也就是说,FragmentPagerAdapter只是销毁了fragment的视图, 但仍将fragment实例保留在FragmentManager中 而如何取决需要按场景来使用: FragmentStatePagerAdapter更节省内存. 如果需要展示的数据很多,如果使用FragmentPageAdapter那么会保存大量的信息, 并且占用很多空间就不是很合适. 所以如果用户界面只需要少量固定的fragment. 那么使用FragmentPagerAdapter比较合适. 否则就反之使用FragmentStatePagerAdapter. ","date":"2016-09-07","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%80/:6:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记一 零散知识整理","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%80/"},{"categories":null,"content":"资源文件的配置与匹配 先看一下以下项目结构目录截图: 有三个value文件夹, 第一个为我们的默认加载的value, 第二个为使用了横屏修饰符修饰声明, 第三个使用了指定语言修饰符声明. 里面都有一个strings文件夹看一下内容. 这里只拿app_name属性来说明测试, 三个文件都有此属性. 具有不同的修饰符的同种功能的文件夹是具有不同优先级的. 还是以上面的图片为例子. 如果说在首页Activity引用了app_name这个字符串. 那么根据不同的场景会去加载不同的资源文件. 如果本地语言指定了中文: 那么就会加载values-zh文件中的资源(此文件夹的配置修饰符优先级在上面的三种场景最高). 如果本地语言非中文, 并且是横屏状态下: 那么会加载values-land文件中的资源 如果即没有指定为中文,也不是横屏状态下, 那么就加载默认的资源文件 values文件夹 可以看出来app加载资源文件的时候是按照一定优先级去加载的, 首先会先排除掉不兼容当前设备配置的资源目录. 如果有多个文件匹配那么高优先级的文件夹首先会检查当前手机环境对应的配置是否匹配(比如是否横屏,是否设置某种本地语言). 匹配成功之后就会加载对应的文件夹下的内容. 而低优先级的对应功能的文件夹不会再去加载. 但是如果发现匹配不成功或者成功之后没有找到对应的属性那么还会继续往低优先级的查找. 直到找到为止. 所以可以看出一个属性值,最少要保证在资源文件中存在一份. 否则会出现加载错误, 并且需要处理好场景之间无值可选的问题. 下面列出大部分具有配置修饰符的设备特征. 他们的优先级从高到低排列的 优先级(数值越低越高) 特征说明 1 移动国家码, 通常附有移动网络码 2 语言代码, 通常附有地区代码 3 布局方向 4 最小宽度 5 可用宽度 6 可用高度 7 屏幕尺寸 8 屏幕纵横比 9 屏幕方位 10 UI模式 11 夜间模式 12 屏幕显示密度 13 触摸屏类型 14 键盘可用性 15 首选输入法 16 导航键可用性 17 非文本导航方法 18 API级别 资源文件夹也可以使用多重配置修饰符, 例如values-zh-land, 各修饰符必须按照优先级高低排序.否则无效. 例如values-land-zh就是无效的目录. 这里就不细说. 可在官网guide/topics/resources/providing-resources查看. 资源命名 资源的文件只能有小写字母组成并且不能包含空格. 无论是在XML中还是在代码中引入资源, 引用都不包括文件的扩展名. 所以在同级目录下不能以文件的扩展名作为依据来区分命名相同的文件. 也不允许同级下名称相同扩展名不同的文件存在,在编译时候会报错 布局文件命名 最好按文件名排序的声明文件名. 通常以其定义的视图类型名为前缀. 如activity_,dialog_,list_item_.这样查找分类就容易多了. 资源目录结构 所有的资源都应该保存在res/目录的子目录下, 常见的子目录有drawable/,mipmap/,layout/,values/,raw/, menu/等. Android会无视res/目录下的其他子目录. ","date":"2016-09-07","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%80/:7:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记一 零散知识整理","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%80/"},{"categories":null,"content":"操作栏 也可以认为是title bar. 说法很多. 如下 可显示在操作栏上的菜单被称作选项菜单, 选项菜单类似于popupWind.可以作为用户的扩展操作. 1.首先在XML文件中定义选项菜单 res/menu/目录下创建一个xml. 根标签为\u003cmenu\u003e如下 或者你可以这样 showAsAction属性用于指定菜单选项是显示在操作栏上, 还是隐藏到溢出菜单中. 比如上图中的app:showAsAction=\"ifRoom|withText\"是一个组合属性. 代表着只要操作栏可用的控件足够,菜单项图标和文字描述都会显示在操作栏中. 这个属性值不设定的情况下默认是溢出菜单模式显示的. 如果空间仅够显示图片那么文字不会显示, 如果剩余空间即不够显示文字也不够显示图标, 那么菜单项会被转移隐藏到菜单中. 上面这个属性值还有两个可设置项always和never. 不推荐使用always, 应尽量使用更方便的ifRoom属性值, 让操作系统系统决定如何显示菜单项. 对于那些很少用到的菜单项, 使用never是个不错的选择. icon: 属性使用了系统的图标资源. 这个资源只存在于设备上. 2. 菜单文件创建完之后,就该代码设置了 首先Activity提供了管理选项菜单的回调函数. 在需要选项菜单的时候, Android会调用其onCreateOptionsMenu()方法. 如果你使用的是Fragment那么也没关系因为Fragment也有同名的函数为你使用. 接下来以在Fragment为例说明. 复写onCreateOptionsMenu()函数. 通过inflate进行填充布局到menu对象中. 如下 @Override public void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) { // 为操作栏创建浮动的上下文菜单 mActivity.getMenuInflater().inflate(R.menu.crime_list_item_context, menu); } 然后在Fragment#onCreate()方法中添加一段代码 setHasOptionsMenu(true); 说明: Fragment#onCreateOptionsMenu()方法是由FragmentManager负责调用的. 因此当activity接收到来自操作系统的onCreateOptionsMenu()方法回调请求时, 我们需要明确的告诉FragmentManager需接收选项菜单的方法回调.就是setHasOptionsMenu(). 现在我们的选项菜单就已经可以显示出来. 3. 响应菜单选项选择的事件 既然添加了扩展功能的选项, 那么必定需要实现某些点击事件. 通过复写onOptionsItemSelected()来进行处理. 有于我们可能在menu.xml中声明了多个item. 为了区分点击的是哪一个. 可以通过id来识别不同的点击触发. 如下 @Override public boolean onOptionsItemSelected(MenuItem item) { switch (item.getItemId()){ case R.id.menu_item_new_crime: // 做一些想做的事情 return true; case R.id.menu_item_show_subtitle: // 设置操作栏的子标题 ActionBar supportActionBar = ((AppCompatActivity) getActivity()).getSupportActionBar(); if (supportActionBar.getSubtitle() == null){ supportActionBar.setSubtitle(sub_description); item.setTitle(R.string.hide_subtitle); }else{ supportActionBar.setSubtitle(null); item.setTitle(R.string.show_subtitle); } return true; default: return super.onOptionsItemSelected(item); } } 你可能看到上面有一行注释写的设置操作栏的子标题这个的效果如下图. 4. 层级式导航,向左后退箭头 虽然大多数都是自定义的titlebar, 但是对于系统的默认后退也应该了解. 通过Activity#getSupportActionBar().setDisplayHomeAsUpEnable(). (通过测试发现当在二级界面的时候默认都会出现向左的后退箭头但是默认的是没有处理的, 需要在onOptionsItemSelected()做对应的处理,我这里测试的环境为sdk为24,使用的AppCompatActivity派生的子类) 所以如果是fragment开发为基础, 那么别忘了setHasOptionsMenu(true), 允许FragmentManager对自己的fragment队列进行菜单选项的事件分发回调. 如下: @Override public boolean onOptionsItemSelected(MenuItem item) { switch (item.getItemId()){ // android.R.id.home 就是默认的向左箭头组件的id case android.R.id.home: getActivity().finish(); return true; default: return super.onOptionsItemSelected(item); } } 还有一个问题! Android编程, 有时候你以为已经丝入扣, 天衣无缝, 可以高枕无忧的时候上线, 总是会被人提醒到好像还有一个问题! 上面的二级标题是否还记得. 有这么一个场景如果二级标题显示了, 但是发生了设备旋转! ok 那么重建后你会发现二级标题不存在了. 这时就可以使用setRetaionInstance(true)来保存成员属性. 并利用一个布尔值来控制在创建菜单选项的时候二级标题是否需要显示. ","date":"2016-09-07","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%80/:8:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记一 零散知识整理","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%80/"},{"categories":null,"content":"Android的文件系统与Java I/O 在操作系统级别, Android运行在Linux内核之中, 因此,它的文件系统类似于其他一些Linux或Unix系统. 目录名称已正斜杠/分隔. 文件名可由各类字符组成, 且区分大小写. 受益于Linux的安全模式, 应用都是以特定的用户ID运行的. Android利用应用的java包名, 来决定应用在文件系统中的存放位置. 用于发布与安装, 应用本身被打包成APK文件格式. 被放置在/data/app目录. 当然这是需要进行root权限才可以的. 访问文件和目录 应用访问文件和目录最便捷的方式是使用Content类提供的方法. Content类是所有关键应用组件的超类. 下面是Content提供的基本文件或目录的便捷方法 方法 使用目的 File getFilesDir() 获取data/data/\u003cpackname\u003e/files目录 FileInputStream openFileInput(String name) 打开data/data/\u003cpackname\u003e/files/目录下的name文件名的文件获得输入流 FileOutputStream openFileOutput(String name, int mode) 同上, 这个是获得输出流, 不同之处如果没有这个文件那就会自动创建 File getDir(String name, int mode) 获取data/data/\u003cpackname\u003e/name名称的文件夹目录(没有就会先创建) String[] fileList() 获取data/data/\u003cpackname\u003e/files目录下的所有文件名称列表. File getCacheDir() 获取data/data/\u003cpackname\u003e/cache目录 ","date":"2016-09-07","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%80/:9:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记一 零散知识整理","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%80/"},{"categories":null,"content":"系统的多选模式 如下效果: 开始实现步骤: 1. 首先定义多选菜单的资源文件 例如上面的垃圾桶图标需要手动去设置, 在res/menu/目录下创建一个xml \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cmenu xmlns:android=\"http://schemas.android.com/apk/res/android\"\u003e \u003citem android:id=\"@+id/menu_item_delete_crime\" android:icon=\"@android:drawable/ic_menu_delete\" android:title=\"@string/delete_crime\"/\u003e \u003c/menu\u003e 同样使用系统的资源图片, 就是右上角的垃圾桶. 2. 实现Content菜单(进入编辑模式) 这里面有两种,在旧版本11之前上编辑模式是单项操作模式, 后续版本是多选模式, 下面简单说一下旧版本的模式然后在回到上面图中的多选模式, 可以直接跳过直接看多选模式, 毕竟11版本已经很旧了 于之前的操作栏里面的步骤大致相同. 这里复写的方法是有两个(fragment类中) onCreateContextMenu(...): 实例化一个Content多选菜单 onContextItemSelected(...): 响应菜单选择按钮 这里还是以在fragment中的代码举例. @Override public void onCreateContextMenu(ContextMenu menu, View v, ContextMenu.ContextMenuInfo menuInfo) { // 为操作栏创建浮动的上下文菜单 mActivity.getMenuInflater().inflate(R.menu.crime_list_item_context, menu); } // 浮动上下文的点击监听回调 @Override public boolean onContextItemSelected(MenuItem item) { switch (item.getItemId()){ // 显示删除的浮动上下文 case R.id.menu_item_delete_crime: // 获得点击的具体listview的item位置, 并得到对象 AdapterView.AdapterContextMenuInfo menuInfo = (AdapterView.AdapterContextMenuInfo) item.getMenuInfo(); // 获得点击的item信息得到posion int position = menuInfo.position; CrimeBean clickItemBean = ((MyCrimeAdapter) getListAdapter()).getItem(position); // mCrimes.remove(clickItemBean); ((MyCrimeAdapter) getListAdapter()).notifyDataSetChanged(); return true; default: return super.onContextItemSelected(item); } } 最后一步为ContextMenu登记一个ListView如下 // 在低版本使用浮动上下文菜单 registerForContextMenu(lv_main); 回到多选模式, 还是多选好 接着第二大步开始. 如果要想实现多选模式的ContextMenu. 那么需要设置列表视图的选择模式为ListView.CHOICE_MODE_MULTIPLE_MODAL, 然后并添加个监听响应即可,其实很简单. lv_main.setChoiceMode(ListView.CHOICE_MODE_MULTIPLE_MODAL); // 设置列表视图操作模式回调 lv_main.setMultiChoiceModeListener(new AbsListView.MultiChoiceModeListener() { // 视图中的选项在选中或者撤销的时候会触发 @Override public void onItemCheckedStateChanged(ActionMode mode, int position, long id, boolean checked) { } // 在ActionMode对象创建后调用, 也是实例化上下文菜单资源, 并显示在上下文操作栏上的任务完成的地方 @Override public boolean onCreateActionMode(ActionMode mode, Menu menu) { MenuInflater menuInflater = mode.getMenuInflater(); menuInflater.inflate(R.menu.crime_list_item_context, menu); return true; } // 在onCreateActionMode()回调之后调用, 以及当前上下文操作栏需要刷新显示新数据时调用 @Override public boolean onPrepareActionMode(ActionMode mode, Menu menu) { return false; } // 在用户选中某个菜单项操作时调用(这里就是垃圾桶图标按钮). 是相应上下文菜单项操作的地方 @Override public boolean onActionItemClicked(ActionMode mode, MenuItem item) { switch (item.getItemId()){ case R.id.menu_item_delete_crime: for (int i = myCrimeAdapter.getCount()-1; i \u003e= 0; i--) { if (getListView().isItemChecked(i)){ mCrimes.remove(myCrimeAdapter.getItem(i)); } } mode.finish(); myCrimeAdapter.notifyDataSetChanged(); return true; } return false; } // 在用户退出上下文操作模式或所选菜单项操作已被响应, 从而导致ActionMode对象将要销毁时调用. // 默认的实现会导致已选视图被反选, 也可以完成上下文操作模式下, 响应菜单项操作而引起的响应fragment刷新 @Override public void onDestroyActionMode(ActionMode mode) { } }); 3. 最后一步 这个最后一步是针对多选模式下的, 上面两步已经在逻辑功能上完成了之前的需求, 但是有一点, 当进入多选的时候点击或不点击发现没有区别, 我们无法得知哪一个item是否已经被点击激活状态, 哪一个没有没点击激活. 所有我们需要给Item添加一个背景, 设置一下item的激活或者非激活的背景色, 代码如下: // 在drawable/文件夹下创建一个文件 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cselector xmlns:android=\"http://schemas.android.com/apk/res/android\"\u003e \u003c!--当引用控件处于激活状态时, 则使用指定的资源文件, 反之不采取任何操作--\u003e \u003citem android:state_activated=\"true\" android:drawable=\"@android:color/darker_gray\"/\u003e \u003c/selector\u003e 把这个StateListDrawable状态drawable设置到ListView的item背景属性上. ok 关于多选的ContentMenu操作就实现完成. 扩展一下: 这里实现的方法可以完全作用在ListView和GridView中(GridView和ListView都是AdapterView的子类). 但是如果不是这两个类型的控件应该如何实现这种多选方式. 首先给一个控件实现长按监听 在长按回调中调用Activity.startActivityMode(..)并创建一个ActionMode.Callback的接口作为参数传入. 这个接口里面的回调很熟悉就是上面ListView设置了setMultiChoiceModeListener里面创建的匿名类里面对应的回调. ","date":"2016-09-07","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%80/:10:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记一 零散知识整理","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%80/"},{"categories":null,"content":"设备屏幕尺寸的确定 你可能会发现你的项目目录中存在如下这个文件, 但具体什么意思却不是很清楚 这是在Android 3.2之后引入的新修饰符, 在3.2之前是使用small, normal, large, xlarge来讲设备分为不同的屏幕大小类别. 现在新引入的屏幕尺寸修饰符如下表: 修饰符格式 描述 wXXXdp 有效宽度: 宽度大于或等于 XXX dp hXXXdp 有效高度: 高度大于或等于 XXX dp swXXXdp 最小宽度: 宽度或者高度(两者中最小的那个) 大于或等于 xxx dp 如果要指定某一个布局仅适用于屏幕宽度至少300dp的设备, 这种情况下, 可以使用宽度修饰符, 并将布局文件放入res/layout-w300dp目录下, (w代表宽度width). 同样道理如果是高度那么使用hxxxdp 有时候设备方向变换, 也会导致设备的宽高发生变化. 为了确定某个具体的屏幕尺寸可是使用sw, 如果不管是横屏1280*720还是竖屏的720*1280, 其对应的sw的值都是800. ","date":"2016-09-07","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%80/:11:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记一 零散知识整理","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%80/"},{"categories":null,"content":"以命令行的方式运行activity 要用adb命令启动首先需要满足activity组件可以被外部启动. 需要在清单文件中配置要被启动的activity的属性如下 \u003cactivity android:name=\".activity.CrimeCameraActivity\" android:exported=\"true\"/\u003e 设置exported属性. 这个属性默认是false. 表示只能从自己的应用中启动. 如果将intent过滤器添加到activity的声明中, 那么该activity的exported将被自动设置为true 然后使用adb命令, 如果你没有设置全局环境那么就到Android SDK安装目录platform-tools子目录下执行adb命令. adb shell am start -n 应用包名/.activity类名 / 后面接的和清单文件中activity的name属性对应的是一样的. 如果你如上代码在多层包中. 那么实际上是这样的. 我的包名com.szysky.note.criminal 演示代码: adb shell am start -n com.szysky.note.criminal/.activity.CrimeCameraActivity am(Activity Manager)是一个在设备上运行的命令行程序. 它支持启动和停止Android组件(component)并从命令行发送intent. 可以运行adb shell am指令. 查看am工具能够完成的所有任务. ","date":"2016-09-07","objectID":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%80/:12:0","tags":["android","笔记"],"title":"《Android编程权威指南》随记一 零散知识整理","uri":"/posts/android%E7%BC%96%E7%A8%8B%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E9%9A%8F%E8%AE%B0%E4%B8%80/"},{"categories":null,"content":" 第15章: 通过一些常见的性能优化方法, 这将有助于提高Android程序的性能, 于一些性能能分析等. 优化主要几个方面: 布局优化 绘制优化 内存泄漏优化 响应速度优化 ListView, Bitmap, 线程优化 ","date":"2016-08-27","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B015-android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:0:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 15-Android性能优化","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B015-android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"Android性能优化的方法 ","date":"2016-08-27","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B015-android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:1:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 15-Android性能优化","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B015-android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"布局优化 布局优化的思想就是尽量减少布局的嵌套层级,这就可以让Android绘制时的工作量减少 删除无用的控件和层级, 有选择地使用ViewGroup. 例如RelativeLayout和LinearLayout. 都可以的话那么就采用LinearLayout. 因为RelativeLayout的功能比较复杂, 它的布局过程需要花费更多的CPU时间. FrameLayout和LinearLayout都是一种简单高效的ViewGroup. 如果需要嵌套才可以实现的布局那么就使用RelativeLayout. 布局优化的另外一个方法就是采用\u003cinclude\u003e标签, \u003cmerge\u003e标签和ViewStub. \u003cinclude\u003e: 主要用于布局的重用 \u003cmerge\u003e: 一般和include标签配合使用, 它可以减少布局的层级 ViewStub: 提供了按需加载的功能, 当需要时才会将ViewStub中的布局加载到内存,这可以提高程序的初始化. \u003cinclude\u003e标签 可以将一个指定的布局文件加载到当前布局文件中: \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cLinearLayout xmlns:android=\"http://schemas.android.com/apk/res/android\" android:layout_width=\"match_parent\" android:layout_height=\"match_parent\" android:orientation=\"horizontal\"\u003e \u003cinclude android:id=\"@+id/hah\" android:layout=\"@layout/layout_titlebar\" android:layout_height=\"match_parent\" android:layout_width=\"match_parent\" android:visibility=\"invisible\"/\u003e \u003c/LinearLayout\u003e 这个标签里面支持的属性很少, 根据编辑器的提示只有5个, 而且width和height如果要出现需要同时出现, 也可以不写, 最重要的就是一个必须指定导入的布局layout=\"xxxxxx\". \u003cmerge\u003e标签 这个标签一般和include标签一起使用从而减少布局的层级. 有时候会有这样一个场景, 如果include导入的布局的根布局是竖直方向的, 而当前布局也是竖直方向的, 那么显然有一个层级是多余的. 这个时候使用\u003cmerge\u003e就可以去掉重复布局. ViewStub ViewStub继承了View, 这是一个非常轻量级的且宽高都是0, 因此它本身不参与任何的布局和绘制过程. 而ViewStub存在的意义在于按需加载所需的布局文件, 在实际开发中, 有很多布局文件在正常情况系不会显示, 如网络异常等. 这个时候就没有必要再整个界面初始化的时候将其加载. 首先布局中添加\u003cViewStub\u003e \u003cViewStub android:id=\"@+id/stub_import\" android:inflatedId=\"@+id/stin_root\" android:layout=\"@layout/layout_stubview\" android:layout_width=\"match_parent\" android:layout_height=\"60dp\"/\u003e 这里android:layout属性还是导入外部布局的意思. inflatedId这个添加的id的属性是给导入进来的布局layout_stubview的根布局设定了一个id值. 然后在代码中有两种方式让其显示 // 方式一 通过设置visibility ((ViewStub)findViewById(R.id.stub_import)).setVisibility(View.VISIBLE); // 方式二 通过inflate加载显示 //View inflate = ((ViewStub) findViewById(R.id.stub_import)).inflate(); // 通过inflatedId这个id可以得到加载进来的布局的根布局 LinearLayout commLv = (LinearLayout) findViewById(R.id.stin_root); ","date":"2016-08-27","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B015-android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:1:1","tags":["android","笔记"],"title":"《Android 开发艺术探索》 15-Android性能优化","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B015-android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"绘制优化 绘制优化是指View#onDraw()方法要避免执行大量的操作.两个方面 onDraw中不要创建新的局部对象, 因为onDraw()方法可能会被频繁调用, 这样就会在一瞬间产生大量的临时对象, 这不仅占用了过多的内存而且还会导致系统频繁的gc, 降低了程序的执行效率. 不要做耗时任务, 也不能执行成千上万次的循环操作. 即使每次循环都很轻量级, 但是大量的循环仍然十分抢占CPU的时间片, 这会造成View的绘制流程不流畅. 按照官方的规范, View的绘制帧率保证60fps最佳. 也就是16ms的为每一阵帧的绘制时间. ","date":"2016-08-27","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B015-android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:1:2","tags":["android","笔记"],"title":"《Android 开发艺术探索》 15-Android性能优化","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B015-android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"内存泄漏优化 情况1. 静态变量导致的内存泄漏 private static View sView; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); sView = new View(this); } 如非必须传递Activity的引用不要这么做, 如果需要上下文可以传递getApplicationContext()返回的上下文 情况2. 单例模式导致的内存泄漏 常见的就是在使用注册监听的时候, 往往会往一个单例类中传入this本类对象,进行注册, 然后却没有解注册的动作. 那么这个Activity被引用的时间也就是和Application的生命周期持平. 情况3. 属性动画导致的内存泄漏 在Android 3.0中加入了属性动画, 属性动画有一类无限循环的动画, 如果在Activity中播放此类动画且没有在Activity退出的时候没有停止动画. 尽管无法界面上看到效果, 但是创建这个动画所关联的View被动画所持有, 而View又持有了Activity, 最终Activity无法释放. 解决方案, 就是在onDestroy()中调用动画的cancel()来停止动画. ","date":"2016-08-27","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B015-android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:1:3","tags":["android","笔记"],"title":"《Android 开发艺术探索》 15-Android性能优化","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B015-android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"响应速度和ANR日志分析 响应速度的优化核心就是避免主线程做耗时操作, 响应速度过慢更多体现在Activity启动的速度上. 如果主线程内做太多的事情, 会导致Activity启动时出现黑屏现象, 甚至出现ANR. Android中规定如果Activity5秒钟之内无法响应屏幕事件或者键盘输入事件就会出现ANR. 而BroadCastReceiver如果10秒之内还未执行完操作也会出现ANR. 如果进程发生了ANR以后, 系统会在data/anr目录下创建一个文件traces.txt. 通过分析这个文件就定位出原因.(这个文件很长如果需要分析, 请先删除文件生成一个在分析来进行了解) 通过一个例子来了解如何去分析文件, 首先在onCreate()添加如下代码, 让主线程等待一个锁,然后点击返回5秒后会出现ANR, 贴代码 @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 以下代码是为了模拟一个ANR的场景来分析日志 new Thread(new Runnable() { @Override public void run() { testANR(); } }).start(); SystemClock.sleep(10); initView(); } /** * 以下两个方法用来模拟出一个稍微不好发现的ANR */ private synchronized void testANR(){ SystemClock.sleep(3000 * 1000); } private synchronized void initView(){} 这样会出现ANR, 然后导出/data/anr/straces.txt文件. 因为内容比较多只贴出关键部分 DALVIK THREADS (15): \"main\" prio=5 tid=1 Blocked | group=\"main\" sCount=1 dsCount=0 obj=0x73db0970 self=0xf4306800 | sysTid=19949 nice=0 cgrp=apps sched=0/0 handle=0xf778d160 | state=S schedstat=( 151056979 25055334 199 ) utm=5 stm=9 core=1 HZ=100 | stack=0xff5b2000-0xff5b4000 stackSize=8MB | held mutexes= at com.szysky.note.androiddevseek_15.MainActivity.initView(MainActivity.java:0) - waiting to lock \u003c0x2fbcb3de\u003e (a com.szysky.note.androiddevseek_15.MainActivity) - held by thread 15 at com.szysky.note.androiddevseek_15.MainActivity.onCreate(MainActivity.java:42) 这段可以看出最后指明了ANR发生的位置在ManiActivity的42行. 并且通过上面看出initView方法正在等待一个锁\u003c0x2fbcb3de\u003e锁的类型是一个MainActivity对象. 并且这个锁已经被线程id为15(tid=15)的线程持有了. 接下来找一下线程15 \"Thread-404\" prio=5 tid=15 Sleeping | group=\"main\" sCount=1 dsCount=0 obj=0x12c00f80 self=0xeb95bc00 | sysTid=19985 nice=0 cgrp=apps sched=0/0 handle=0xef34be80 | state=S schedstat=( 391248 0 1 ) utm=0 stm=0 core=2 HZ=100 | stack=0xe2bfe000-0xe2c00000 stackSize=1036KB | held mutexes= at java.lang.Thread.sleep!(Native method) - sleeping on \u003c0x2e3896a7\u003e (a java.lang.Object) at java.lang.Thread.sleep(Thread.java:1031) - locked \u003c0x2e3896a7\u003e (a java.lang.Object) at java.lang.Thread.sleep(Thread.java:985) at android.os.SystemClock.sleep(SystemClock.java:120) at com.szysky.note.androiddevseek_15.MainActivity.testANR(MainActivity.java:50) - locked \u003c0x2fbcb3de\u003e (a com.szysky.note.androiddevseek_15.MainActivity) tid = 15 就是相关信息如上, 首行已经标出线程的状态为Sleeping, 原因在50行, 就是 SystemClock.sleep(3000 * 1000);这句话. 也就是testANR(). 而最后一行也表明了持有的locked\u003c0x2fbcb3de\u003e就是主线程在等待的那个锁对象. ","date":"2016-08-27","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B015-android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:1:4","tags":["android","笔记"],"title":"《Android 开发艺术探索》 15-Android性能优化","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B015-android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"ListView和Bitmap优化 ListView: 在前面已经说过了, 主要三个方面: 采用ViewHolder避免在getView中执行耗时操作; 其次要根据列表的滑动状态来控制任务的执行频率; 最后可以尝试开启硬件加速是ListView滑动更加流畅. ListView的优化策略也完全适用于GridView Bitmap: 也已经说过, 主要是通过BitmapFactory.Options根据需要对图片进行采样, 采样率的设置通过inSampleSize属性. ","date":"2016-08-27","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B015-android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:1:5","tags":["android","笔记"],"title":"《Android 开发艺术探索》 15-Android性能优化","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B015-android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"线程优化 主要思想就是采用线程池, 避免程序中存在大量的Thread. 线程池可以重用内部的线程, 避免了线程创建和销毁的性能开销. 同时线程池还能有效的控制线程的最大并发数, 避免了大量线程因互相抢占系统资源从而导致阻塞现象的发生. ","date":"2016-08-27","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B015-android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:1:6","tags":["android","笔记"],"title":"《Android 开发艺术探索》 15-Android性能优化","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B015-android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"额外的性能优化建议 避免创建过多的对象 不要过多使用枚举, 枚举占用的内存空间比整形还要大,使用Android官方提供的方法可参考另一篇博客链接跳转 常量请使用 static final 来修饰 使用一些Android特有的数据结构, 比如SparseArray和Pair等 适当的使用软引用和弱引用 采用内存缓存和磁盘缓存 尽量采用静态内部类, 避免潜在的由于内部类而导致的内存泄漏 ","date":"2016-08-27","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B015-android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:1:7","tags":["android","笔记"],"title":"《Android 开发艺术探索》 15-Android性能优化","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B015-android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"内存泄漏分析工具MAT MAT全程Eclipse Memory Analyzer, 是一个内存泄漏分析工具. 下载后解压即可. 下载地址http://www.eclipse.org/mat/downloads.php. 这里仅简单说一下. 这个我没有手动去实践, 就当个记录, 因为现在Android Studio可以直接分析hprof文件. 可以手动写一个会造成内存泄漏的代码, 然后打开DDMS, 然后选中要分析的进程, 然后单击Dump HPROF file这个按钮. 等一小段会生成一个文件. 这个文件不能被MAT直接识别. 需要使用Android SDK中的工具进行格式转换一下.这个工具在platform-conv文件夹下 hprof-conv 要转换的文件名 输出的文件名 文件名的签名有包名. 然后打开MAT通过菜单打开转换后的这个文件. 这里常用的就有两个 Histogram: 可以直观的看出内存中不同类型的buffer的数量和占用内存大小 Dominator Tree: 把内存中的对象按照从大到小的顺序进行排序, 并且可以分析对象之间的引用关系, 内存泄漏分析就是通过这个完成的. 分析内存泄漏的时候需要分析Dominator Tree里面的内存信息, 一般会不直接显示出来, 可以按照从大到小的顺序去排查一遍. 如果发生了了泄漏, 那么在泄漏对象处右键单击Path To GC Roots-\u003eexclude wake/soft references. 可以看到最终是什么对象导致的无法释放. 刚才的操作之所以排除软引用和弱引用是因为,大部分情况下这两种类型都可以被gc回收掉,所以基本也就不会造成内存泄漏. 同样这里也可以使用搜索功能, 假如我们手动模拟了内存泄漏, 泄漏的对象就是Activity那么我们back退出重进循环几次, 会发现其实很多个Activit对象. 更多的东西我也不会,作者也没有说.. 不过这些以后Android Studio都会很有好用对应功能. ","date":"2016-08-27","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B015-android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:1:8","tags":["android","笔记"],"title":"《Android 开发艺术探索》 15-Android性能优化","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B015-android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":null,"content":"提高程序的可维护性 这里主要说Android的程序设计思想. 主旨是如何提高代码的可维护性和可扩展性, 而程序的可维护性也包含可扩展性. 这里的切入点为: 代码风格, 代码的层次性和单一职责原则, 面向扩展编程以及设计模式 可读性是代码可维护性的前提, 一段只能让机器读懂的代码即使可以跑也属于\"坏味道的代码\", 而良好的代码风格在一定程度上可以提高从程序的可读性. 代码的风格有 命名规范, 代码排版, 注释说明. 命名要规范, 正确传达出变量或者方法的定义, 少用缩写除非业界通用的缩写如String-\u003estr.能让人一眼明白的. 私有成员要以m开头. 静态成员要以s开头. 常量要全部大写. 代码排版上留出合理的空白来区分不同的代码块, 其中同类变量的声明放在一组, 两类变量之间留出一行作为空白. 仅为非常关键的代码添加注释, 其他地方不写注释, 这就对变量和方法的命名风格提出了很高的要求. 一个合理的命名风格可以让读者阅读源码的时候就如阅读注释一样. 因此根本不需要为代码额外写注释 代码的层次是指代码要有分层的概念, 对于一段业务逻辑, 不要试图在一个方法或者一个类中去全部实现, 而是将其分成几个子逻辑, 然后每个逻辑做自己的事情, 这样即显得代码层次分明, 又可以分解任务从而实现简单逻辑的效果. 单一职责是和层次性相关联的. 代码分层以后, 每一层仅仅关注少量的逻辑, 这样就做到了单一职责. 程序的扩展性, 由于很多时候在开发过程中无法保证已经做好的需求不在后面的版本发生更改, 因此在写程序的时候要时刻考虑到扩展的问题, 考虑如果这个逻辑以后发生了改变那么哪些需要修改, 以及怎样在以后修改的时候降低工作量, 而面向扩展编程可以让程序具有很好的扩展性. 适当使用设计模式可以提高代码的可维护性和可扩展性. 但是一定控制设计的度, 千万别过度设计. 这本书终于抄完了, 看了两遍. 全部理解透彻是没达到. 不过这本书挺不错的. 以后针对一些不是很理解,并且在Android中是一些贯穿始终的东西必须要认真琢磨. good night. 感谢任玉刚. ","date":"2016-08-27","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B015-android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/:2:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 15-Android性能优化","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B015-android%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/"},{"categories":null,"content":" 第14章: 弥补Java的跨平台特性导致的于本地交互能力不足而出现的. Java JNI本意为Java Native Interface(java本地接口), 是为方便java调用C或者C++等本地代码所封装的一层接口. 由于Java的跨平台性导致本地交互能力的不好, 一些和操作系统相关的特性Java无法完成, 于是Java提供了JNI专门用于和本地代码交互. NDK是android所提供的一个工具合集, 通过NDK可以在Android中更加方便地通过JNI来访问本地代码. NDK还提供了交叉编译工具, 开发人员只需要简单的修改mk文件就可以生成特定的CPU平台的动态库. 好处如下: 提供代码的安全性. so库反编译比较困难 可以很方便地使用目前已有的C/C++开源库 提高程序在某些特定情形下得执行效率, 但是不能明显提高Android程序的的性能. ","date":"2016-08-26","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-14-jni%E5%92%8Cndk%E7%BC%96%E7%A8%8B/:0:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 14-JNI和NDK编程","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-14-jni%E5%92%8Cndk%E7%BC%96%E7%A8%8B/"},{"categories":null,"content":"JNI的开发流程 大体步骤就是在java中声明native方法, 然后调用c/c++实现的native的方法. 下面开始具体步骤 1. 在Java中声明native方法 创建一个java类 package com.szysky.note.androiddevseek_14; public class JNITest { static { System.loadLibrary(\"jni-test\"); } public native String get(); public native void set(String str); // 主函数 public static void main(String arg[]) { JNITest jniTest = new JNITest(); System.out.println(jniTest.get()); jniTest.set(\"java写入数据\"); } } 首先是通过静态代码块先加载so库, 然后声明两个native方法提供使用. 这两个方法需要在JNI中实现. 加载so库名称填入的虽然是jni-test, 但是so库全名称应该是libjni-test.so,这是加载so库的规范. 2. 编辑Java源文件得到class文件, 然后通过javah命令导出JNI头文件 在包的的根路径, 进行命令操作 javac com/szysky/note/androiddevseek_14/JNITest.java javah com.szysky.note.androiddevseek_14.JNITest 执行之后会在, 操作的路径下生成一个com_szysky_note_androiddevseek_14_JNITest.h头文件, 这个就是第二步生成的东西. /* DO NOT EDIT THIS FILE - it is machine generated */ #include \u003cjni.h\u003e /* Header for class com_szysky_note_androiddevseek_14_JNITest */ #ifndef _Included_com_szysky_note_androiddevseek_14_JNITest #define _Included_com_szysky_note_androiddevseek_14_JNITest #ifdef __cplusplus extern \"C\" { #endif /* * Class: com_szysky_note_androiddevseek_14_JNITest * Method: get * Signature: ()Ljava/lang/String; */ JNIEXPORT jstring JNICALL Java_com_szysky_note_androiddevseek_114_JNITest_get (JNIEnv *, jobject); /* * Class: com_szysky_note_androiddevseek_14_JNITest * Method: set * Signature: (Ljava/lang/String;)V */ JNIEXPORT void JNICALL Java_com_szysky_note_androiddevseek_114_JNITest_set (JNIEnv *, jobject, jstring); #ifdef __cplusplus } #endif #endif 对生成的.h文件进行一下说明: 函数名:格式遵循:Java_包名_类名_方法名包名之间的.分割全部替换成_分割. 参数: jstring是代表String类型参数. 具体的类型关系后面会说明. JNIEnv *: 表示一个指向JNI环境的指针, 可以通过它来访问JNI提供的方法. jobject: 表示java对象中的this. JNIEXPORT和JNICALL: 这是JNI种所定义的宏, 可以在jni.h这个头文件查到 #ifdef __cplusplus extern \"C\" { #endif 而这个宏定义是必须的, 作用是指定extern\"C\"内部的函数采用C语言的命名风格来编译. 如果设定那么当JNI采用C++来实现时, 由于C/C++编译过程对函数的命名风格不同, 这将导致JNI在链接时无法根据函数名找到具体的函数, 那么JNI调用肯定会失效. 3. 实现JNI方法 JNI方法是指的Java中声明的native方法, 这里可以选择c++和c来实现. 过程都是类似的. 只有少量的区别, 这里两种都实现一下. 首先是C++ 在工程的主目录创建一个子目录, 名称任意, 然后将之前通过javah命令生成的**.h头文件**复制到创建的目录下, 接着创建test.cpp实现如下: // Created by 苏泽钰 on 16/8/27. // test.app #include \"com_szysky_note_androiddevseek_14_JNITest.h\" #include \u003cstdio.h\u003e JNIEXPORT jstring JNICALL Java_com_szysky_note_androiddevseek_114_JNITest_get(JNIEnv *env, jobject thiz){ printf(\"执行在c++文件中 get方法\\n\"); return env-\u003eNewStringUTF(\"Hello from JNI .\"); } JNIEXPORT void JNICALL Java_com_szysky_note_androiddevseek_114_JNITest_get(JNIEnv *env, jobject thiz, jstring string){ printf(\"执行在c++文件中 set方法\\n\"); char* str = (char*) env-\u003eGetStringUTFChars(string, NULL); printf(\"\\n, str\"); env-\u003eReleaseStringUTFChars(string, str); } 在看一下C的实现: // Created by 苏泽钰 on 16/8/27. // test.c #include \"com_szysky_note_androiddevseek_14_JNITest.h\" #include \u003cstdio.h\u003e JNIEXPORT jstring JNICALL Java_com_szysky_note_androiddevseek_114_JNITest_get(JNIEnv *env, jobject thiz){ printf(\"执行在c文件中 get方法\\n\"); return (*env)-\u003eNewStringUTF(\"Hello from JNI .\"); JNIEXPORT void JNICALL Java_com_szysky_note_androiddevseek_114_JNITest_get(JNIEnv *env, jobject thiz, jstring string){ printf(\"执行在c文件中 set方法\\n\"); char* str = (char*) (*env)-\u003eGetStringUTFChars(env, string, NULL); printf(\"%s\\n, str\"); (*env)-\u003eReleaseStringUTFChars(env, string, str); }} 其实C\\C++在实现上很相似, 但是对于env的操作方式有所不同. 4. 编写so库并在java中调用 so库的编译这里采用gcc(Linux, mac环境下, window不清楚). 命令cd到放置刚才生成c/c++的目录下. 使用如下命令: gcc -shared -I /Library/Java/JavaVirtualMachines/jdk1.8.0_91.jdk/include -fPIC test.cpp -o libjni-test.so Linux /Library/Java/JavaVirtualMachines/jdk1.8.0_91.jdk这个就是java的环境目录. 书上这条操作是在Linux,如果你是mac系统, 请这样修改一下,要不无法编译 Mac 首先找到你的Java环境的目录然后在后面追加Content/Home/来替换上面的路径. 这么做的意义可以上mac电脑下看一下/Library/Java/JavaVirtualMachines/jdk1.8.0_91.jdk/Contents/Home/include发现文件夹下有有一个jni.h的文件, 这个文件在我们生成的头文件中有过导入, 这下明白了为什么修改了吧, 别急还有一步, 在jni.h中还会导入一个jni_md.h这个文件默认在jni.h的同级目录有一个darwin文件夹下把这个文件也拷贝出来放在和jni.h同级, 然后执行下面命令: gcc -shared -I /Library/Java/JavaVirtualMachines/jdk1.8.0_91.jdk/Contents/Home/include -fPIC test.cpp -o libjni-test.jnilib (别忘了替换路径) 如果是mac系统, 那么生成.jnilib而不是","date":"2016-08-26","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-14-jni%E5%92%8Cndk%E7%BC%96%E7%A8%8B/:1:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 14-JNI和NDK编程","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-14-jni%E5%92%8Cndk%E7%BC%96%E7%A8%8B/"},{"categories":null,"content":"NDK的开发流程 NDK的开发是基于JNI的, 主要有如下步骤 1. 下载并进行配置NDK 首先要下载NDK. NDK下载地址 下载后解压. 或者你可以直接在Android SDK Manager下载. 如果在sdk manager下载那么就在上面图中上部的Android SDK Location指定根目录下的ndk-bundle文件夹. 接下来就配置一下全局环境, 这里是mac系统下的操作(Linux修改~/.bashrc文件), 命令行直接输出: open ~/.bash_profile 添加一下配置 # 设置ndk环境路径 export PATH=${PATH}:/Users/suzeyu/Library/Android/sdk/ndk-bundle 可以使用ndk-build检测是否成功了, 之后就可以使用ndk-build命令产生编译so的库. 这里使用的NDK版本是android-ndk-r12d 2. 创建一个android项目, 在类中声明所需的native方法 这一步和上面创建java普通类的方法一样. public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); } static{ System.loadLibrary(\"jni-test\"); } public native String get(); public native void set(String str); } 3. 实现Android项目中所声明的native方法 jniLibs是AndroidStudio默认目录，用来存放已经编译好的.so文件，当然你也可以放在任意自定义目录下，例如src/main/libs，然后在build.gradle中指定相应的资源目录位置即可： android { sourceSets.main { // 你的.so库的实际路径 jniLibs.srcDir 'src/main/libs' } } 上面是已经有了so文件的方式. 下面说说如果只有**c/c++**源码 这里有两种实现一种是手动使用ndk-build的命令, 一种利用gradle 利用gradle来生成 这里书上的方法已经不适用, 上网查询了一下是因为gradle文件首行使用的插件apply plugin: 'com.android.application'导致 使用传统的ndk-build来实现吧 在jni下创建3个文件, test.cpp, Android.mk, Application.mk三个文件 // 这是test.cpp文件 #include \u003cjni.h\u003e #include \u003cstdio.h\u003e #ifdef __cplusplus extern \"C\" { #endif jstring Java_com_szysky_note_androiddevseek_114_MainActivity_get(JNIEnv *env, jobject thiz){ printf(\"执行在c++文件中 get方法\\n\"); return env-\u003eNewStringUTF(\"Hello from JNI .\"); } void Java_com_szysky_note_androiddevseek_114_MainActivity_set(JNIEnv *env, jobject thiz, jstring string){ printf(\"执行在c++文件中 set方法\\n\"); char* str = (char*) env-\u003eGetStringUTFChars(string, NULL); printf(\"%s\\n\", str); env-\u003eReleaseStringUTFChars(string, str); } #ifdef __cplusplus } #endif // Android.mk文件 LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) LOCAL_MODULE := jni-test //生成so的文件名称 LOCAL_SRC_FILES := test.cpp //所关联的cpp文件 include $(BUILD_SHARED_LIBRARY) // Application.mk文件 APP_ABI := armeabi 这里说明一个mk文件: LOCAL_MODULE: 表示模块的名称 LOCAL_SRC_FILES: 表示需要参与的源文件 APP_ABI: 表示CPU的架构平台类型. 如armeabi, x86, mips等. 而test.cpp这个文件 要注意这里的函数名换成再调用处的所在类, 按照生成的JNI的函数的命名规则. 4. 切换到jni目录的父目录下, 通过ndk-build命令编译产生so库 命令行截图: 这些做完了, 使用命令生成. 如下图: 在产生的libs目录下把生成的so文件放在Android Studio的默认so路径下 Main/jniLibs文件夹下. 我在测试的时候, 必须要把jni文件夹内容删掉,否则会报错, 按照错误提示应该也可以通过gradle来在运行时候忽略此文件 为了保留生成必须代码而不影响运行, 原jni内容被移动到backup文件夹中. ","date":"2016-08-26","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-14-jni%E5%92%8Cndk%E7%BC%96%E7%A8%8B/:2:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 14-JNI和NDK编程","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-14-jni%E5%92%8Cndk%E7%BC%96%E7%A8%8B/"},{"categories":null,"content":"JNI的数据类型和类型签名 JNI的数据类型包含两种: 基本类型和引用类型. 基本类型主要有jboolean, jchar, jint等, 和Java中的数据类型对应如下: JNI类型 Java类型 描述 jboolean boolean 无符号8位整型 jbyte byte 无符号8位整型 jchar char 无符号16位整型 jshort short 有符号16位整型 jint int 32位整型 jlong long 64位整型 jfloat float 32位浮点型 jdouble double 64位浮点型 void void 无类型 JNI中的引用类型主要有类, 对象和数组. 他们和Java中的引用类型的对应关系如下: JNI类型 Java类型 描述 jobject Object Object类型 jclass Class Class类型 jstring String String类型 jobjeckArray Object[] 对象数组 jbooleanArray boolean[] boolean数组 jbyteArray byte[] byte数组 jcharArray char[] char数组 jshortArray short[] short数组 jintArray int[] int数组 jlongArray long[] long数组 jfloatArray float[] float数组 jdoubleArray double[] double数组 jthrowable Throwable Throwable JNI的类型签名标识了一个特定的Java类型, 这个类型既可以是类也可以是方法, 也可以是数据类型. 类的签名比较简单, 它采用L+包名+类型+;的形式, 只需要将其中的.替换为/即可. 例如java.lang.String, 它的签名为Ljava/lang/String;, 末尾的;也是一部分. 基本数据类型的签名采用一系列大写字母来表示, 如下: Java类型 签名 Java类型 签名 Java类型 签名 boolean Z byte B char C short S int I long J float F double D void V 基本数据类型的签名基本都是单词的首字母, 但是boolean除外因为B已经被byte占用, 而long的表示也被Java类签名占用. 所以不同. 而对象和数组, 对象的签名就是对象所属的类签名, 数组的签名[+类型签名例如byte数组. 首先类型为byte,所以签名为B然后因为是数组那么最终形成的签名就是[B.例如如下各种对应: char[] [C float[] [F double[] [D long[] [J String[] [Ljava/lang/String; Object[] [Ljava/lang/Object; 如果是多维数组那么就根据数组的维度多少来决定[的多少, 例如int[][]那么就是[[I 方法的签名为**(参数类型签名)+返回值类型签名**. 举个例子有这个一个方法boolean fun(int a, double b, int[] c). 参数类型的签名是连在一起, 那么按照方法的签名规则就是(ID[I)Z 例如方法:void fun(int a, String s, int[] c), 那么签名就是(ILjava/lang/String;[I)V 例如方法:int fun(), 对应签名()I 例如方法:int fun(float f), 对应签名(F)I ","date":"2016-08-26","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-14-jni%E5%92%8Cndk%E7%BC%96%E7%A8%8B/:3:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 14-JNI和NDK编程","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-14-jni%E5%92%8Cndk%E7%BC%96%E7%A8%8B/"},{"categories":null,"content":"JNI调用Java方法的流程 JNI调用java方法的流程是先通过类名找到类, 然后在根据方法名找到方法的id, 最后就可以调用这个方法了. 如果是调用Java的非静态方法, 那么需要构造出类的对象后才可以调用它 演示一下调用静态的方法: 首先在java中声明要被调用的静态方法. 这里触发的时机是一个按钮的点击,自行添加 static{ System.loadLibrary(\"jni-test\"); } /** * 定义一个静态方法 , 提供给JNI调用 */ public static void methodCalledByJni(String fromJni){ Log.e(\"susu\", \"我是从JNI被调用的消息, JNI返回的值是:\"+fromJni ); } // 定义调用本地方法, 好让本地方法回调java中的方法 public native void callJNIConvertJavaMethod(); @Override public void onClick(View view) { switch (view.getId()){ case R.id.btn_jni2java: // 调用JNI的方法 callJNIConvertJavaMethod(); break; } } 在JNI的test.cpp中添加一个c的函数用来处理调用java的逻辑, 并提供一个方法供java代码调起来触发. 一个两个方法. // 定义调用java中的方法的函数 void callJavaMethod( JNIEnv *env, jobject thiz){ // 先找到要调用的类 jclass clazz = env -\u003e FindClass(\"com/szysky/note/androiddevseek_14/MainActivity\"); if (clazz == NULL){ printf(\"找不到要调用方法的所属类\"); return; } // 获取java方法id // 参数二是调用的方法名, 参数三是方法的签名 jmethodID id = env -\u003e GetStaticMethodID(clazz, \"methodCalledByJni\", \"(Ljava/lang/String;)V\"); if (id == NULL){ printf(\"找不到要调用方法\"); return; } jstring msg = env-\u003eNewStringUTF(\"我是在c中生成的字符串\"); // 开始调用java中的静态方法 env -\u003e CallStaticVoidMethod(clazz, id, msg); } void Java_com_szysky_note_androiddevseek_114_MainActivity_callJNIConvertJavaMethod(JNIEnv *env, jobject thiz){ printf(\"调用c代码成功, 马上回调java中的代码\"); callJavaMethod(env, thiz); } 稍微说明一下, 程序首先根据类名com/szysky/note/androiddevseek_14/MainActivity找到类, 然后在根据方法名methodCalledByJni找到方法, 并传入方法对应签名(Ljava/lang/String;)V, 最后通过JNIEnv对象的CallStaticVoidMethod()方法来完成最终调用. 最后只要在Java_com_szysky_note_androiddevseek_114_MainActivity_callJNIConvertJavaMethod方法中调用callJavaMethod方法即可. 流程就是–\u003e 按钮触发了点击的onClikc –\u003e 然后Java中会调用JNI的callJNIConvertJavaMethod() –\u003e JNI的callJNIConvertJavaMethod()方法内部会调用具体实现回调Java中的方法callJavaMethod() –\u003e 方法最终通过CallStaticVoidMethod()调用了Java中的methodCalledByJni()来接收一个参数并打印一个log. 结果图: 生成so库的文件保存在git中的app/src/main/backup目录下一个两个版本代码, 第一个就是第二小节中的NDK开发代码, 第二个就是第四小节的代码就是目前的. 而so库是最新的, 包含了所有的JNI代码生成的库文件. JNI调用Java的过程和Java中方法的定义有很大关联, 针对不同类型的java方法, JNIEnv提供了不同的接口去调用, 更为细节的部分要去开发中或者去网站去了解更多. 第15章 Android的性能优化 ","date":"2016-08-26","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-14-jni%E5%92%8Cndk%E7%BC%96%E7%A8%8B/:4:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 14-JNI和NDK编程","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-14-jni%E5%92%8Cndk%E7%BC%96%E7%A8%8B/"},{"categories":null,"content":" crash的异常处理, Android中的方法限制, 反编译等也是需要了解的技术. blog相关代码 ","date":"2016-08-25","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-13-%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF/:0:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 13-综合技术","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-13-%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF/"},{"categories":null,"content":"捕捉Crash信息 应用总会不可避免的发生Crash, 有可能是因为底层bug, 或者是适配问题, 代码逻辑问题等等. 当发生Crash的时候, 系统会kill掉正在执行的程序, 现象就是闪退或者提示用户程序已经停止运行, 这对用户来说是很不友好, 也是开发者不愿意看到的. 系统提供了在程序Crash之前可以保存异常信息的能力, 这样在崩溃前可以保存异常信息到文件中, 传回服务器,这样可以针对各种各样的用户发生的错误对应用进行完善的方法, 这个类在Thread中的setDefaultUncaughtException()方法. /** * Sets the default uncaught exception handler. This handler is invoked in * case any Thread dies due to an unhandled exception. * * @param handler The handler to set or null. */ public static void setDefaultUncaughtExceptionHandler(UncaughtExceptionHandler handler) { Thread.defaultUncaughtHandler = handler; } 从方法名的意思看出设置默认未捕获异常的处理器. 就是当Crash发生的时候, 系统会回调UncaughtExceptionHandler#uncaughtException()方法, 在这个方法中可以获取到异常的信息, 可以选择把信息写到SD卡中, 然后在合适的时机通过网络将Crash信息上传到服务器上. 也可以在这里弹出一个对话框告诉用户, 会比直接闪退好那么一点. 首先要实现出一个UncaughtExceptionHandler的子类. 直接看实现: public class MyCrashHandler implements Thread.UncaughtExceptionHandler { private static final String TAG = MyCrashHandler.class.getSimpleName(); /** * 定义异常文件要存储的路径 */ private static final String PATH = Environment.getExternalStorageDirectory().getPath() + \"/szyCrash/log/\"; private static final String FILE_NAME = \"crash-\"; private static final String FILE_NAME_SUFFIX = \".trace\"; private Thread.UncaughtExceptionHandler mDefaultUncaughtExceptionHandler; private Context mContext; /** * 单例模式三部曲 懒汉式 */ private static MyCrashHandler sInstance = new MyCrashHandler(); private MyCrashHandler() { } public static MyCrashHandler getsInstance() { return sInstance; } /** * 设置本类为当前进行的默认未捕捉异常处理器 */ public void init(Context context) { mContext = context.getApplicationContext(); mDefaultUncaughtExceptionHandler = Thread.getDefaultUncaughtExceptionHandler(); Thread.setDefaultUncaughtExceptionHandler(this); } @Override public void uncaughtException(Thread thread, Throwable ex) { try { // 导出信息到sd卡上 dumpExceptionToSDCard(ex); // 对本地的信息进行上传服务器处理 uploadExceptionToServer(); } catch (IOException e) { e.printStackTrace(); } finally { // 也把异常打印到控制台 防止系统没有默认异常处理器导致的没有崩溃信息 ex.printStackTrace(); // 如果系统有默认的异常处理器那么就给系统处理 否则自己关闭掉 // 如果不交给系统 或者 自己手动杀掉, 那么应用就会进入假死, 点击会出现ANR if (mDefaultUncaughtExceptionHandler != null) { ex.printStackTrace(); mDefaultUncaughtExceptionHandler.uncaughtException(thread, ex); } else { Process.killProcess(Process.myPid()); } } } /** * 上传发生未捕获的错误日志 */ private void uploadExceptionToServer() { // TODO: 16/8/25 看具体需求, 也可以在每次启动app后检测本地是否有异常日志 } /** * 开始异常信息进行本地存储处理 * * @param ex 程序发生的异常对象 * @throws IOException 写入文件发生异常 */ private void dumpExceptionToSDCard(Throwable ex) throws IOException { // 首先判断sd卡是否被挂起 if (!Environment.getExternalStorageState().equals(Environment.MEDIA_MOUNTED)) { Log.w(TAG, \"sd卡不可用, 跳过 dump Exception\"); return; } File dir = new File(PATH); if (!dir.exists()) { dir.mkdirs(); } // 获取日志记录时间 long currentTimeMillis = System.currentTimeMillis(); String formatTimeStr = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss\").format(new Date(currentTimeMillis)); // 创建存储异常的文件 File file = new File(PATH + FILE_NAME + formatTimeStr + FILE_NAME_SUFFIX); try { // 创建写入流, 开始哗哗写东西 PrintWriter pw = new PrintWriter(new BufferedWriter(new FileWriter(file))); pw.println(formatTimeStr); dumpPhoneInfo(pw); pw.println(); pw.println(\"**********************异常信息**************************\"); ex.printStackTrace(pw); pw.close(); } catch (PackageManager.NameNotFoundException e) { Log.e(TAG, \"存储未捕获异常失败了.\"); } } /** * 读取当前设备信息 并追加到异常日志中 */ private void dumpPhoneInfo(PrintWriter pw) throws PackageManager.NameNotFoundException { // 获得应用包管理者 并获取存储当前应用的信息对象 PackageManager pm = mContext.getPackageManager(); PackageInfo pi = pm.getPackageInfo(mContext.getPackageName(), PackageManager.GET_ACTIVITIES); pw.println(\"**********************设备信息**************************\"); // 开始写入 应用信息 pw.println(\"App Version \"); pw.print(\" VersionName: \"); pw.println(pi.versionName); pw.print(\" VersionCode: \"); pw.println(pi.versionCode); // 开始写入 Android版本信息 pw.println(\"OS Version \"); pw.println(\" SDK_NAME: \" + Build.VERSION.RELEASE); pw.println(\" SDK_INT: \" + Build.VERSION.SDK_INT); // 开始写入 手","date":"2016-08-25","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-13-%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF/:1:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 13-综合技术","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-13-%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF/"},{"categories":null,"content":"multidex解决方法数越界 Android中单个dex文件所能包含的最大方法数为65536, 这包含了FrameWork, 依赖的jar包以及应用本身的代码中的所有方法. 会爆出: com.android.dex.DexIndexOverflowException: method ID not in[0, 0xffff] :65536 可能在一些低版本的手机, 即使没有超过方法数的上限却还是出现错误 E/dalvikvm: Optimization failed E/installd: dexopt failed on '/data/dalvik-cache/.....' 这个现象, 首先dexpot是一个程序, 应用在安装时, 系统会通过dexopt来优化dex文件, 在优化过程中dexopt采用一个固定大小的缓冲区来存储应用中所有方法消息, 这个缓冲区就是linearAlloc. LinearAlloc缓冲区在新版本的Android系统中大小为8MB或者16MB. 在Android 2.2和2.3中却只有5MB. 这是如果方法过多, 即使方法数没有超过65535也有可能会因为存储空间失败而无法安装. 解决方案 插件化: 是一套重量级的技术方案, 通过将一个dex拆分成两个或者多个dex,可以在一定程度上解决方法数的越界问题. 但是还有兼容性问题需要考虑, 所以需要权衡是否需要使用这个方案. multidex: 这是Google在2014年提出的解决方案 = =. 略过 ","date":"2016-08-25","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-13-%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF/:2:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 13-综合技术","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-13-%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF/"},{"categories":null,"content":"Android的动态加载技术 动态加载也叫插件化. 当项目越来越大的时候, 可以通过插件化来减轻应用的内存和CPU占用. 还可以实现热插播, 即可以在不发布新版本的情况下更新某些模块. 插件化基本都要面临解决的基本问题: 资源访问 Activity声明周期的管理 ClassLoader的管理 说明宿主和插件的概念, 宿主是指普通的apk, 而插件一般指经过处理的dex或者apk. 在主流的插件化框架中多采用经过处理的apk来作为插件, 处理方式往往和编译以及打包环节有关, 另外很多插件化框架都需要用到代理Activity的概念, 插件Activity的启动大多数是借助一个代理Activity来实现. = =. 略过 ","date":"2016-08-25","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-13-%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF/:3:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 13-综合技术","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-13-%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF/"},{"categories":null,"content":"反编译 = =. 略过 第14章: JNI和NDK编程 ","date":"2016-08-25","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-13-%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF/:4:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 13-综合技术","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-13-%E7%BB%BC%E5%90%88%E6%8A%80%E6%9C%AF/"},{"categories":null,"content":" 由于Bitmap的特殊性以及Android对单个应用所施加的内存限制, 会导致加载Bitmap的时候很容易出现内存溢出. 还有常用的缓存策略. blog相关代码 ","date":"2016-08-23","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-12-bitmap%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8Ccache/:0:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 12-Bitmap的加载和Cache","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-12-bitmap%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8Ccache/"},{"categories":null,"content":"Bitmap的高效加载 先来简单介绍一下如何加载一个Bitmap, Bitmap在android中指的是一张图片, 可以是png格式也可以是jpg等其他常见的图片格式. **那么如何加载一个图片?**首先BitmapFactory类提供了四种方法: decodeFile(), decodeResource(), decodeStream(), decodeByteArray(). 分别用于从文件系统, 资源文件, 输入流以及字节数组加载出一个Bitmap对象. 其中decodeFile和decodeResource又间接调用了decodeStream()方法, 这四类方法最终是在Android的底层实现的, 对应着BitmapFactory类的几个native方法. **高效加载的Bitmap的核心思想:**采用BitmapFactory.Options来加载所需尺寸的图片. 比如说一个ImageView控件的大小为300*300. 而图片的大小为800*800. 这个时候如果直接加载那么就比较浪费资源, 需要更多的内存空间来加载图片, 这不是很必要的. 这里我们就可以先把图片按一定的采样率来缩小图片在进行加载. 不仅降低了内存占用,还在一定程度上避免了OOM异常. 也提高了加载bitmap时的性能. 而通过Options参数来缩放图片: 主要是用到了inSampleSize参数, 即采样率. 如果是inSampleSize=1那么和原图大小一样, 如果是inSampleSize=2那么宽高都为原图1/2, 而像素为原图的1/4, 占用的内存大小也为原图的1/4 如果是inSampleSize=3那么宽高都为原图1/3, 而像素为原图的1/9, 占用的内存大小也为原图的1/9 以此类推….. 要知道Android中加载图片具体在内存中的占有的大小是根据图片的像素决定的, 而与图片的实际占用空间大小没有关系.而且如果要加载mipmap下的图片, 还会根据不同的分辨率下的文件夹进行不同的放大缩小. 列举现在有一张图片像素为:1024*1024, 如果采用ARGB8888(四个颜色通道每个占有一个字节,相当于1点像素占用4个字节的空间)的格式来存储.(这里不考虑不同的资源文件下情况分析) 那么图片的占有大小就是1024*1024*4那现在这张图片在内存中占用4MB. 如果针对刚才的图片进行inSampleSize=2, 那么最后占用内存大小为512*512*4, 也就是1MB 采样率的数值必须是大于1的整数是才会有缩放效果, 并且采样率同时作用于宽/高, 这将导致缩放后的图片以这个采样率的2次方递减, 即内存占用缩放大小为1/(inSampleSize的二次方). 如果小于1那么相当于=1的时候. 在官方文档中指出, inSampleSize的取值应该总是为2的指数, 比如1,2,4,8,16,32…如果外界传递inSampleSize不为2的指数, 那么系统会向下取整并选择一个最接近的2的指数来代替. 比如如果inSampleSize=3,那么系统会选择2来代替. 但是这条规则并不作用于所有的android版本, 所以可以当成一个开发建议 整理一下开发中代码流程: 将BitmapFactory.Options的inJustDecodeBounds参数设置为true并加载图片. 从BitmapFactory.Options取出图片的原始宽高信息, 他们对应于outWidth和outHeight参数 根据采样率的规则并结合目标View的所需大小计算出采样率inSampleSize 将BitmapFactory.Options的inJustDecodeBounds参数设为false, 然后重新加载. 第一个步骤设置了一个参数, 这个参数的作用就是在加载图片的时候是否只是加载图片宽高信息而不把图片全部加载到内存. 所以这个操作是个轻量级的. 通过这些步骤就可以整理出以下的工具加载图片类调用decodeFixedSizeForResource()即可. public class MyBitmapLoadUtil { /** * 对一个Resources的资源文件进行指定长宽来加载进内存, 并把这个bitmap对象返回 * * @param res 资源文件对象 * @param resId 要操作的图片id * @param reqWidth 最终想要得到bitmap的宽度 * @param reqHeight 最终想要得到bitmap的高度 * @return 返回采样之后的bitmap对象 */ public static Bitmap decodeFixedSizeForResource(Resources res, int resId, int reqWidth, int reqHeight){ // 首先先指定加载的模式 为只是获取资源文件的大小 BitmapFactory.Options options = new BitmapFactory.Options(); options.inJustDecodeBounds = true; BitmapFactory.decodeResource(res, resId, options); //Calculate Size 计算要设置的采样率 并把值设置到option上 options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight); // 关闭只加载属性模式, 并重新加载的时候传入自定义的options对象 options.inJustDecodeBounds = false; return BitmapFactory.decodeResource(res, resId, options); } /** * 一个计算工具类的方法, 传入图片的属性对象和 想要实现的目标大小. 通过计算得到采样值 */ private static int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) { //Raw height and width of image //原始图片的宽高属性 final int height = options.outHeight; final int width = options.outWidth; int inSampleSize = 1; // 如果想要实现的宽高比原始图片的宽高小那么就可以计算出采样率, 否则不需要改变采样率 if (reqWidth \u003c height || reqHeight \u003c width){ int halfWidth = width/2; int halfHeight = height/2; // 判断原始长宽的一半是否比目标大小小, 如果小那么增大采样率2倍, 直到出现修改后原始值会比目标值大的时候 while((halfHeight/inSampleSize) \u003e= reqHeight \u0026\u0026 (halfWidth/inSampleSize) \u003e= reqWidth){ inSampleSize *= 2; } } return inSampleSize; } } 当给ImageView设置的时候传入控件的大小, 就会自动转换返回. 可以看一下下面的两张图, 当加载一个分辨率很大的图片如果不使用此方法那么就出程序崩溃 了解一下一个原始图片到手机显示的最终占用内存大小 ","date":"2016-08-23","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-12-bitmap%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8Ccache/:1:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 12-Bitmap的加载和Cache","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-12-bitmap%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8Ccache/"},{"categories":null,"content":"Android中的缓存策略 目前常用的一种缓存算法是LRU(Least Recently Used), 最近最少使用算法. 核心思想: 当缓存存满时, 会优先淘汰那些近期最少使用的缓存对象. 采用LRU算法的缓存有两种: LruCache和DiskLruCache,LruCache用于实现内存缓存, DiskLruCache则充当了存储设备缓存, 当组合使用后就可以实现一个类似ImageLoader这样的类库. ","date":"2016-08-23","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-12-bitmap%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8Ccache/:2:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 12-Bitmap的加载和Cache","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-12-bitmap%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8Ccache/"},{"categories":null,"content":"LruCache LruCache是Android 3.1所提供的一个缓存类, 通过support-v4兼容包可以兼容到早期的Android版本 LruCache是一个泛型类, 它内部采用了一个LinkedHashMap以强引用的方式存储外界的缓存对象, 其提供了get和put方法来完成缓存的获取和添加的操作. 当缓存满了时, LruCache会移除较早使用的缓存对象, 然后在添加新的缓存对象. 普及一下各种引用的区别: 强引用: 直接的对象引用 软引用: 当一个对象只有软引用存在时, 系统内存不足时此对象会被gc回收 弱引用: 当一个对象只有弱引用存在时, 对象会随下一次gc时被回收 创建的缓存对象大小通过可用内存的1/8来进行分配, 并需要重写sizeOf()方法, sizeOf()是计算缓存对象的大小, 如果有需要还可以重写entryRemoved(),在Lru移除旧缓存的时候回调用此方法. 获取, 添加, 删除, 分别对应get, put, remove ","date":"2016-08-23","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-12-bitmap%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8Ccache/:2:1","tags":["android","笔记"],"title":"《Android 开发艺术探索》 12-Bitmap的加载和Cache","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-12-bitmap%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8Ccache/"},{"categories":null,"content":"DiskLruCache DiskLruCache用于实现存储设备缓存, 即磁盘缓存. 它通过将缓存对象写入文件系统从而实现缓存的效果. 1. DiskLruCache的创建 DiskLruCache并不能通过构造方法来创建, 他提供了open()方法用于创建自身, 如下所示 public static DiskLruCache open(File directory, int appVersion, int valueCount, long maxSize) 这个方法有四个参数: File directory: 表示磁盘缓存在文件系统中的存储路径. 可以选择SD卡上的缓存目录, 具体是指/sdcard/Andriod/data/package_name/cache目录, package_name表示当前应用的包名, 当应用被卸载后, 此目录会一并删除掉. 也可以选择data目录下. 或者其他地方. **这里给出的建议:**如果应用卸载后就希望删除缓存文件的话 , 那么就选择SD卡上的缓存目录, 如果希望保留缓存数据那就应该选择SD卡上的其他目录. int appVersion: 表示应用的版本号, 一般设为1即可. 当版本号发生改变的时候DiskLruCache会清空之前所有的缓存文件, 在实际开发中这个实用性不大. int valueCount: 表示单个节点所对应的数据的个数, 一般设为1. long maxSize: 表示缓存的总大小, 比如50MB, 当缓存大小超出这个设定值后, DiskLruCache会清除一些缓存而保证总大小不大于这个设定值. 2. DiskLruCache的缓存添加 DiskLruCache的缓存添加的操作是通过Editor完成的, Editor表示一个缓存对象的编辑对象. 如果还是缓存图片为例子, 每一张图片都通过图片的url为key, 这里由于url可能会有特殊字符所以采用url的md5值作为key. 根据这个key就可以通过edit()来获取Editor对象, 如果这个缓存对象正在被编辑, 那么edit()就会返回null. 即DiskLruCache不允许同时编辑一个缓存对象. 当用.edit(key)获得了Editor对象之后. 通过editor.newOutputStream(0)就可以得到一个文件输出流. 由于之前open()方法设置了一个节点只能有一个数据. 所以在获得输出流的时候传入常量0即可. 有了文件输出流, 可以当网络下载图片时, 图片就可以通过这个文件输出流写入到文件系统上. 别忘了使用Bufferedxxxxx写完之后, 要通过Editor中commit()来提交写操作, 如果下载中发生异常, 那么使用Editor中abort()来回退整个操作. 3. DiskLruCache的缓存查找 和缓存的添加过程类似, 缓存查找过程也需要将url转换成key, 然后通过DiskLruCache#get()方法可以得到一个Snapshot对象, 接着在通过Snapshot对象即可得到缓存的文件输入流, 有了文件输入流, 自然就可以得到Bitmap对象. 为了避免加载图片出现OOM所以采用压缩的方式. 在前面对BitmapFactory.Options的使用说明了. 但是这中方法对FileInputStream的缩放存在问题. 原因是FileInputStream是一种有序的文件流, 而两次decodeStream调用会影响文件的位置属性, 这样在第二次decodeStream的时候得到的会是null. 针对这一个问题, 可以通过文件流来得到它所对应的文件描述符, 然后通过BitmapFactory.decodeFileDescription()来加载一张缩放后的图片. ","date":"2016-08-23","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-12-bitmap%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8Ccache/:2:2","tags":["android","笔记"],"title":"《Android 开发艺术探索》 12-Bitmap的加载和Cache","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-12-bitmap%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8Ccache/"},{"categories":null,"content":"ImageLoader的实现 一个好的ImageLoader应该具备以下几点: 图片的压缩 网络拉取 内存缓存 磁盘缓存 图片的同步加载 图片的异步加载 也可以利用picasso和glide这种图片加载类库, 使用构建者模式提供使用. 本文练习demo实现了链式调用设置控件,并制定url然后自动去获取. 相关联的类在load包中 可以看看有了缓存的区别 ","date":"2016-08-23","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-12-bitmap%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8Ccache/:2:3","tags":["android","笔记"],"title":"《Android 开发艺术探索》 12-Bitmap的加载和Cache","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-12-bitmap%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8Ccache/"},{"categories":null,"content":"ImageLoader的使用 ","date":"2016-08-23","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-12-bitmap%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8Ccache/:3:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 12-Bitmap的加载和Cache","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-12-bitmap%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8Ccache/"},{"categories":null,"content":"照片墙效果 这里定义一个自定义的ImageView作为GridView的item布局控件, 之所以这样是想让图片的控件自动去使用设备达到宽高相等的效果比较好看些 public class SquareImageView extends ImageView { public SquareImageView(Context context) { super(context); } public SquareImageView(Context context, AttributeSet attrs) { super(context, attrs); } public SquareImageView(Context context, AttributeSet attrs, int defStyleAttr) { super(context, attrs, defStyleAttr); } @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { // 由于这里准备提供给GridView控件使用, 对于一个水平线有几个是未知的 // 那么通过父控件的测量传到这里的宽度规格, 也当做高度即可 super.onMeasure(widthMeasureSpec, widthMeasureSpec); } } 这个实现很简单, 利用动态的宽度同时也当做高度即可实现预期的效果. 这个就是结果, 或许应该对网络加上判断非wifi给一个提示, 可能首次加载会需要比较多的流量. // 根据连接网络的情况判断是否加载图片 if (!NetWorkUtil.isWifi(getApplicationContext())) { AlertDialog.Builder builder = new AlertDialog.Builder(this); builder.setMessage(\"首次使用会从手机网络下载图片, 是否确认下载?\") .setTitle(\"友情提示\") .setPositiveButton(\"好的.\", new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { mCanLoadForPhoneNet = true; imageAdapter.notifyDataSetChanged(); } }) .setNegativeButton(\"不行!\", new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialog, int which) { Toast.makeText(getApplicationContext(), \"瞅你扣那样!!!\", Toast.LENGTH_LONG).show(); } }).show(); }else{ mCanLoadForPhoneNet = true; } // NetWorkUtil类 public class NetWorkUtil { public static boolean isWifi(Context context) { ConnectivityManager connectivityManager = (ConnectivityManager) context .getSystemService(Context.CONNECTIVITY_SERVICE); NetworkInfo activeNetInfo = connectivityManager.getActiveNetworkInfo(); if (activeNetInfo != null \u0026\u0026 activeNetInfo.getType() == ConnectivityManager.TYPE_WIFI) { return true; } return false; } } 然后优化列表 只有在GridView静止的时候才进行图片加载, 避免滑动时候的无谓的线程加载消耗(即使ImageLoader内部使用了线程池, 你仍然有这么做的必要) GridView gv_main = (GridView) findViewById(R.id.gv_main); // 监听GridView的滑动状态 gv_main.setOnScrollListener(new AbsListView.OnScrollListener() { @Override public void onScrollStateChanged(AbsListView view, int scrollState) { if (scrollState == AbsListView.OnScrollListener.SCROLL_STATE_IDLE){ mIsGridViewIdle = true; // 并触发更新adapter imageAdapter.notifyDataSetChanged(); }else{ mIsGridViewIdle = false; } } @Override public void onScroll(AbsListView view, int firstVisibleItem, int visibleItemCount, int totalItemCount) { } }); 最后在adapter中的getView()设置标记位的判断, 只有在wifi和静止的状态下才进行加载请求下面是getView()代码 @Override public View getView(int position, View convertView, ViewGroup parent) { ViewHolder holder = null; if (convertView == null){ convertView = View.inflate(mContext, R.layout.item_photo_wall, null); holder = new ViewHolder(); holder.mImageView = (ImageView) convertView.findViewById(R.id.iv_square); convertView.setTag(holder); }else{ holder = (ViewHolder) convertView.getTag(); } // 设置默认图片 ImageView mImageView = holder.mImageView; mImageView.setImageResource(android.R.drawable.screen_background_dark_transparent); // 检测是否wifi 和 是否是滑动状态 // 优化重点 if (mCanLoadForPhoneNet \u0026\u0026 mIsGridViewIdle){ // 加载图片 mImageLoader.setImageView(mImageView).url(mUrls.get(position)); } return convertView; } ","date":"2016-08-23","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-12-bitmap%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8Ccache/:3:1","tags":["android","笔记"],"title":"《Android 开发艺术探索》 12-Bitmap的加载和Cache","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-12-bitmap%E7%9A%84%E5%8A%A0%E8%BD%BD%E5%92%8Ccache/"},{"categories":null,"content":" 第11章: 不仅仅是在Android中, 就算java中线程都是一块很重要的知识, 占有不小的比重. blog相关代码 除了最常使用的Thread之外, 在Android之中可以扮演线程角色的还有很多: 如AsyncTask和IntentService, 同时HandlerThread也是一种特殊的线程. 虽然这些线程的表现形式有别于基础线程. 但是本质上还是传统的线程. 例如AsyncTask它的底层使用了线程池. 而对于IntentService和HandlerThread来说, 他们的底层则直接使用了线程. 根据不同的特性来实现不同的场景 AsyncTask: 封装了线程池和Handler, 它主要是为了方便开发者在子线程中更新UI. HandlerThread: 是一种具有消息循环的线程, 在它的内部可以使用Handler. IntentService: 是一个服务, 系统对其进行了封装使其可以更方便地执行后台任务, IntentService内部采用了HandlerThread来执行任务, 当任务执行完毕后IntentService会自动退出. 从执行任务的角度来看, 更像一个后台的线程. 但是因为其本身是一种服务, 所以导致不容易被系统杀死从而保证任务的执行. 而如果是一个后台线程, 由于这个时候进行中没有活动的四大组件, 那么这个进程的优先级会很低, 很容易被系统杀死, 这就是IntentService的优点. 线程的简单概述 在操作系统中, 线程是操作系统调度的最小单元, 同时线程又是一种受限的系统资源, 即线程不可能无限制的产生, 并且线程的创建和销毁都会有相应的开销. 当系统中存在大量的线程时, 系统会通过时间片转轮的方式调度每个线程, 因此线程不可能做到绝对的并行, 除非线程数量小于等于cpu的核心数. 但这种情况太少了, 所以线程池的概念就由此出现. 通过线程池就可以避免因为频繁创建和销毁线程所带来的系统开销. ","date":"2016-08-22","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-11-android%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/:0:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 11-Android的线程和线程池","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-11-android%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"categories":null,"content":"主线程和子线程 主线程是指进程所拥有的线程, 在Java中默认情况下一个进程只有一个线程, 这个线程就是主线程. 主线程主要处理界面交互相关的逻辑, 因为用户随时会和界面发生交互, 因此主线程在任何时候都必须有较高的响应速度, 否则就会产生一种界面卡顿的感觉. 为了保持较高的响应速度, 这就要求主线程中不能执行耗时的任务, 这个时候子线程就派上用场. 子线程也叫作工作线程, 除了主线程以外的线程都叫做子线程 Android沿用了Java的线程模型, 其中的线程也分为主线程和子线程, 其中主线程也叫UI线程. 主线程的作用是运行四大组件以及处理它们和用户的交互. 而子线程的作用则是执行耗时任务, 比如网络请求, I/O操作等. 从Android 3.0 开始系统要求网络访问必须在子线程中进行, 否则网络访问将会失败并抛出NetworkOnMainThreadException这个异常, 这样做是为了避免主线程由于耗时操作所阻塞从而出现ANR现象. ","date":"2016-08-22","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-11-android%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/:1:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 11-Android的线程和线程池","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-11-android%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"categories":null,"content":"Android中的线程形态 ","date":"2016-08-22","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-11-android%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/:2:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 11-Android的线程和线程池","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-11-android%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"categories":null,"content":"AsyncTask AsyncTask是一种轻量级的异步任务类, 他可以在线程池中执行后台任务, 然后把执行的进度和最终的结果传递给主线程并在主线程更新UI. 从实现上来说. AsyncTask封装了Thread和Handler, 通过AsyncTask可以更加方便地执行后台任务, 对于特别耗时的任务来说, 建议使用线程池. public abstract class AsyncTask\u003cParams, Progress, Result\u003e { // 省略一大坨代码 } AsyncTask就是一个抽象的泛型类. 这三个泛型的意义. Params: 表示参数的类型 Progress: 表示后台任务的执行进度的类型 Result: 则表示后台任务的返回结果的类型 如果不需要传递具体的参数, 那么这三个泛型参数可以用Void来代替. AsyncTask提供了4个核心方法, 含义如下 onPreExecute(): 在主线程执行, 在异步任务执行之前, 此方法会被调用, 一般可以用于做一些准备工作 doInBackground(): 在线程池中执行, 此方法用于执行异步任务, 参数params表示异步任务的输入参数. 在此方法中可以通过publishProgress()方法来更新任务的进度, publishProgress()方法会调用onProgressUpdate()方法. 另外此方法需要返回计算结果给onPostExecute() onProgressUpdate(): 在主线程执行,在异步任务执行之后, 此方法会被调用, 其中result参数是后台任务的返回值, 即doInBackground()的返回值. onPostExecute(): 在主线程执行, 在异步任务执行之后, 此方法会被调用, 其中result参数是后台任务的返回值, 即doInBackground的返回值. 除了上述的四种方法,还有onCancelled(), 它同样在主线程执行, 当异步任务被取消时, onCancelled()方法会被调用, 这个时候onPostExecute()则不会被调用. AsyncTask在使用过程中有一些条件限制 AsyncTask的类必须在主线程被加载, 这就意味着第一次访问AsyncTask必须发生在主线程, 这个问题不是绝对, 因为在Android 4.1及以上的版本已经被系统自动完成. 在Android 5.0的源码中, 可以看到ActivityThread#main()会调用AsyncTask#init()方法. AsyncTask的对象必须在主线程中创建. execute方法必须在UI线程调用. 不要在程序中直接调用onPreExecute(), onPostExecute(), doInBackground和onProgressUpdate() 一个AsyncTask对象只能执行一次, 即只能调用一次execute()方法, 否则会报运行时异常. 在Android 1.6之前, AsyncTask是串行执行任务的; Android 1.6的时候AsyncTask开始采用线程池里处理并行任务; 但是Android 3.0开始, 为了避免AsyncTask带来的并发错误, AsyncTask又采用了一个线程来串行的执行任务. 尽管如此在3.0以后, 仍然可以通过AsyncTask#executeOnExecutor()方法来并行执行任务. ","date":"2016-08-22","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-11-android%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/:2:1","tags":["android","笔记"],"title":"《Android 开发艺术探索》 11-Android的线程和线程池","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-11-android%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"categories":null,"content":"AsyncTask的工作原理 这里以源码5.0来分析, 不同的版本源码具体实现是不同的. 为了分析AsyncTask的工作原理, 可以从它的execute()方法开始分析, execute()方法又会调用executeOnExecutor()方法. 实际上这里调用进来后是一个串行的线程池, 一个进程中所有的AsyncTask全都在这个串行的线程池中排队执行, 然后会先调用AsyncTask#onPreExecute()方法, 然后线程池开始执行. 看看SerialExecutor()的源码实现: public static final Executor SERIAL_EXECUTOR = new SerialExecutor(); private static volatile Executor sDefaultExecutor = SERIAL_EXECUTOR; private static class SerialExecutor implements Executor { final ArrayDeque\u003cRunnable\u003e mTasks = new ArrayDeque\u003cRunnable\u003e(); Runnable mActive; public synchronized void execute(final Runnable r) { mTasks.offer(new Runnable() { public void run() { try { r.run(); } finally { scheduleNext(); } } }); if (mActive == null) { scheduleNext(); } } protected synchronized void scheduleNext() { if ((mActive = mTasks.poll()) != null) { THREAD_POOL_EXECUTOR.execute(mActive); } } } 在SerialExecutor的实现可以分析AsyncTask的排队执行的过程. 首先系统会把AsyncTask#Params参数封装成FutureTask对象, FutureTask是一个并发类, 在这里充当了Runnable的作用. 接着这个FutureTask会交给SerialExecutor#execute()方法去处理. 这个方法首先会把FutureTask对象插入到任务队列mTasks中, 如果这个时候没有正在活动AsyncTask任务, 那么就会调用SerialExecutor#scheduleNext()方法来执行下一个AsyncTask任务. 同时当一个AsyncTask任务执行完后, AsyncTask会继续执行其他任务直到所有的任务都执行完毕为止, 从这一点可以看出, 在默认情况下, AsyncTask是串行执行的 AsyncTask中有两个线程池(SerialExecutor和THREAD_POOL_EXECUTOR)和一个Handler(InternalHandler), 其中线程池SerialExecutor用于任务的排列, 而线程池THREAD_POOL_EXECUTOR用于真正的执行任务, 而InternalHandler用于将执行环境从线程切换到主线程, 其本质仍然是线程的调用过程. 在AsyncTask的构造方法中有如下这段代码, 由于FutureTask#run()方法会调用mWorker.call()方法, 因此mWorker的call方法最终会在线程池中执行. mWorker = new WorkerRunnable\u003cParams, Result\u003e() { public Result call() throws Exception { mTaskInvoked.set(true); Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND); //noinspection unchecked return postResult(doInBackground(mParams)); } }; 在mWorker.call()方法中, 首先将mTaskInvoked设为了true. 表示当前任务已经被调用过了. 然后执行AsyncTask#doInBackground()方法, 接着将其返回值传递给postResult(), 这个方法的实现: private Result postResult(Result result) { @SuppressWarnings(\"unchecked\") Message message = sHandler.obtainMessage(MESSAGE_POST_RESULT, new AsyncTaskResult\u003cResult\u003e(this, result)); message.sendToTarget(); return result; } 这里, postResult()会通过sHandler发送一个MESSAGE_POST_RESULT消息, 而sHandler的定义如下: private static final InternalHandler sHandler = new InternalHandler(); private static class InternalHandler extends Handler { @SuppressWarnings({\"unchecked\", \"RawUseOfParameterizedType\"}) @Override public void handleMessage(Message msg) { AsyncTaskResult result = (AsyncTaskResult) msg.obj; switch (msg.what) { case MESSAGE_POST_RESULT: // There is only one result result.mTask.finish(result.mData[0]); break; case MESSAGE_POST_PROGRESS: result.mTask.onProgressUpdate(result.mData); break; } } } 可以看出sHandler是一个静态的Handler对象, 为了能够将执行环境切换到主线程, 这就要求sHandler这个对象必须在主线程中创建. 由于静态成员会在加载类的时候进行初始化, 因此这就变相要求AsyncTask的类必须在主线程中加载, 否则同一个进程中的AsyncTask都无法正常工作. sHandler收到了消息后会调用AsyncTask#finish()方法, 如下: private void finish(Result result) { if (isCancelled()) { onCancelled(result); } else { onPostExecute(result); } mStatus = Status.FINISHED; } 这个finish()方法很简单, 如果AsyncTask被取消了, 那么就调用onCancelled()方法, 否则就会调用onPostExecute()方法, 可以看到doInBackground的反馈结果会传递给onPostExecute()方法. 通过源码分析, 可以确定从3.0开始, 默认情况下AsyncTask就是串行的. 通过一段代码测试. @Override public void onClick(View v) { switch (v.getId()){ case R.id.btn_main: new MyAsync(\"任务_1\").execute(\"\"); new MyAsync(\"任务_2\").execute(\"\"); new MyAsync(\"任务_3\").execute(\"\"); new MyAsync(\"任务_4\").execute(\"\"); new MyAsync(\"任务_5\").execute(\"\"); break; } } private static class MyAsync extends AsyncTask\u003cString, Integer, String\u003e{ private static final String TAG = MyAsync.class.getSimpleName(); private final String mTaskName; public MyAsync(String taskName){ mTaskName = taskName; } @Override protected String doInBackground(String... params) { SystemClock.sleep(3000); return mTaskName; } @Override protected void onPostExecute(String s) { super.onPostExecute(s); SimpleDateFormat df = new SimpleDateFormat(\"HH:mm:ss\"); Log.e(TAG, s+\" onPostExecute finish time: \" +df.format(new Date())); } } 给按钮添加一个点击触","date":"2016-08-22","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-11-android%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/:2:2","tags":["android","笔记"],"title":"《Android 开发艺术探索》 11-Android的线程和线程池","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-11-android%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"categories":null,"content":"HandlerThread HandlerThread继承了Thread, 它是一种可以使用Handler的Thread, 它的实现也很简单, 就是run方法中通过Looper.prepare()来创建消息队列, 并通过Looper.loop()来开启消息循环, 这样在实际的使用中就允许在HandlerThread中创建Handler, 看一下run()方法. @Override public void run() { mTid = Process.myTid(); Looper.prepare(); synchronized (this) { mLooper = Looper.myLooper(); notifyAll(); } Process.setThreadPriority(mPriority); onLooperPrepared(); Looper.loop(); mTid = -1; } 从HandlerThread的实现来看, 它和普通的Thread有显著的不同之处. 普通的Thread主要用于在run方法中执行一个耗时任务; 而HandlerThread在内部创建了消息队列, 外界需要通过Handler的消息方式来通知HandlerThread执行一个具体的任务. HandlerThread是一个很有用的类, 在Android中一个具体使用场景就是IntentService. 由于HandlerThread#run()是一个无线循环方法, 因此当明确不需要再使用HandlerThread时, 最好通过quit()或者quitSafely()方法来终止线程的执行. ","date":"2016-08-22","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-11-android%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/:2:3","tags":["android","笔记"],"title":"《Android 开发艺术探索》 11-Android的线程和线程池","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-11-android%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"categories":null,"content":"IntentService IntentService是一种特殊的Service, 它继承了Service并且它是一个抽象类, 因此需要创建子类才能使用. IntentService可以用于执行后台耗时任务, 当任务执行后会自动停止, 同时由于本质是服务的原因, 这导致了它的优先级比单纯的线程要高很多, 所以IntentService比较适合执行一些高优先级的后台任务. IntentService封装了Handler和HandlerThread. 这是在onCreate()来实现的. @Override public void onCreate() { // TODO: It would be nice to have an option to hold a partial wakelock // during processing, and to have a static startService(Context, Intent) // method that would launch the service \u0026 hand off a wakelock. super.onCreate(); HandlerThread thread = new HandlerThread(\"IntentService[\" + mName + \"]\"); thread.start(); mServiceLooper = thread.getLooper(); mServiceHandler = new ServiceHandler(mServiceLooper); } 当第一次启动的时候, onCreate()就会被调用, 内部就会创建一个HandlerThread, 然后使用它的Looper来构造一个Handler对象mServiceHandler. 这样通过 mServiceHandler发送的消息最终都会在HandlerThread中执行, 从这个角度看IntentService也可以用于执行后台任务. 每次启动IntentService的时候, 它的onStartCommand()方法就会被调用一次, IntentService在onStartCommand()中处理每个后台任务的Intent. 看看源码是如何处理外界的Intent的. 首先onStartCommand()调用了onStart() @Override public void onStart(Intent intent, int startId) { Message msg = mServiceHandler.obtainMessage(); msg.arg1 = startId; msg.obj = intent; mServiceHandler.sendMessage(msg); } 这个方法只是通过mServiceHandler发送了一个消息, 所以这个消息会在HandlerThread中被处理. 消息收到后, 会将Intent对象传递给onHandlerIntent()方法去处理. 注意这个Intent对象和外界startService()参数传递内容是一样的. 通过Intent的参数就可以区分具体的后台任务, 这样在onHandlerIntent()方法中就可以对不同的后台任务做处理了. 当onHandlerIntent()方法执行完毕后, IntentService会通过stopSelf()方法来停止服务. 这里使用的方法是有参数的, 不使用无参数的stopSelf()是因为无参函数会立刻停止服务, 可能会导致还有没执行完的任务失效. 有参的stopSelf(int startId)在尝试 停止服务之前会判断最近启动的服务次数是否和startId这个参数值相等, 如果相等就立刻停止服务, 否则反之. 这个策略可以从AMS#stopServiceToken()方法的实现中找到依据. IntentService#onHandleIntent()方法是一个抽象方法, 他需要我们在子类中实现, 它的作用是从Intent参数中区分具体的任务并执行这些任务. 如果目前只存在一个后台任务, 那么onHandleIntent()方法执行完成后, stopSelf(int startId)会立即停止服务; 如果目前存在多个后台任务, 那么当onHandleIntent()方法执行完最后一个任务时, stopSelf(int startId)才会停止任务. 另外由于每次执行一个后台任务都必须启动一次IntentService, 而其内部则通过消息的方式向HandlerThread请求执行任务, Handler中的Looper是顺序处理消息的, 这就意味着IntentService也是顺序执行后台任务的, 当有多个后台任务同时存在时, 这些后台任务会按照外界发起的顺序排队执行. 用代码来演示一遍: // 派生一个IntentService 的子类 public static class LocalIntentService extends IntentService { private static final String TAG = LocalIntentService.class.getSimpleName(); public LocalIntentService() { super(TAG); } @Override protected void onHandleIntent(Intent intent) { String task = intent.getStringExtra(\"task\"); Log.d(TAG, \"receiver task :\"+task); SystemClock.sleep(2000); } @Override public void onDestroy() { Log.w(TAG, \"onDestroy: 准备关闭\" ); super.onDestroy(); } } // 开启3个服务 Intent service = new Intent(this, LocalIntentService.class); service.putExtra(\"task\", \"hi, 我是数据1\"); startService(service); service.putExtra(\"task\", \"hi, 我是数据2\"); startService(service); service.putExtra(\"task\", \"hi, 我是数据3\"); startService(service); 可以看出, 三个后台任务是串行执行的, 他们的执行顺序就是发起请求的顺序. 当任务3完成了之后. LocalIntentService才真正的停止, 因为这是时候执行了onDestroy(). ","date":"2016-08-22","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-11-android%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/:2:4","tags":["android","笔记"],"title":"《Android 开发艺术探索》 11-Android的线程和线程池","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-11-android%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"categories":null,"content":"Android中的线程池 概括一下线程池的优点: 重用线程池中的线程, 避免因为线程的创建和销毁所带来的性能开销. 能有效控制线程的最大并大数, 避免大量的线程之间因互相抢占系统资源而导致的阻塞现象. 能够对线程进行简单的管理, 并提供定时执行以及指定间隔循环执行等能力. Android中的线程池的概念来源于Java中的Executor, Executor是一个接口, 真正的线程池的实现为ThreadPoolExecutor. ThreadPoolExecutor提供了一系列参数来配制线程池, 通过不同的参数可以创建不同的线程池. 而从功能的特性来分的话可以分成四类. 下面说明. ","date":"2016-08-22","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-11-android%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/:3:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 11-Android的线程和线程池","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-11-android%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"categories":null,"content":"ThreadPoolExecutor ThreadPoolExecutor是线程池的真正实现, 它的构造方法提供了一系列参数来配置线程池, 下面对构造方法中参数进行一下说明, 这些参数将会直接影响到线程池的功能特性. public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue\u003cRunnable\u003e workQueue) { this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, Executors.defaultThreadFactory(), defaultHandler); } corePoolSize: 线程池的核心线程数, 默认情况下, 核心线程会在线程池中一直存活, 即使都处于闲置状态. 如果将ThreadPoolExecutor#allowCoreThreadTimeOut属性设置为true, 那么闲置的核心线程在等待新任务到来时会有超时的策略, 这个时间间隔由keepAliveTime属性来决定. 当等待时间超过了keepAliveTime设定的值那么核心线程将会终止. maximumPoolSize: 线程池所能容纳的最大线程数, 当活动线程数达到这个数值之后, 后续的任务将会被阻塞. keepAliveTime: 非核心线程闲置的超时时长, 超过这个时长, 非核心线程就会被回收. allowCoreThreadTimeOut这个属性为true的时候, 这个属性同样会作用于核心线程. unit: 用于指定keepAliveTime参数的时间单位, 这是一个枚举, 常用的有TimeUtil.MILLISECONDS(毫秒), TimeUtil.SECONDS(秒)以及TimeUtil.MINUTES(分) workQueue: 线程池中的任务队列, 通过线程池的execute方法提交的Runnable对象会存储在这个参数中. threadFactory: 线程工厂, 为线程池提供创建新线程的功能. ThreadFactory是一个接口. 线程池执行任务时大致遵循如下规则: 如果线程池中的线程数量未达到核心线程的数量, 那么会直接启动一个核心线程来执行任务. 如果线程池中的线程数量已经达到或者超过核心线程的数量, 那么任务会被插入到任务队列中排队等待执行. 如果在步骤2中无法将任务插入到任务队列中, 这通常是因为任务队列已满, 这个时候如果线程数量未达到线程池的规定的最大值, 那么会立刻启动一个非核心线程来执行任务. 如果步骤3中的线程数量已经达到最大值的时候, 那么会拒绝执行此任务, ThreadPoolExecutor会调用RejectedExecution方法来通知调用者. ThreadPoolExecutor的参数配置在AsyncTask中有明显的体现, 下面是其配置情况 private static final int CPU_COUNT = Runtime.getRuntime().availableProcessors(); private static final int CORE_POOL_SIZE = CPU_COUNT + 1; private static final int MAXIMUM_POOL_SIZE = CPU_COUNT * 2 + 1; private static final int KEEP_ALIVE = 1; private static final ThreadFactory sThreadFactory = new ThreadFactory() { private final AtomicInteger mCount = new AtomicInteger(1); public Thread newThread(Runnable r) { return new Thread(r, \"AsyncTask #\" + mCount.getAndIncrement()); } }; private static final BlockingQueue\u003cRunnable\u003e sPoolWorkQueue = new LinkedBlockingQueue\u003cRunnable\u003e(128); /** * An {@link Executor} that can be used to execute tasks in parallel. */ public static final Executor THREAD_POOL_EXECUTOR = new ThreadPoolExecutor(CORE_POOL_SIZE, MAXIMUM_POOL_SIZE, KEEP_ALIVE, TimeUnit.SECONDS, sPoolWorkQueue, sThreadFactory); 这个配置后的规格是这样的 核心线程数等于CPU核心数 + 1; 线程池的最大线程数为CPU核心数的2倍 + 1; 核心线程无超时机制, 非核心线程在闲置时有超时机制,超时时间为1秒. 任务队列的容量为128 ","date":"2016-08-22","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-11-android%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/:3:1","tags":["android","笔记"],"title":"《Android 开发艺术探索》 11-Android的线程和线程池","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-11-android%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"categories":null,"content":"线程池的分类 1. FixedThreadPool 通过Executors#newFixedThreadPool()方法来创建. 它是一种线程数量固定的线程池, 当线程处于空闲状态时, 它们并不会被回收, 除非线程池关闭了. 当所有的线程都处于活动状态时, 新任务都会处于等待状态, 直到有线程空闲出来. 由于FixedThreadPool只有核心线程并且这些核心线程不会被回收, 这意味着它能够更加快速地响应外界的请求. 2. CachedThreadPool 通过Executors#newCachedThreadPool()方法来创建. 它是一种线程数量不定的线程池, 它只有非核心线程, 并且其最大值线程数为Integer.MAX_VALUE. 这就可以认为这个最大线程数为任意大了. 当线程池中的线程都处于活动的时候, 线程池会创建新的线程来处理新任务, 否则就会利用空闲的线程来处理新任务. 线程池中的空闲线程都有超时机制, 这个超时时长为60S, 超过这个时间那么空闲线程就会被回收. 和FixedThreadPool不同的是, CachedThreadPool的任务队列其实相当于一个空集合, 这将导致任何任务都会立即被执行, 因为在这种场景下SynchronousQueue是无法插入任务的. SynchronousQueue是一个非常特殊的队列, 在很多情况下可以把它简单理解为一个无法存储元素的队列. 在实际使用中很少使用.这类线程比较适合执行大量的耗时较少的任务 3. ScheduledThreadPool 通过Executors#newScheduledThreadPool()方法来创建. 它的核心线程数量是固定的, 而非核心线程数是没有限制的, 并且当非核心线程闲置时会立刻被回收掉. 这类线程池用于执行定时任务和具有固定周期的重复任务 4. SingleThreadExecutor 通过Executors#newSingleThreadPool()方法来创建. 这类线程池内部只有一个核心线程, 它确保所有的任务都在同一个线程中按顺序执行. 这类线程池意义在于统一所有的外界任务到一个线程中, 这使得在这些任务之间不需要处理线程同步的问题 第12章: Bitmap的加载和Cache ","date":"2016-08-22","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-11-android%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/:3:2","tags":["android","笔记"],"title":"《Android 开发艺术探索》 11-Android的线程和线程池","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-11-android%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0/"},{"categories":null,"content":" 第10章: Handler究竟是如何运行的. Android的消息机制主要指Handler的运行机制, Handler的运行需要底层的MessageQueue和Lopper的支撑. MessageQueue消息机制, 内部存储了一组消息, 以队列的形式对外提供插入和删除工作. 虽然叫消息队列,但是其内部存储结构并不是真正的队列,而是采用单链表的数据结构来存储消息列表. Looper消息循环, 因为MessageQueue本质只是一个消息的存储单元, 它不能去处理消息, 而Looper就是为实现处理而产生的. Looper会以无限循环的形式去查找是否有新消息, 如果有的话就处理消息, 否在就一直等待. Looper中有一个特殊的概念ThreadLocal, ThreadLocal并不是一个线程, 它可以在每个线程中进行数据的存储. 我们使用的Handler创建的时候都会采用当前线程的Looper来构造消息循环系统, 而这个当前线程就是通过ThreadLocal来进行操作的. 有一点需要记住: 一个新的线程默认是没有Looper的, 如果要使用Handler就必为线程创建Looper, 而我们使用主线程的时候之所以不需要创建Looper是因为. UI线程也就是ActivityThread在被创建的时候就会初始化Looper, 所以我们在主线程也就可以直接使用Handler的原因. ","date":"2016-08-22","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-10-android%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/:0:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 10-Android的消息机制","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-10-android%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"},{"categories":null,"content":"Android 的消息机制描述 在日常开发中如果不小心在子线程更新了UI那么就会抛出异常, 这一步骤是在ViewRootImpl#checkThread()方法完成的. void checkThread() { if (mThread != Thread.currentThread()) { throw new CalledFromWrongThreadException( \"Only the original thread that created a view hierarchy can touch its views.\"); } } 那Handler可以认为是为了在子线程处理完操作可以切回到主线程进行UI操作的用途. 那为什么不能再子线程进行UI处理呢? 这是因为Android的UI线程控件不是线程安全, 如果在多线程中并发的访问可能会导致UI控件处于不可预期的状态, 虽然可以用加锁的形式让上述问题消失, 但是有两个弊端: 加锁机制会让UI访问的逻辑变得复杂 锁机制会降低UI的访问的效率, 因为锁机制会阻塞某些线程的执行. 因为这样, 最简单且高效的方法就是采用单线程模型来处理UI操作. 当Handler, Looper, MessageQueue都准备好之后. 就可以通过Handler#post()方法将一个Runnable投递到Handler内部的Looper中去处理, 也可以通过send()方法来发送一个消息, 这个消息同样会在Looper中处理. 而post()内部也是通过send()来发送的. ","date":"2016-08-22","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-10-android%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/:1:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 10-Android的消息机制","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-10-android%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"},{"categories":null,"content":"Android消息机制分析 ","date":"2016-08-22","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-10-android%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/:2:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 10-Android的消息机制","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-10-android%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"},{"categories":null,"content":"ThreadLocal的工作原理 ThreadLocal是一个线程内部的数据存储类, 通过他可以在指定的线程中存储数据. 数据存储以后, 只能在指定线程中可以获取到存储的数据. 而其他线程无法获取. 而Android中的Looper ,ActivityThread, AMS都用到了ThreadLocal. 可以这样来说: 当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候, 可以采用ThreadLocal. 可以自己用三个线程分别对一个ThreadLocal对象进行操作, 虽然操作的是一个对象, 但是每个线程在获取值的时候却不相同. 这是因为: 不同的线程访问同一个ThreadLocal#get()方法的时候, ThreadLocal内部会从各自的线程中取出一个数组, 然后再从数组中根据当前ThreadLocal的索引去查找出对应的value值. 可以看出不同的线程中的数组是不相同的. 所以也就是为什么使用ThreadLocal可以在不同的线程中维护一套数据的副本并且彼此互不影响. 还是用源码来梳理流程 ThreadLocal是一个泛型类, 它的定义为public class ThreadLocal\u003cT\u003e, 看一下set()或者get()就明白了. public void set(T value) { Thread currentThread = Thread.currentThread(); Values values = values(currentThread); if (values == null) { values = initializeValues(currentThread); } values.put(this, value); } 首先会通过value()方法来获取当前线程中的ThreadLocal数据. 就是在Thread类的内部有一个成员专门用于存储线程的ThreadLocal的数据ThreadLocal.Values localValues. 如果value的值为null那么就会进行初始化, 初始化结束之后再将ThreadLocal的值进行存储. 具体看一下是如何在localValues中进行存储的. 在localValues中有一个数组private Object[] table, ThreadLocal的值就存在在这个table数组中. 看一下put()方法. void put(ThreadLocal\u003c?\u003e key, Object value) { cleanUp(); // Keep track of first tombstone. That's where we want to go back // and add an entry if necessary. int firstTombstone = -1; for (int index = key.hash \u0026 mask;; index = next(index)) { Object k = table[index]; if (k == key.reference) { // Replace existing entry. table[index + 1] = value; return; } if (k == null) { if (firstTombstone == -1) { // Fill in null slot. table[index] = key.reference; table[index + 1] = value; size++; return; } // Go back and replace first tombstone. table[firstTombstone] = key.reference; table[firstTombstone + 1] = value; tombstones--; size++; return; } // Remember first tombstone. if (firstTombstone == -1 \u0026\u0026 k == TOMBSTONE) { firstTombstone = index; } } } 这里只说看得出的规则, 不需要具体看实现的算法. 规则就是ThreadLocal的值在table数组中的存储位置总是为ThreadLocal的reference字段所标示的对象的下一个位置. 例如如果ThreadLocal的reference对象在table中的索引为index, 那么ThreadLocal的值在table数组中的索引就是index+1. 接着看get()方法 public T get() { // Optimized for the fast path. Thread currentThread = Thread.currentThread(); Values values = values(currentThread); if (values != null) { Object[] table = values.table; int index = hash \u0026 values.mask; if (this.reference == table[index]) { return (T) table[index + 1]; } } else { values = initializeValues(currentThread); } return (T) values.getAfterMiss(this); } 而ThreadLocal#get()方法, 同样是取出当前线程的Values对象, 同样的通过reference的角标+1来获取. 如果取出的Values对象为null那么就返回初始值, 初始值由ThreadLocal#initialValue()方法来描述, 默认情况下为null(在Android 6.0的源码已经不直接返回null, 而是创建一个Values来返回). 也可以重写这个方法. 从上面这两个方法也可以看出, 他们所操作的对象都是当前线程的localValues对象的table数组. 因为不同的线程中访问同一个ThreadLocal#set() get()他们对ThreadLocal所做的读写操作仅限于各自线程的对应数据. ","date":"2016-08-22","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-10-android%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/:2:1","tags":["android","笔记"],"title":"《Android 开发艺术探索》 10-Android的消息机制","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-10-android%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"},{"categories":null,"content":"消息队列的工作原理 消息队列在android中指的是MessageQueue, MessageQueue主要包含两个操作: 插入和读取. 读取操作本身会伴随着删除的操作, 插入和读取对应的方法分别为enqueueMessage(),next(). 前者就是往消息队列中插入一条消息, 而后者就是取出一条消息并将其从消息队列中消除. 上面说过虽然MessageQueue称为消息队列, 但是内部实现使用的是单链表的数据结构来维护的消息列表. 单链表在插入和删除上比较有优势. boolean enqueueMessage(Message msg, long when) { // 省略... synchronized (this) { if (mQuitting) { IllegalStateException e = new IllegalStateException( msg.target + \" sending message to a Handler on a dead thread\"); Log.w(TAG, e.getMessage(), e); msg.recycle(); return false; } msg.markInUse(); msg.when = when; Message p = mMessages; boolean needWake; if (p == null || when == 0 || when \u003c p.when) { // New head, wake up the event queue if blocked. msg.next = p; mMessages = msg; needWake = mBlocked; } else { needWake = mBlocked \u0026\u0026 p.target == null \u0026\u0026 msg.isAsynchronous(); Message prev; for (;;) { prev = p; p = p.next; if (p == null || when \u003c p.when) { break; } if (needWake \u0026\u0026 p.isAsynchronous()) { needWake = false; } } msg.next = p; // invariant: p == prev.next prev.next = msg; } if (needWake) { nativeWake(mPtr); } } return true; } 可以看到enqueueMessage的实现主要操作就是单链表的插入操作. 继续看一下next()方法. Message next() { final long ptr = mPtr; int pendingIdleHandlerCount = -1; // -1 only during first iteration int nextPollTimeoutMillis = 0; for (;;) { if (nextPollTimeoutMillis != 0) { Binder.flushPendingCommands(); } nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) { // Try to retrieve the next message. Return if found. final long now = SystemClock.uptimeMillis(); Message prevMsg = null; Message msg = mMessages; if (msg != null \u0026\u0026 msg.target == null) { do { prevMsg = msg; msg = msg.next; } while (msg != null \u0026\u0026 !msg.isAsynchronous()); } if (msg != null) { if (now \u003c msg.when) { // Next message is not ready. Set a timeout to wake up when it is ready. nextPollTimeoutMillis = (int) Math.min(msg.when - now, Integer.MAX_VALUE); } else { // Got a message. mBlocked = false; if (prevMsg != null) { prevMsg.next = msg.next; } else { mMessages = msg.next; } msg.next = null; if (DEBUG) Log.v(TAG, \"Returning message: \" + msg); msg.markInUse(); return msg; } } else { // No more messages. nextPollTimeoutMillis = -1; } // Process the quit message now that all pending messages have been handled. if (mQuitting) { dispose(); return null; } if (pendingIdleHandlerCount \u003c 0 \u0026\u0026 (mMessages == null || now \u003c mMessages.when)) { pendingIdleHandlerCount = mIdleHandlers.size(); } if (pendingIdleHandlerCount \u003c= 0) { // No idle handlers to run. Loop and wait some more. mBlocked = true; continue; } if (mPendingIdleHandlers == null) { mPendingIdleHandlers = new IdleHandler[Math.max(pendingIdleHandlerCount, 4)]; } mPendingIdleHandlers = mIdleHandlers.toArray(mPendingIdleHandlers); } // Run the idle handlers. // We only ever reach this code block during the first iteration. for (int i = 0; i \u003c pendingIdleHandlerCount; i++) { final IdleHandler idler = mPendingIdleHandlers[i]; mPendingIdleHandlers[i] = null; // release the reference to the handler boolean keep = false; try { keep = idler.queueIdle(); } catch (Throwable t) { Log.wtf(TAG, \"IdleHandler threw exception\", t); } if (!keep) { synchronized (this) { mIdleHandlers.remove(idler); } } } // Reset the idle handler count to 0 so we do not run them again. pendingIdleHandlerCount = 0; // While calling an idle handler, a new message could have been delivered // so go back and look again for a pending message without waiting. nextPollTimeoutMillis = 0; } } next()是一个无限循环的方法, 如果消息队列中没有消息, 那么next方法会一直阻塞在这里. 当有新消息到来时, next方法会返回这条消息并将其从单链表中移除. ","date":"2016-08-22","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-10-android%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/:2:2","tags":["android","笔记"],"title":"《Android 开发艺术探索》 10-Android的消息机制","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-10-android%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"},{"categories":null,"content":"Looper的工作原理 Looper在Android的消息机制中扮演者消息循环的角色, 具体来说就是他会不停地从MessageQueue中查看是否有新消息. 如果有新消息就会处理. 否则就一直阻塞在那里. 先从构造方法开始, 在构造方法中他会创建一个MessageQueue即消息队列, 然后将当前线程的对象保存起来. private Looper(boolean quitAllowed) { mQueue = new MessageQueue(quitAllowed); mThread = Thread.currentThread(); } 构造函数是私有权限, 而内部使用的地方就是Looper#prepare()方法. private static void prepare(boolean quitAllowed) { if (sThreadLocal.get() != null) { throw new RuntimeException(\"Only one Looper may be created per thread\"); } sThreadLocal.set(new Looper(quitAllowed)); } 这也就是为什么在使用Handler之前要有Looper的节奏, 而当调用了Looper.prepare(). 就不会出现异常的原因. Looper除了prepare()方法外, 还提供了prepareMainLooper()方法, 这个方法主要是给主线程也就是ActivityThread创建Looper使用的. 本质也是通过prepare()来实现的. 由于主线程的Looper比较特殊, 所以Looper提供了一个getMainLooper()方法, 通过它可以在任何地方获取到主线程的Looper. Looper的退出: quit(): 这个方法会直接退出Looper quitSafely(): 设定一个退出标记, 然后把消息队列中的已有消息处理完毕后才安全的退出. 如果Looper退出, 通过Handler发送的消息会失败, 这个时候Handler发送的消息会失败, 而Handler#send()方法这个时候回返回false. 在子线程中, 如果手动为其创建了Looper, 那么在所有的事情完成以后应该调用quit()方法来终止消息循环. 否则这个线程会一直处于等待的状态, 而如果退出了Looper以后, 这个线程就会立刻终止. Looper最重要的一个方法loop()方法, 只有调用了loop后, 消息循环系统才会真正的起作用,如下 public static void loop() { final Looper me = myLooper(); if (me == null) { throw new RuntimeException(\"No Looper; Looper.prepare() wasn't called on this thread.\"); } final MessageQueue queue = me.mQueue; // Make sure the identity of this thread is that of the local process, // and keep track of what that identity token actually is. Binder.clearCallingIdentity(); final long ident = Binder.clearCallingIdentity(); for (;;) { Message msg = queue.next(); // might block if (msg == null) { // No message indicates that the message queue is quitting. return; } // This must be in a local variable, in case a UI event sets the logger Printer logging = me.mLogging; if (logging != null) { logging.println(\"\u003e\u003e\u003e\u003e\u003e Dispatching to \" + msg.target + \" \" + msg.callback + \": \" + msg.what); } msg.target.dispatchMessage(msg); if (logging != null) { logging.println(\"\u003c\u003c\u003c\u003c\u003c Finished to \" + msg.target + \" \" + msg.callback); } // Make sure that during the course of dispatching the // identity of the thread wasn't corrupted. final long newIdent = Binder.clearCallingIdentity(); if (ident != newIdent) { Log.wtf(TAG, \"Thread identity changed from 0x\" + Long.toHexString(ident) + \" to 0x\" + Long.toHexString(newIdent) + \" while dispatching to \" + msg.target.getClass().getName() + \" \" + msg.callback + \" what=\" + msg.what); } msg.recycleUnchecked(); } } 首先这个loop()方法是一个死循环, 唯一跳出循环的方式就是MessageQueue#next()方法返回null. 当Looper#quit()被调用时, Looper就会调用MessageQueue#quit()或者quitSafely()方法来通知消息队列退出, 当消息队列被标识为退出状态时, 它的next()方法就会返回null. 也就是说Looper必须退出, 否则loop方法就会无限循环下去. loop()会调用MessageQueue#next()方法来获取新消息. 而next是一个阻塞操作, 当没有消息时, next方法就会一直阻塞在那里. 这也导致loop()会一直阻塞在那里. 如果MessageQueue#next()返回了新消息, Looper就会处理这条消息: msg.target.dispatchMessage(msg), 这里的msg.target是发送这条消息的Handler对象, 这样Handler发送的消息最终又交给它的dispatcherMessage()来处理. 但是这里不同的是, Handler#dispatcherMessage()方法是在创建Handler时所使用的Looper中执行的. 这样就成功的将代码逻辑切换到指定的线程中去执行了. ","date":"2016-08-22","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-10-android%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/:2:3","tags":["android","笔记"],"title":"《Android 开发艺术探索》 10-Android的消息机制","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-10-android%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"},{"categories":null,"content":"Handler的工作原理 Handler主要包含消息的发送和接收过程. 消息的发送可以通过post的一系列方法以及send的一系列方法来实现. post的一系列方法最终就是还是通过send方法来实现的. public boolean sendMessageAtTime(Message msg, long uptimeMillis) { MessageQueue queue = mQueue; if (queue == null) { RuntimeException e = new RuntimeException( this + \" sendMessageAtTime() called with no mQueue\"); Log.w(\"Looper\", e.getMessage(), e); return false; } return enqueueMessage(queue, msg, uptimeMillis); } 上面这段代码是Handler#send()系列的最终调用. 可以看出, Handler发送消息的过程仅仅是向消息队列中插入了一条消息, MessageQueue#next()方法就是返回这条消息给Looper, Looper收到消息后就开始处理. 最终消息有Looper交由Handler处理, 即Handler#dispatchMessage()方法会被调用, 这个时候Handler就会进入了处理消息的阶段. public void dispatchMessage(Message msg) { if (msg.callback != null) { handleCallback(msg); } else { if (mCallback != null) { if (mCallback.handleMessage(msg)) { return; } } handleMessage(msg); } } 整理一下: 先检查msg.callback属性是否为null, 不为null就通过handleCallback()来处理消息. msg.callback是一个Runnable接口, 实际上就是post()中传递的Runnable参数. handleCallback()实现如下: private static void handleCallback(Message message) { message.callback.run(); } 其次检查mCallback是否为null, 不为null就调用mCallback.handleMessage(msg)方法来处理消息. Callback是一个接口, 定义如下: public interface Callback { public boolean handleMessage(Message msg); } 通过Callback可以采用如下方式来创建Handler对象: Handler handler = new Handler(callback). 通过源码注释了解: 这个接口可以用来创建一个Handler的实例但并不需要派生Handler的子类并重写其handleMessage方法来处理具体的消息, 而CallBack给我们提供了另外一种方式使用Handler. 当我们不想派生子类时, 就可以通过Callback来实现. 最后, 调用Handler#handleMessage()方法来处理消息. Handler还有一个特殊的构造方法, 那就是通过一个特定的Looper来构造Handler, 最常用的就是直接new 出一个Handler, 这个构造方法会调用下面的构造函数. 很明显这就是为什么当前线程没有Looper的话, 就会抛出Can't create handler inside thread that has not called Looper.prepare()这个异常. public Handler(Callback callback, boolean async) { //.... mLooper = Looper.myLooper(); if (mLooper == null) { throw new RuntimeException( \"Can't create handler inside thread that has not called Looper.prepare()\"); } mQueue = mLooper.mQueue; mCallback = callback; mAsynchronous = async; } ","date":"2016-08-22","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-10-android%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/:2:4","tags":["android","笔记"],"title":"《Android 开发艺术探索》 10-Android的消息机制","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-10-android%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"},{"categories":null,"content":"主线程的消息循环 Android的主线程就是ActivityThread, 主程序的入口方法为main(), 在main()中系统通过Looper.prepareMainLooper()来创建主线程的Looper以及MessageQueue, 并通过Looper.loop()来开启主线程的消息循环. 当主线程的消息循环开始以后, ActivityThread还需要一个Handler来和消息队列进行交互, 这个Handler就是ActivityThread.H, 它的内部定义了一组消息类型, 主要包含了四大组件的启动和停止等过程. private class H extends Handler { public static final int LAUNCH_ACTIVITY = 100; public static final int PAUSE_ACTIVITY = 101; public static final int PAUSE_ACTIVITY_FINISHING= 102; public static final int STOP_ACTIVITY_SHOW = 103; public static final int STOP_ACTIVITY_HIDE = 104; public static final int SHOW_WINDOW = 105; public static final int HIDE_WINDOW = 106; public static final int RESUME_ACTIVITY = 107; public static final int SEND_RESULT = 108; public static final int DESTROY_ACTIVITY = 109; public static final int BIND_APPLICATION = 110; public static final int EXIT_APPLICATION = 111; public static final int NEW_INTENT = 112; public static final int RECEIVER = 113; public static final int CREATE_SERVICE = 114; public static final int SERVICE_ARGS = 115; public static final int STOP_SERVICE = 116; public static final int CONFIGURATION_CHANGED = 118; public static final int CLEAN_UP_CONTEXT = 119; public static final int GC_WHEN_IDLE = 120; public static final int BIND_SERVICE = 121; public static final int UNBIND_SERVICE = 122; } ActivityThread通过ApplicationThread和AMS进行进程间通信, AMS以进程间通信的方式完成ActivityThread的请求后回调ApplicationThread中的Binder()方法, 然后Application会向H发送消息, H收到消息后会将ApplicationThread中的逻辑切换到ActivityThread中去执行, 即切换到主线程去执行, 这个过程就是主线程的消息循环模型. 第11章 Android的线程和线程池 ","date":"2016-08-22","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-10-android%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/:3:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 10-Android的消息机制","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-10-android%E7%9A%84%E6%B6%88%E6%81%AF%E6%9C%BA%E5%88%B6/"},{"categories":null,"content":" 第九章: 还原四大组件的本质 blog相关代码 ","date":"2016-08-16","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-09-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/:0:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 09-四大组件的工作过程","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-09-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/"},{"categories":null,"content":"四大组件的运行状态 四大组件中除了BroadcastReceiver以外, 其余的三种组件都必须在AndroidManifest中注册, 对于BroadcastReceiver来说, 既可以在清单文件中注册, 也可以通过代码来注册. 在调用形式上除了ContentProvider不需要借助Intent. 其余的三大组件都需要Intent Activity是一种展示型组件, 用于向用户直接地展示一个界面, 并且可以接收用户的输入信息从而进行交互. Activity是最重要的一种组件, 对于用户来说它就是应用的全部, 因为其他三大组件对用户来说是无法感知的. Activity的启动由Intent触发, 其中Intent可以分为显式和隐式. 显式Intent可以明确的指向一个Activity, 而隐式Intent则指向一个或者多个Activity组件. 或者是没有Activity组件可以处理这个隐式的Intent. 一个Activity具有特定的启动模式. 也可以通过finish来停止. 总结来说, Activity组件的主要作用是展示一个界面并和用户交互, 它扮演的是一种前台界面的角色. Service是一种计算型组件, 用于后台执行一系列计算任务. 运行在后台,用户是无法感知的. Service和Activity的不同: Activity组件只有一种运行模式,即Activity处于启动状态, 但是Service组件有两种状态: 启动状态和绑定状态. 当Service处于启动状态时, 这个时候Service内部可以做一些后台计算. 尽管Service组件是用于执行后台计算的, 但是它本身是运行在主线程的. 因此单独的耗时操作仍然需要单独的线程去执行. 当Service处于绑定状态时, 内部同样可以进行后台计算, 但是处于这种状态时, 外界可以很方便的和Service组件进行通信. Service可以停止, 需要灵活采用stopService和unBindService BroadcastReceiver是一种消息型组件, 用于在不同的组件乃至不同的应用之间传递消息. 同样无法被用户感知, 因为是运行在系统内部, 广播的注册方式有两种:静态注册和动态注册 静态注册: 在清单文件中进行注册广播, 这种广播在应用安装时会被系统解析, 此种形式的广播不需要应用启动就可以接收到相应的广播. 动态注册: 需要通过Context.registerReceiver()来实现, 并在不需要的时候通过Context.unRegisterReceiver()来解除广播. 此种形态的广播要应用启动才能注册和接收广播. 在实际开发中通过Context的一系列的send方法来发送广播, 被发送的广播会被系统发送给感兴趣的广播接收者, 发送和接收的过程的匹配是通过广播接收者的\u003cintent-filter\u003e来描述的. 可以实现低耦合的观察者模式, 观察者和被观察者之间可以没有任何耦合. 但广播不适合来做耗时操作. ContentProvider是一种数据共享组件, 用于向其他组件乃至其他应用共享数据. 无法被用户感知. 对于内容提供者来说, 它只需要实现增删改查四种基本操作, 在它内部维持着一份数据集合, 这个数据集合既可以通过数据库来实现, 也可以采用其他任何类型来实现, 例如list或者map. ContentProvider对数据集合的具体实现并没有任何要求. 要注意处理好内部的insert, delete, update, query方法的线程同步, 因为这几个方法是在Binder线程池被调用. ","date":"2016-08-16","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-09-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/:1:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 09-四大组件的工作过程","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-09-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/"},{"categories":null,"content":"Activity的工作过程 虽然要打开一个Activity很简单, 但是不应该只是局限于表面. 了解其内部走向构成.所以一切从startActivity(intent)这个方法开始. startActivity()有好几种重载方式但是最终都是调用startActivityForResult()方法. 注意这里分析的是5.0版本的源码, 和6.0源码实现稍微不同 首先看startActivityForResult() public void startActivityForResult(Intent intent, int requestCode, @Nullable Bundle options) { if (mParent == null) { Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity( this, mMainThread.getApplicationThread(), mToken, this, intent, requestCode, options); if (ar != null) { mMainThread.sendActivityResult( mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData()); } if (requestCode \u003e= 0) { mStartedActivity = true; } final View decor = mWindow != null ? mWindow.peekDecorView() : null; if (decor != null) { decor.cancelPendingInputEvents(); } // TODO Consider clearing/flushing other event sources and events for child windows. } else { if (options != null) { mParent.startActivityFromChild(this, intent, requestCode, options); } else { // Note we want to go through this method for compatibility with // existing applications that may have overridden it. mParent.startActivityFromChild(this, intent, requestCode); } } if (options != null \u0026\u0026 !isTopOfTask()) { mActivityTransitionState.startExitOutTransition(this, options); } } 关注mParent==null的分支. mParent代表的是ViewGroup, ActivityGroup最开始被用来在一个界面中嵌入多个子Activity, 在API13已经被废弃. 系统推荐使用Fragment代替ActivityGroup. 注意mMainThread.getApplicationThread()这个参数, 它的参数类型是ApplicationThread, ApplicationThread是ActivityThread的一个内部类. 看一下Instrumentation#execStartActivity()这个方法 public ActivityResult execStartActivity( Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, int requestCode, Bundle options) { IApplicationThread whoThread = (IApplicationThread) contextThread; if (mActivityMonitors != null) { synchronized (mSync) { final int N = mActivityMonitors.size(); for (int i=0; i\u003cN; i++) { final ActivityMonitor am = mActivityMonitors.get(i); if (am.match(who, null, intent)) { am.mHits++; if (am.isBlocking()) { return requestCode \u003e= 0 ? am.getResult() : null; } break; } } } } try { intent.migrateExtraStreamToClipData(); intent.prepareToLeaveProcess(); // 启动Activity的真正实现 int result = ActivityManagerNative.getDefault() .startActivity(whoThread, who.getBasePackageName(), intent, intent.resolveTypeIfNeeded(who.getContentResolver()), token, target != null ? target.mEmbeddedID : null, requestCode, 0, null, options); checkStartActivityResult(result, intent); } catch (RemoteException e) { } return null; } 代码中真正启动Activity的真正实现是由ActivityManagerNative.getDefault().startActivity()方法完成的. 后面对ActivityManagerService简称AMS. AMS继承自ActivityManagerNative(), 而ActivityManagerNative()继承自Binder并实现了IActivityManager这个Binder接口, 因此AMS也是一个Binder, 它是IActivityManager的具体实现. 由于ActivityManagerNative.getDefault()本质是一个IActivityManager类型的Binder对象, 因此具体实现是AMS. 在ActivityManagerNative中, AMS这个Binder对象采用单例模式对外提供, Singleton是一个单例封装类. 第一次调用它的get()方法时会通过create方法来初始化AMS这个Binder对象, 在后续调用中会返回这个对象. 具体实现如下代码. static public IActivityManager getDefault() { return gDefault.get(); } private static final Singleton\u003cIActivityManager\u003e gDefault = new Singleton\u003cIActivityManager\u003e() { protected IActivityManager create() { IBinder b = ServiceManager.getService(\"activity\"); if (false) { Log.v(\"ActivityManager\", \"default service binder = \" + b); } IActivityManager am = asInterface(b); if (false) { Log.v(\"ActivityManager\", \"default service = \" + am); } return am; } }; 由上可以看到关于Activity的启动是由ActivityManagerNative.getDefault()来启动的, 而ActivityManagerNative.getDefault()实际上是AMS, 所以Activity的启动过程又被转移到了AMS中, 接下来查看AMS中的startActivity()方法. 在分析AMS#startActivity()之前, 是否在开始时候碰到过Activity没有在清单文件中声明然后崩溃的现象? 这个步骤是在Instrumentation#execStartActivity()刚才分析ActivityManagerNative.getDefault().startActivity()的下一步. 有一个checkStartActivityResult(),看名字应该是检查的类, 看一下实现. public static void checkStartActivityResult(int res, Object intent) { if (res \u003e= ActivityManager.START_SUCCESS) { return; } switch (res) { case ActivityManager.START_INTENT_NOT_RESOLVE","date":"2016-08-16","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-09-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/:2:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 09-四大组件的工作过程","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-09-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/"},{"categories":null,"content":"Service的工作流程 ","date":"2016-08-16","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-09-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/:3:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 09-四大组件的工作过程","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-09-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/"},{"categories":null,"content":"Service的启动过程 同样从ContextImpl#startService()这个方法作为入口. 这个方法会调用startServiceCommon()并返回. 这个方法内部通过 ActivityManagerNative.getDefault()获得一个AMS并调用startService()开启一个服务. 在这里通过AMS来启动一个服务的行为是属于远程调用的过程. 看一下startService() public ComponentName startService(IApplicationThread caller, Intent service, String resolvedType, int userId) { enforceNotIsolatedCaller(\"startService\"); // Refuse possible leaked file descriptors if (service != null \u0026\u0026 service.hasFileDescriptors() == true) { throw new IllegalArgumentException(\"File descriptors passed in Intent\"); } if (DEBUG_SERVICE) Slog.v(TAG, \"startService: \" + service + \" type=\" + resolvedType); synchronized(this) { final int callingPid = Binder.getCallingPid(); final int callingUid = Binder.getCallingUid(); final long origId = Binder.clearCallingIdentity(); ComponentName res = mServices.startServiceLocked(caller, service, resolvedType, callingPid, callingUid, userId); Binder.restoreCallingIdentity(origId); return res; } } 这段主要就是AMS通过mServices这个对象来完成Service后续的启动过程. 这里mService的对象类型是ActivityServices(这是一个辅助AMS进行Service管理的类, 包括Service的启动,绑定和停止等). 这里调用了mServices.startServiceLocked()然后这个方法最后又调用了startServiceInnerLocked(), 实现如下. ComponentName startServiceInnerLocked(ServiceMap smap, Intent service, ServiceRecord r, boolean callerFg, boolean addToStarting) { ProcessStats.ServiceState stracker = r.getTracker(); if (stracker != null) { stracker.setStarted(true, mAm.mProcessStats.getMemFactorLocked(), r.lastActivity); } r.callStart = false; synchronized (r.stats.getBatteryStats()) { r.stats.startRunningLocked(); } String error = bringUpServiceLocked(r, service.getFlags(), callerFg, false); if (error != null) { return new ComponentName(\"!!\", error); } if (r.startRequested \u0026\u0026 addToStarting) { boolean first = smap.mStartingBackground.size() == 0; smap.mStartingBackground.add(r); r.startingBgTimeout = SystemClock.uptimeMillis() + BG_START_TIMEOUT; if (DEBUG_DELAYED_SERVICE) { RuntimeException here = new RuntimeException(\"here\"); here.fillInStackTrace(); Slog.v(TAG, \"Starting background (first=\" + first + \"): \" + r, here); } else if (DEBUG_DELAYED_STARTS) { Slog.v(TAG, \"Starting background (first=\" + first + \"): \" + r); } if (first) { smap.rescheduleDelayedStarts(); } } else if (callerFg) { smap.ensureNotStartingBackground(r); } return r.name; } ServiceRecord描述的是一个Service记录, ServiceRecord一直贯穿着整个Service的启动过程. startServiceInnerLocked()方法并没有完成具体的启动工作, 而是把后续的工作交给了bringUpServiceLocked(),在bringUpServiceLocked()又调用了realStartServiceLocked()方法. 这个方法算是真正的启动一个Service. **realStartServiceLocked()**首先通过app.thread.scheduleCreateService()方法来创建Service对象并调用其onCreate(), 接着再通过sendServiceArgsLoceked()方法来调用Service的其他方法, 比如onStartCommond这两个过程均是进程间通信. app.thread是一个Binder对象. 具体实现看ApplicationThread即可. 在Activity启动流程的时候已经解释过了. 所以只查看Application对Service的启动过程的处理即可. 这对应着它的scheduleCreateService(). public final void scheduleCreateService(IBinder token, ServiceInfo info, CompatibilityInfo compatInfo, int processState) { updateProcessState(processState, false); CreateServiceData s = new CreateServiceData(); s.token = token; s.info = info; s.compatInfo = compatInfo; sendMessage(H.CREATE_SERVICE, s); } 这个过程和Activity类似, 都是通过H来完成. 最终处理消息接收结果会调用handleCreateService. private void handleCreateService(CreateServiceData data) { unscheduleGcIdler(); LoadedApk packageInfo = getPackageInfoNoCheck( data.info.applicationInfo, data.compatInfo); Service service = null; try { java.lang.ClassLoader cl = packageInfo.getClassLoader(); service = (Service) cl.loadClass(data.info.name).newInstance(); } catch (Exception e) { if (!mInstrumentation.onException(service, e)) { throw new RuntimeException( \"Unable to instantiate service \" + data.info.name + \": \" + e.toString(), e); } } try { if (localLOGV) Slog.v(TAG, \"Creating service \" + data.info.name); ContextImpl context = ContextImpl.createAppContext(this, packageInfo); context.setOuterContext(service); Application app = packageInfo.makeApplication(false, mInstrumentation); //---------------- service.attach(context, this, data.i","date":"2016-08-16","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-09-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/:3:1","tags":["android","笔记"],"title":"《Android 开发艺术探索》 09-四大组件的工作过程","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-09-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/"},{"categories":null,"content":"Service的绑定过程 和启动过程一样, 绑定过程同样是从ContextImpl开始的. 先查看bindServiceCommon(). private boolean bindServiceCommon(Intent service, ServiceConnection conn, int flags, UserHandle user) { IServiceConnection sd; if (conn == null) { throw new IllegalArgumentException(\"connection is null\"); } if (mPackageInfo != null) { sd = mPackageInfo.getServiceDispatcher(conn, getOuterContext(), mMainThread.getHandler(), flags); } else { throw new RuntimeException(\"Not supported in system context\"); } validateServiceIntent(service); try { IBinder token = getActivityToken(); if (token == null \u0026\u0026 (flags\u0026BIND_AUTO_CREATE) == 0 \u0026\u0026 mPackageInfo != null \u0026\u0026 mPackageInfo.getApplicationInfo().targetSdkVersion \u003c android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) { flags |= BIND_WAIVE_PRIORITY; } service.prepareToLeaveProcess(); int res = ActivityManagerNative.getDefault().bindService( mMainThread.getApplicationThread(), getActivityToken(), service, service.resolveTypeIfNeeded(getContentResolver()), sd, flags, user.getIdentifier()); if (res \u003c 0) { throw new SecurityException( \"Not allowed to bind to service \" + service); } return res != 0; } catch (RemoteException e) { return false; } } 这段代码首先将客户端的ServiceConnection对象转化成为ServiceDispatcher.InnerConnection对象. 不能直接使用ServiceConnection对象必须借助于Binder才能让远程服务回调自己的方法. 而ServiceDispatcher的内部类InnerConnection刚好充当了Binder这个角色. ServiceDispatcher的作用就是连接ServiceConnection和InnerConnection的作用. 这个过程由LoadedApk的getServiceDispatcher()方法完成. 实现如下: public final IServiceConnection getServiceDispatcher(ServiceConnection c, Context context, Handler handler, int flags) { synchronized (mServices) { LoadedApk.ServiceDispatcher sd = null; ArrayMap\u003cServiceConnection, LoadedApk.ServiceDispatcher\u003e map = mServices.get(context); if (map != null) { sd = map.get(c); } if (sd == null) { sd = new ServiceDispatcher(c, context, handler, flags); if (map == null) { map = new ArrayMap\u003cServiceConnection, LoadedApk.ServiceDispatcher\u003e(); mServices.put(context, map); } map.put(c, sd); } else { sd.validate(context, handler); } return sd.getIServiceConnection(); } } mService是一个ArrayMap, 它存储了一个应用当前活动的ServiceConnection和ServiceDispatcher的映射关系. 系统首先会查找是否存在相同的ServiceConnection, 如果不存在就会重新创建一个ServiceDispatch对象并将其存储在mService中, 其中的key是ServiceConnection,value是ServiceDispatcher, 在ServiceDispatcher的内部又保存了ServiceConnection和InnerConnection对象. 当Service和客户端建立连接后, 系统会通过InnerConnection来调用ServiceConnection中的onServiceConnected()方法. 这个过程可能是跨进程的. 当ServiceDispatcher创建好了以后, getServiceDispatcher会返回其保存的InnerConnection对象. 接着bindServiceCommon方法会通过AMS完成Service的具体绑定, 这对应着AMS#bindService()方法. public int bindService(IApplicationThread caller, IBinder token, Intent service, String resolvedType, IServiceConnection connection, int flags, int userId) { enforceNotIsolatedCaller(\"bindService\"); // Refuse possible leaked file descriptors if (service != null \u0026\u0026 service.hasFileDescriptors() == true) { throw new IllegalArgumentException(\"File descriptors passed in Intent\"); } synchronized(this) { return mServices.bindServiceLocked(caller, token, service, resolvedType, connection, flags, userId); } } 然后AMS会调用ActivityService#bindServiceLocked()方法. 然后调用bringUpServiceLocked(), 继续调用. 发现调到了realStartServiceLocked. 这里面的逻辑和启动过程类似. 最终都是通过ApplicationThread来完成Service实例的创建并执行其onCreate()方法. 这里不再重复说明. 与Service启动稍微不同的是: 绑定过程: 会调用到app.thread(ActivityThread)的scheduleBindService()方法. 而这个过程的实现是在ActiveService#requestServiceBindingLocked()方法. private final boolean requestServiceBindingLocked(ServiceRecord r, IntentBindRecord i, boolean execInFg, boolean rebind) { if (r.app == null || r.app.thread == null) { // If service is not currently running, can't yet bind. return false; } if ((!i.requested || rebind) \u0026\u0026 i.apps.size() \u003e 0) { try { bumpServiceExecutingLocked(r, execInFg, \"bind\"); r.app.forceProcessStateUpTo(ActivityManager.PROCESS_STATE_SERVICE); r.app.thread.scheduleBindService(r, i.intent.getIntent(), rebind, r.app.repProcState); if (!rebind) { i.requested = true; } i.hasBound = true; i.doRebind = false; } catch (RemoteException ","date":"2016-08-16","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-09-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/:3:2","tags":["android","笔记"],"title":"《Android 开发艺术探索》 09-四大组件的工作过程","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-09-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/"},{"categories":null,"content":"BroadcastReceiver的工作流程 简单回顾一下广播的使用方法, 首先定义广播接收者, 只需要继承BroadcastReceiver并重写onReceive()方法即可. 定义好了广播接收者, 还需要注册广播接收者, 分为两种静态注册或者动态注册. 注册完成之后就可以发送广播了. ","date":"2016-08-16","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-09-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/:4:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 09-四大组件的工作过程","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-09-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/"},{"categories":null,"content":"广播的注册过程 广播的注册有两种静态注册, 动态注册. 其中静态注册的广播在应用安装时由系统自动完成注册, 具体来说是有PMS(PackageManagerService)来完成整个注册过程的. 除了广播外, 其他三大组件也都是在应用安装时由PMS解析并注册的. 动态注册的过程是从ContextWrapper#registerReceiver()开始的. 和Activity或者Service一样. ContextWrapper并没有做实际的工作, 而是将注册的过程直接交给了ContextImpl来完成. ContextImpl#registerReceiver()方法调用了本类的registerReceiverInternal()方法. private Intent registerReceiverInternal(BroadcastReceiver receiver, int userId, IntentFilter filter, String broadcastPermission, Handler scheduler, Context context) { IIntentReceiver rd = null; if (receiver != null) { if (mPackageInfo != null \u0026\u0026 context != null) { if (scheduler == null) { scheduler = mMainThread.getHandler(); } rd = mPackageInfo.getReceiverDispatcher( receiver, context, scheduler, mMainThread.getInstrumentation(), true); } else { if (scheduler == null) { scheduler = mMainThread.getHandler(); } rd = new LoadedApk.ReceiverDispatcher( receiver, context, scheduler, null, true).getIIntentReceiver(); } } try { return ActivityManagerNative.getDefault().registerReceiver( mMainThread.getApplicationThread(), mBasePackageName, rd, filter, broadcastPermission, userId); } catch (RemoteException e) { return null; } } 上述代码中, 系统首先从mPackageInfo获取到IIntentReceiver对象, 然后再采用跨进程的方式向AMS发送广播注册的请求. 之所以采用IIntentReceiver而不是直接采用BroadcastReceiver, 这是因为上述注册过程中是一个进程间通信的过程. 而BroadcastReceiver作为Android中的一个组件是不能直接跨进程传递的. 所有需要通过IIntentReceiver来中转一下. IIntentReceiver作为一个Binder接口, 它的具体实现是LoadedApk.ReceiverDispatcher.InnerReceiver, ReceiverDispatcher的内部同时保存了BroadcastReceiver和InnerReceiver, 这样当接收到广播的时候, ReceiverDispatcher可以很方便的调用BroadcastReceiver#onReceive()方法. 这里和Service很像有同样的类, 并且内部类中同样也是一个Binder接口. 看一下LoadedApk.ReceiverDispatcher#getIIntentReceiver()的实现, 很显然getReceiverDispatcher()重新创建了一个ReceiverDispatcher对象并将其保存的InnerReceiver对象作为返回值返回, 其中InnerReceiver对象和BroadcastReceiver都是在ReceiverDispatcher的构造方法中被保存起来的. public IIntentReceiver getReceiverDispatcher(BroadcastReceiver r, Context context, Handler handler, Instrumentation instrumentation, boolean registered) { synchronized (mReceivers) { LoadedApk.ReceiverDispatcher rd = null; ArrayMap\u003cBroadcastReceiver, LoadedApk.ReceiverDispatcher\u003e map = null; if (registered) { map = mReceivers.get(context); if (map != null) { rd = map.get(r); } } if (rd == null) { rd = new ReceiverDispatcher(r, context, handler, instrumentation, registered); if (registered) { if (map == null) { map = new ArrayMap\u003cBroadcastReceiver, LoadedApk.ReceiverDispatcher\u003e(); mReceivers.put(context, map); } map.put(r, rd); } } else { rd.validate(context, handler); } rd.mForgotten = false; return rd.getIIntentReceiver(); } } 由于注册广播真正实现过程是在AMS中, 因此跟进AMS中, 首先看registerReceiver()方法, 这里只关心里面的核心部分. 这段代码最终会把远程的InnerReceiver对象以及IntentFilter对象存储起来, 这样整个广播的注册就完成了. public Intent registerReceiver(IApplicationThread caller, String callerPackage, IIntentReceiver receiver, IntentFilter filter, String permission, int userId) { //... mRegisteredReceivers.put(receiver.asBinder(), rl); BroadcastFilter bf = new BroadcastFilter(filter, rl, callerPackage,permission, callingUid, userId); rl.add(bf); mReceiverResolver.addFilter(bf); } ","date":"2016-08-16","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-09-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/:4:1","tags":["android","笔记"],"title":"《Android 开发艺术探索》 09-四大组件的工作过程","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-09-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/"},{"categories":null,"content":"广播的发送和接收过程 当通过send()发送广播时, AMS会查找出匹配的广播接收者并将广播发送给他们处理. 广播的发送种类有: 普通广播, 有序广播, 粘性广播. 这里分析普通广播. 广播的发送和接收, 本质就是一个过程的两个阶段. 广播的发送仍然开始于ContextImpl#sendBroadcase()方法, 之所以不是Context, 那是因为Context#sendBroad()是一个抽象方法. 和广播的注册过程一样, ContextWrapper#sendBroadcast()仍然什么都不做, 只是把事情交给了ContextImpl去处理, ContextImpl#sendBroadcast()源码如下 @Override public void sendBroadcast(Intent intent) { warnIfCallingFromSystemProcess(); String resolvedType = intent.resolveTypeIfNeeded(getContentResolver()); intent.prepareToLeaveProcess(); ActivityManagerNative.getDefault().broadcastIntent( mMainThread.getApplicationThread(), intent, resolvedType, null, Activity.RESULT_OK, null, null, null, AppOpsManager.OP_NONE, null, false, false, getUserId()); } 看到ContextImpl里面也几乎什么都没有做, 内部直接向AMS发起了一个异步请求用于发送广播. 接下来看AMS#broadcastIntent()方法. public final int broadcastIntent(IApplicationThread caller, Intent intent, String resolvedType, IIntentReceiver resultTo, int resultCode, String resultData, Bundle resultExtras, String[] requiredPermissions, int appOp, Bundle options, boolean serialized, boolean sticky, int userId) { enforceNotIsolatedCaller(\"broadcastIntent\"); synchronized(this) { intent = verifyBroadcastLocked(intent); final ProcessRecord callerApp = getRecordForAppLocked(caller); final int callingPid = Binder.getCallingPid(); final int callingUid = Binder.getCallingUid(); final long origId = Binder.clearCallingIdentity(); int res = broadcastIntentLocked(callerApp, callerApp != null ? callerApp.info.packageName : null, intent, resolvedType, resultTo, resultCode, resultData, resultExtras, requiredPermissions, appOp, null, serialized, sticky, callingPid, callingUid, userId); Binder.restoreCallingIdentity(origId); return res; } } 看到这里, 又继续调用broadcastIntentLocked()方法, 这个方法有点长. 在代码开始处 // By default broadcasts do not go to stopped apps. intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES); 这个表示默认情况下广播不会发送给已经停止的应用, android5.0中. 而android 3.1开始就增添了两个标记为. 分别是FLAG_INCLUDE_STOPPED_PACKAGES, FLAG_EXCLUDE_STOPPED_PACKAGES. 用来控制广播是否要对处于停止的应用起作用. FLAG_INCLUDE_STOPPED_PACKAGES: 包含停止应用, 广播会发送给已停止的应用. FLAG_EXCLUDE_STOPPED_PACKAGES: 不包含已停止应用, 广播不会发送给已停止的应用 在android 3.1开始, 系统就为所有广播默认添加了FLAG_EXCLUDE_STOPPED_PACKAGES标识, 为了防止广播无意间或者不必要的时候调起已经停止运行的应用. 当这两个标记共存的时候以FLAG_INCLUDE_STOPPED_PACKAGES(非默认项为主). 应用处于停止分为两种 应用安装后未运行 被手动或者其他应用强停 开机广播同样受到了这个标志位的影响. 从Android 3.1开始处于停止状态的应用同样无法接受到开机广播, 而在android 3.1之前处于停止的状态也是可以接收到的开机广播的. 在broadcastIntentLocked()内部, 会根据intent-filter查找出匹配的广播接收者并经过一系列的条件过滤. 最终会将满足条件的广播接收者添加到BroadcastQueue中, 接着BroadcastQueue就会将广播发送给相应广播接收者. if ((receivers != null \u0026\u0026 receivers.size() \u003e 0) || resultTo != null) { BroadcastQueue queue = broadcastQueueForIntent(intent); BroadcastRecord r = new BroadcastRecord(queue, intent, callerApp, callerPackage, callingPid, callingUid, resolvedType, requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode, resultData, resultExtras, ordered, sticky, false, userId); if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, \"Enqueueing ordered broadcast \" + r + \": prev had \" + queue.mOrderedBroadcasts.size()); if (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST, \"Enqueueing broadcast \" + r.intent.getAction()); boolean replaced = replacePending \u0026\u0026 queue.replaceOrderedBroadcastLocked(r); if (!replaced) { queue.enqueueOrderedBroadcastLocked(r); queue.scheduleBroadcastsLocked(); } } 跟进BroadcastQueue#scheduleBroadcastsLocked() public void scheduleBroadcastsLocked() { if (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, \"Schedule broadcasts [\" + mQueueName + \"]: current=\" + mBroadcastsScheduled); if (mBroadcastsScheduled) { return; } mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, this)); mBroadcastsScheduled = true; } 方法内并没有立即发送广播, 而是发送了一个BROADCAST_INTENT_MSG类型的消息, BroadcastQueue收到消息后会调用processNextBroadcast()方法. 这个方法对普通广播的处理如下: // First, deliver any non-serialized broadcasts right away. while (mParallelBroadcasts.size() \u003e 0) { r = mParallelBroadcasts.remove(0); r.dispatchTime = SystemClock.uptimeMillis(); r.dispatchClockTime = System.currentTimeMillis(); final int ","date":"2016-08-16","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-09-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/:4:2","tags":["android","笔记"],"title":"《Android 开发艺术探索》 09-四大组件的工作过程","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-09-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/"},{"categories":null,"content":"ContentProvider的工作机制 ContentProvider是一种内容共享型组件, 它通过Binder向其他组件乃至其他应用提供数据. 当ContentProvider所在的进程启动时, ContentProvider会同时启动并发布到AMS中. 要注意:这个时候ContentProvider的onCreate()方法是先于Application的onCreate()执行的这一点在四大组件是少有的现象. 当一个应用启动的时候, 入口的方法为ActivityThread#main()方法, main方法为一个静态方法, 在main方法中会创建ActivityThread的实例, 并创建主线程的消息队列, 然后在ActivityThread#attach()方法中会远程调用AMS#attachApplication()并将ApplicationThread对象提供给AMS. ApplicationThread是一个Binder对象, 它的Binder接口是IApplicationThread, 主要用于ActivityThread和AMS之间的通信, 这一点在前面多次提到. 在AMS的attachApplication()中, 会调用ApplicationThread#bindApplication(). 这个过程同样是跨进程的. bindApplication()中会经过 ActivityThread中的mh(Handler) 切换到ActivityThread中去执行, 具体的方式是handleBindApplication(). 在handleBindApplication()方法中, ActivityThread会创建Application对象并加载ContentProvider. 需要注意的是, ActivityThread会先加载ContentProvider, 然后在调用Application#onCreate()方法 以上就是ContentProvider的启动过程, ContentProvider启动后, 外界就可以通过它所提供的增删改查这四个接口来操作ContentProvider中的数据源, 这四个方法都是通过Binder来调用的, 外界无法直接访问ContentProvider, 它只能通过AMS根据URI来获取到对应的ContentProvider的Binder接口IContentProvider, 然后再通过IContentProvider来访问ContentProvider中的数据源. ContentProvider是否属于单实例? 具体ContentProvider是否是单实例取决于android:multiprocess属性来决定的, 当其值为false的时候, 就是单实例也是默认值. 如果为true那就为多实例. 这个时候在每一个调用者的进程中都会存在一个ContentProvider对象. 通过单实例的ContentProvider来分析一下启动过程 首先访问ContentProvider需要通过ContentResolver, ContentResolver是一个抽象类, 通过Content#getContentResolver()方法获取的实际上是ApplicationContentResolver对象, 而这个类继承了ContentProvider并实现了其抽象方法. 当ContentProvider所在的进程未启动时, 第一次访问它的时候就会触发ContentProvider的创建, 当然这也伴随着ContentProvider所在的进程的启动. 通过四个对数据的操作方法中的任何一个, 都可以触发ContentProvider的启动过程. 四种操作过程差不多, 那么这里以query方法为例 首先会获取IContentProvider对象, 不管是通过acquireUnstableProvider()方法还是直接通过acquireProvider()方法, 他们的本质都是一样的, 最终都是通过acquireProvider方法来获取ContentProvider. ApplicationContentResolver#acquireProvider()方法并没有处理任何逻辑, 它直接调用了ActivityThread#acquireProvider(), 这个方法如下: public final IContentProvider acquireProvider( Context c, String auth, int userId, boolean stable) { final IContentProvider provider = acquireExistingProvider(c, auth, userId, stable); if (provider != null) { return provider; } IActivityManager.ContentProviderHolder holder = null; try { holder = ActivityManagerNative.getDefault().getContentProvider( getApplicationThread(), auth, userId, stable); } catch (RemoteException ex) { } if (holder == null) { Slog.e(TAG, \"Failed to find provider info for \" + auth); return null; } // Install provider will increment the reference count for us, and break // any ties in the race. holder = installProvider(c, holder, holder.info, true /*noisy*/, holder.noReleaseNeeded, stable); return holder.provider; } 这段代码主要从ActivityThread中查找是否已经存在了ContentProvider了, 如果存在那么就直接返回. ActivityThread中通过mProviderMap来存储已经启动的ContentProvider对象, 这个集合的存储类型ArrayMap\u003cProviderKey, ProviderClientRecord\u003e mProviderMap. 如果目前ContentProvider没有启动, 那么就发送一个进程间请求给AMS让其启动项目目标ContentProvider, 最后再通过installProvider()方法来修改引用计数. 那么AMS是如何启动ContentProvider的呢? 关于ContentProvider被启动的时候会伴随着进程的启动, 在AMS中, 首先会启动ContentProvider所在的进程, 然后再启动ContentProvider. 启动进程是由AMS#startProcessLocked()方法来完成, 其内部主要是通过Process#start()方法来完成一个新进程的启动, 新进程启动后其入口方法为ActivityThread#main()方法. 如下: public static void main(String[] args) { Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, \"ActivityThreadMain\"); SamplingProfilerIntegration.start(); // CloseGuard defaults to true and can be quite spammy. We // disable it here, but selectively enable it later (via // StrictMode) on debug builds, but using DropBox, not logs. CloseGuard.setEnabled(false); Environment.initForCurrentUser(); // Set the reporter for event logging in libcore EventLogger.setReporter(new EventLoggingReporter()); AndroidKeyStoreProvider.install(); // Make sure TrustedCertificateStore looks in the right place for CA certificates final File configDir = Environment.getUserConfigDirectory(UserHandle.myUserId()); TrustedCertificateStore.setDefaultUserDirectory(configDir); Process.setArgV0(\"\u003cpre-initialized\u003e\"); Looper.prepareMainLooper(); ActivityThread thread = new ActivityThread(); thread.attach(false);","date":"2016-08-16","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-09-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/:5:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 09-四大组件的工作过程","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-09-%E5%9B%9B%E5%A4%A7%E7%BB%84%E4%BB%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B/"},{"categories":null,"content":" 第八章: 所有的视图都是Windown呈现的, 那它都干了什么? blog相关代码保存在第7章项目window包中 Window表示一个窗口的概念, 如有需要在桌面上显示一个类似悬浮窗的东西, 那么这种效果就需要Window来实现. Window是一个抽象类, 具体实现是PhoneWindow. 如果想要创建一个Window只需要通过WindowManager即可完成. WindowManager是外界访问Window的入口, Window具体实现位于WindowManagerService中, WM和WMS的交互是一个IPC过程. Android中所有的视图都是通过Window来呈现的, 不管是Activity, Dialog, Toast他们的视图实际上都是附加在Window上的. ","date":"2016-08-15","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-08-%E7%90%86%E8%A7%A3window%E5%92%8Cwindowmanager/:0:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 08-理解Window和WindowManager","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-08-%E7%90%86%E8%A7%A3window%E5%92%8Cwindowmanager/"},{"categories":null,"content":"Window和WindowManager 先演示使用WindowManger添加一个Window. public void addWindow(){ Button button = new Button(getApplicationContext()); button.setText(\"动态添加\"); WindowManager.LayoutParams layoutParams = new WindowManager.LayoutParams(WindowManager.LayoutParams.WRAP_CONTENT, WindowManager.LayoutParams.WRAP_CONTENT, 0, 0, PixelFormat.TRANSPARENT); layoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE | WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED; layoutParams.gravity = Gravity.LEFT ; layoutParams.width = 400; layoutParams.height = 300; getWindowManager().addView(button, layoutParams); } Flag参数表示Window的属性,这些属性可以控制Window的显示特性. 下面是常用的属性: FLAG_NOT_FOCUSABLE: 表示Window不需要获取焦点, 而不需要接收各种输入事件, 此标记会同时启动FLAG_NOT_TOUCH_MODAL, 最终事件会直接传递给下层的具有焦点的Window. FLAG_NOT_TOUCH_MODAL: 这种模式下, 系统会将当前Window区域以外的点击事件传递给底层的Window, 当前Window区域以内的单击事件则自己处理. 这个标记很重要, 一般来说都需要开启此标记, 否则其他Window将无法接收到单击事件. FLAG_SHOW_WHEN_LOCKED: 开启此模式可以让Window显示在锁屏的界面上. Type参数表示Window的类型 Window共有三种类型, 分别是应用Window, 子Window, 系统Window. 应用类Window对应着一个Activity. 子Window不能单独存在, 他需要附属在特定的父Window中,比如常见的Dialog就是一个子Window. 系统Window是需要声明权限才能创建的Window, 比如Toast和系统状态栏都是系统的Window. Window是分层的, 每个Window都有对应的z-ordered, 层级大的会覆盖在层级小的Window的上面, 这和HTML中的z-index的概念一样. 应用Window的层级范围是1~99, 子Window的层级范围是1000~1999, 系统Window的层级范围是2000~2999. 如果想要在最顶层显示, 可以选择使用TYPE_SYSTEM_OVERLAY, TYPE_SYSTEM_ERROR. 如果采用了TYPE_SYSTEM_ERROR同时要声明权限android.permission.SYSTEM_ALERT_WINDOW. 如果不声明那么在创建的时候就会报错. WindowManager常用的功能 在ViewManager接口中定义了三个方法. 就是我们常用的方法添加View,删除View,修改View. WM继承了这个接口. ","date":"2016-08-15","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-08-%E7%90%86%E8%A7%A3window%E5%92%8Cwindowmanager/:1:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 08-理解Window和WindowManager","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-08-%E7%90%86%E8%A7%A3window%E5%92%8Cwindowmanager/"},{"categories":null,"content":"Window的内部机制 Window是一个抽象的概念, 每一Window都对应着一个View和一个ViewRootImpl, Window和View通过ViewRootImpl来建立联系, 因此Window并不是实际存在的, 他是以View的形式存在. 通过WindowManager的定义和提供的三个接口方法看出都是针对View的. 说明View才是Windwo存在的实体. 而在实际的使用中无法直接访问Window, 对Window的访问都是必须通过WM. ","date":"2016-08-15","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-08-%E7%90%86%E8%A7%A3window%E5%92%8Cwindowmanager/:2:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 08-理解Window和WindowManager","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-08-%E7%90%86%E8%A7%A3window%E5%92%8Cwindowmanager/"},{"categories":null,"content":"Window的添加过程 Window的添加过程需要通过WindowManager的addView()来实现, 而WindowManager是一个接口, 它的真正实现是WindowManagerImpl类, 在WindowManagerImpl中Window的三大操作如下. @Override public void addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params) { applyDefaultToken(params); mGlobal.addView(view, params, mDisplay, mParentWindow); } @Override public void updateViewLayout(@NonNull View view, @NonNull ViewGroup.LayoutParams params) { applyDefaultToken(params); mGlobal.updateViewLayout(view, params); } @Override public void removeView(View view) { mGlobal.removeView(view, false); } WindowManagerImpl并没有直接实现Window的三大操作, 而是全部交给了WindowManagerGlobal来处理. WindowManagerGlobal以工厂的形式向外提供自己的实例. 而WindowManagerImpl这种工作模式就典型的桥接模式, 将所有的操作全部委托给WindowManagerGlobal来实现. WindowManagerGlobal的addView()主要分为 检查所有参数是否合法, 如果是子Window那么还需要调整一些布局参数. 创建ViewRootImpl并将View添加到列表中. 通过ViewRootImpl来更新界面并完成Window的添加过程. 这个过程是通过ViewRootImpl#setView()来完成的. View的绘制过程是由ViewRootImpl来完成的, 在内部会调用requestLayout()来完成异步刷新请求. 而scheduleTraversals()实际上是View绘制的入口. 接着会通过WindowSession完成Window的添加过程(Window的添加过程是一次IPC调用). 最终会通过WindowManagerService来实现Window的添加. WindowManagerService内部会为每一个应用保留一个单独的Session. ","date":"2016-08-15","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-08-%E7%90%86%E8%A7%A3window%E5%92%8Cwindowmanager/:2:1","tags":["android","笔记"],"title":"《Android 开发艺术探索》 08-理解Window和WindowManager","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-08-%E7%90%86%E8%A7%A3window%E5%92%8Cwindowmanager/"},{"categories":null,"content":"Window的删除过程 Window 的删除过程和添加过程一样, 都是先通过WindowManagerImpl后, 在进一步通过WindowManagerGlobal的removeView()来实现的. public void removeView(View view, boolean immediate) { synchronized (mLock) { int index = findViewLocked(view, true); View curView = mRoots.get(index).getView(); removeViewLocked(index, immediate); if (curView == view) { return; } throw new IllegalStateException(\"Calling with view \" + view + \" but the ViewAncestor is attached to \" + curView); } } 方法内首先通过findViewLocked来查找待删除的View的索引, 这个过程就是建立数组遍历, 然后调用removeViewLocked来做进一步的删除. private void removeViewLocked(int index, boolean immediate) { ViewRootImpl root = mRoots.get(index); View view = root.getView(); if (view != null) { InputMethodManager imm = InputMethodManager.getInstance(); if (imm != null) { imm.windowDismissed(mViews.get(index).getWindowToken()); } } boolean deferred = root.die(immediate); if (view != null) { view.assignParent(null); if (deferred) { mDyingViews.add(view); } } } 这里通过ViewRootImpl的die()完成来完成删除操作. die()方法只是发送了请求删除的消息后就立刻返回了, 这个时候View并没有完成删除操作, 所以最后会将其添加到mDyingViews中, mDyingViews表示待删除的View的列表. boolean die(boolean immediate) { // Make sure we do execute immediately if we are in the middle of a traversal or the damage // done by dispatchDetachedFromWindow will cause havoc on return. if (immediate \u0026\u0026 !mIsInTraversal) { doDie(); return false; } if (!mIsDrawing) { destroyHardwareRenderer(); } else { Log.e(TAG, \"Attempting to destroy the window while drawing!\\n\" + \" window=\" + this + \", title=\" + mWindowAttributes.getTitle()); } mHandler.sendEmptyMessage(MSG_DIE); return true; } die方法中只是做了简单的判断, 如果是异步删除那么就发送一个MSG_DIE的消息, ViewRootImpl中的Handler会处理此消息并调用doDie(); 如果是同步删除, 那么就不发送消息直接调用doDie()方法. 在doDie()方法中会调用dispatchDetachedFromWindow()方法, 真正删除View的逻辑在这个方法内部实现. 其中主要做了四件事: 垃圾回收的相关工作, 比如清除数据和消息,移除回调. 通过Session的remove方法删除Window: mWindowSession.remove(mWindow), 这同样是一个IPC过程, 最终会调用WMS的removeWindow()方法. 调用View的dispatchDetachedFromWindow()方法, 内部会调用View的onDetachedFromWindow()以及onDetachedFromWindowInternal(). 而对于onDetachedFromWindow()就是在View从Window中移除时, 这个方法就会被调用, 可以在这个方法内部做一些资源回收的工作. 比如停止动画,停止线程 调用WindowManagerGlobal#doRemoveView方法刷新数据, 包括mRoots, mParams, mDyingViews, 需要将当前Window所关联的这三类对象从列表中删除. ","date":"2016-08-15","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-08-%E7%90%86%E8%A7%A3window%E5%92%8Cwindowmanager/:2:2","tags":["android","笔记"],"title":"《Android 开发艺术探索》 08-理解Window和WindowManager","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-08-%E7%90%86%E8%A7%A3window%E5%92%8Cwindowmanager/"},{"categories":null,"content":"Window的更新过程 WindowManagerGlobal#updateViewLayout()方法做的比较简单, 它需要更新View的LayoutParams并替换掉老的LayoutParams, 接着在更新ViewRootImpl中的LayoutParams. 这一步主要是通过setLayoutParams()方法实现. 在ViewRootImpl中会通过scheduleTraversals()来对View重新布局, 包括测量,布局,重绘. 除了View本身的重绘以外, ViewRootImpl还会通过WindowSession来更新Window的视图, 这个过程最后由WMS的relayoutWindow()实现同样是一个IPC过程. ","date":"2016-08-15","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-08-%E7%90%86%E8%A7%A3window%E5%92%8Cwindowmanager/:2:3","tags":["android","笔记"],"title":"《Android 开发艺术探索》 08-理解Window和WindowManager","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-08-%E7%90%86%E8%A7%A3window%E5%92%8Cwindowmanager/"},{"categories":null,"content":"Window的创建过程 View是Android中视图的呈现方式, 但是View不能单独存在, 它必须依附在Window这个抽象的概念上面, 因此有视图的地方就有Window. ","date":"2016-08-15","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-08-%E7%90%86%E8%A7%A3window%E5%92%8Cwindowmanager/:3:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 08-理解Window和WindowManager","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-08-%E7%90%86%E8%A7%A3window%E5%92%8Cwindowmanager/"},{"categories":null,"content":"Activity的Window创建过程 Activity的大体启动流程: 最终会由ActivityThread中的PerformLaunchActivity()来完成整个启动过程, 这个方法内部会通过类加载器创建Activity的实例对象, 并调用其attach()方法为其关联运行过程中所依赖的一系列上下文环境变量. 代码如下: private Activity performLaunchActivity(ActivityClientRecord r, Intent customIntent) { Activity activity = null; //获得类加载器 java.lang.ClassLoader cl = r.packageInfo.getClassLoader(); activity = mInstrumentation.newActivity( cl, component.getClassName(), r.intent); StrictMode.incrementExpectedActivityCount(activity.getClass()); r.intent.setExtrasClassLoader(cl); r.intent.prepareToEnterProcess(); if (r.state != null) { r.state.setClassLoader(cl); } Context appContext = createBaseContextForActivity(r, activity); CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager()); Configuration config = new Configuration(mCompatConfiguration); activity.attach(appContext, this, getInstrumentation(), r.token, r.ident, app, r.intent, r.activityInfo, title, r.parent, r.embeddedID, r.lastNonConfigurationInstances, config, r.referrer, r.voiceInteractor); return activity; } 在attach()方法里, 系统会创建Activity所属的Window对象并为其设置回调接口, Window对象的创建是通过PolicyManager#makeNewWindow()方法实现. 由于Activity实现了Window的CallBack接口, 因此当Window接收到外界的状态改变的时候就会回调Activity方法. 比如说我们熟悉的onAttachedToWindow(), onDetachedFromWindow(), dispatchTouchEvent()等等.代码如下 mWindow = new PhoneWindow(this); mWindow.setCallback(this); mWindow.setOnWindowDismissedCallback(this); mWindow.getLayoutInflater().setPrivateFactory(this); if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) { mWindow.setSoftInputMode(info.softInputMode); } if (info.uiOptions != 0) { mWindow.setUiOptions(info.uiOptions); } mUiThread = Thread.currentThread(); 那么Activity视图是怎么附属在Window上的呢? 查看经常使用的setContentView()方法干了什么 public void setContentView(@LayoutRes int layoutResID) { getWindow().setContentView(layoutResID); initWindowDecorActionBar(); } Activity将具体实现交给了Window处理, 而Window的具体实现就是PhoneWindow, 所以只需要看PhoneWindow的相关逻辑分为以下几步. 如果没有DecorView, 那么就创建它. 由installDecor()--\u003egenerateDecor()触发 将View添加到DecorView的mContentParent中 回调Activity的onContentChanged()通知activity视图已经发生改变 这个时候DecorView已经被创建并初始化完毕, Activity的布局文件也已经添加成功到DecorView的mContentParent中. 但是这个时候DecorView还没有被WindowManager正式添加到Window中. 虽然早在Activity的attach方法中window就已经被创建了, 但是这个时候由于DecorView并没有被WindowManager识别, 所以这个时候的Window无法提供具体功能, 因为他还无法接收外界的输入信息. 在ActivityThread#handleResumeActivity()方法中, 首先会调用Activity#onResume(), 接着会调用Activity#makeVisible(), 正是在makeVisible方法中, DecorView真正的完成了添加和显示这两个过程. 如下: void makeVisible() { if (!mWindowAdded) { ViewManager wm = getWindowManager(); wm.addView(mDecor, getWindow().getAttributes()); mWindowAdded = true; } mDecor.setVisibility(View.VISIBLE); } ","date":"2016-08-15","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-08-%E7%90%86%E8%A7%A3window%E5%92%8Cwindowmanager/:3:1","tags":["android","笔记"],"title":"《Android 开发艺术探索》 08-理解Window和WindowManager","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-08-%E7%90%86%E8%A7%A3window%E5%92%8Cwindowmanager/"},{"categories":null,"content":"Dialog的Window创建过程 Dialog的Window的创建过程和Activity类似, 有如下几步 1. 创建Window Dialog的创建后的实际就是PhoneWindow, 这个过程和Activity的Window创建过程一致. 2. 初始化DecorView并将Dialog的视图添加到DecorView中 这个过程也类似, 都是通过Window去添加指定的布局文件. 3. 将DecorView添加到Window中并显示 在Dialog的show方法中, 会通过WindowManager将DecorView添加Window中. mWindowManager.addView(mDecor, l); mShowing = true; sendShowMessage(); 普通的Dialog有一个特殊之处, 那就是必须采用Activity的Content, 如果采用Application的Content, 那么就会报错. 报的错是没有应用token所导致的, 而应用token一般只有Activity才拥有. 还有一种方法. 系统Window比较特殊, 他可以不需要token, 因此只需要指定对话框的Window为系统类型就可以正常弹出对话框. //JAVA 给Dialog的Window改变为系统级的Window dialog.getWindow().setType(WindowManager.LayoutParams.TYPE_SYSTEM_ERROR); //XML 声明权限 \u003cuses-permission android:name=\"android.permission.SYSTEM_ALERT_WINDOW\"/\u003e ","date":"2016-08-15","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-08-%E7%90%86%E8%A7%A3window%E5%92%8Cwindowmanager/:3:2","tags":["android","笔记"],"title":"《Android 开发艺术探索》 08-理解Window和WindowManager","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-08-%E7%90%86%E8%A7%A3window%E5%92%8Cwindowmanager/"},{"categories":null,"content":"Toast的Window创建过程 Toast和Dialog不同, 它的工作过程就稍显复杂. 首先Toast也是基于Window来实现的. 但是由于Toast具有定时取消的功能, 所以系统采用了Handler. 在Toast的内部有两类IPC过程, 第一类是Toast访问NotificationManagerService()后面简称NMS. 第二类是NotificationManagerService回调Toast里的TN接口. Toast属于系统Window, 它内部的视图有两种方式指定, 一种是系统默认的样式, 另一种是通过setView方法来指定一个自定义View. 不管如何, 他们都对应Toast的一个View类型的内部成员mNextView. Toast内部提供了cancel和show两个方法. 分别用于显示和隐藏Toast. 他们内部是一个IPC过程. 显示和隐藏Toast都是需要通过NMS来实现的. 由于NMS运行在系统的进程中, 所以只能通过远程调用的方式来显示和隐藏Toast. 而TN这个类是一个Binder类. 在Toast和NMS进行IPC的过程中, 当NMS处理Toast的显示或隐藏请求时会跨进程回调TN的方法. 这个时候由于TN运行在Binder线程池中, 所以需要通过Handler将其切换到当前主线程. 所以由其可知, Toast无法在没有Looper的线程中弹出, 因为Handler需要使用Looper才能完成切换线程的功能. if (!isSystemToast) { int count = 0; final int N = mToastQueue.size(); for (int i=0; i\u003cN; i++) { final ToastRecord r = mToastQueue.get(i); if (r.pkg.equals(pkg)) { count++; // MAX_PACKAGE_NOTIFICATIONS == 50 if (count \u003e= MAX_PACKAGE_NOTIFICATIONS) { Slog.e(TAG, \"Package has already posted \" + count + \" toasts. Not showing more. Package=\" + pkg); return; } } } } 对于非系统应用来说, 最多能同时存在对Toast封装的ToastRecord上限为50个. 这样做是为了防止DOS(Denial of Service). 如果不这样, 当通过大量循环去连续的弹出Toast, 这将会导致其他应用没有机会弹出Toast, 那么对于其他应用的Toast请求, 系统的行为就是拒绝服务, 这就是拒绝服务攻击的含义. 在ToastRecord被添加到mToastQueue()中后, NMS就会通过showNextToastLocked()方法来显示当前的Toast. Toast的显示是由ToastRecord的callback来完成的. 这个callback实际上就是Toast中的TN对象的远程Binder. 通过callback来访问TN中的方法是需要跨进程的. 最终被调用的TN中的方法会运行在发起Toast请求的应用的Binder线程池. private void scheduleTimeoutLocked(ToastRecord r){ mHandler.removeCallbacksAndMessages(r); Message m = Message.obtain(mHandler, MESSAGE_TIMEOUT, r); long delay = r.duration == Toast.LENGTH_LONG ? LONG_DELAY : SHORT_DELAY; mHandler.sendMessageDelayed(m, delay); } 如上代码就是在Toast显示以后, NMS通过这个方法来发送一个延时消息, 具体取决Toast的时长. LONG_DELAY, SHORT_DELAY分别对应着3.5秒和2秒. 当延时时间达到的时候. NMS会通过cancelToastLocked()方法来隐藏Toast并将其从mToastQueue中移除, 这个时候如果mToastQueue中还有其余Toast那么NMS就继续显示其他. Toast的隐藏也会通过ToastRecord的callback完成的.同样是一次IPC过程. 方式和Toast显示类似. void cancelToastLocked(int index) { ToastRecord record = mToastQueue.get(index); try { record.callback.hide(); } catch (RemoteException e) { Slog.w(TAG, \"Object died trying to hide notification \" + record.callback + \" in package \" + record.pkg); // don't worry about this, we're about to remove it from // the list anyway } mToastQueue.remove(index); keepProcessAliveLocked(record.pid); if (mToastQueue.size() \u003e 0) { // Show the next one. If the callback fails, this will remove // it from the list, so don't assume that the list hasn't changed // after this point. showNextToastLocked(); } } 以上基本说明Toast的显示和影响过程实际上是通过Toast中的TN这个类来实现的. 他有两个方法show(), hide(). 分别对应着Toast的显示和隐藏. 由于这两个方法是被NMS以跨进程的方式调用的, 因此他们运行在Binder线程池中. 为了将执行环境切换到Toast请求所在线程中, 在他们内部使用了handler,如下 @Override public void show() { if (localLOGV) Log.v(TAG, \"SHOW: \" + this); mHandler.post(mShow); } /** * schedule handleHide into the right thread */ @Override public void hide() { if (localLOGV) Log.v(TAG, \"HIDE: \" + this); mHandler.post(mHide); } 上面代码中, mShow, mHide是两个Runnable, 他们内部分别调用了handleShow和handleHide方法. 所以这两个方法才是真正完成隐藏和显示Toast的地方. TN的handleShow中会将Toast的视图添加到Window中. TN的handleHide中会将Toast的视图从Window中移除. 具体实现代码如下: //handleShow() mWM = (WindowManager)context.getSystemService(Context.WINDOW_SERVICE); mWM.addView(mView, mParams); //handleHide() if (mView != null) { if (mView.getParent() != null) { if (localLOGV) Log.v(TAG, \"REMOVE! \" + mView + \" in \" + this); mWM.removeView(mView); } mView = null; } 关于Toast流程已经完事. 除了说到的Activity, Dialog, Toast. 还有PopupWindow 菜单栏, 状态栏都是通过Window来实现的. 下一章: 第9章: 四大组件的工作过程 ","date":"2016-08-15","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-08-%E7%90%86%E8%A7%A3window%E5%92%8Cwindowmanager/:3:3","tags":["android","笔记"],"title":"《Android 开发艺术探索》 08-理解Window和WindowManager","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-08-%E7%90%86%E8%A7%A3window%E5%92%8Cwindowmanager/"},{"categories":null,"content":" 第七章: 了解动画并去自定义动画, 在一些场景有哪些注意事项 blog相关代码 ","date":"2016-08-13","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-07-andriod%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/:0:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 07-Andriod动画深入分析","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-07-andriod%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/"},{"categories":null,"content":"View动画 View动画作用的对象是View, 它支持四种动画效果平移, 缩放, 旋转, 透明. 除了这四种典型的变化效果. 帧动画也属于View动画. ","date":"2016-08-13","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-07-andriod%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/:1:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 07-Andriod动画深入分析","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-07-andriod%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/"},{"categories":null,"content":"View动画的种类 View动画的四种变换效果对应着Animation的四个子类:TranslateAnimation, ScaleAnimation, RotateAnimation和AlphaAnimation. 对于View动画建议采用XML来定义动画 名称 标签 子类 效果 平移动画 \u003ctranslate\u003e TranslateAnimation 移动View 缩放动画 \u003cscale\u003e ScaleAnimation 放大或者缩小View 旋转动画 \u003crotate\u003e RotateAnimation 旋转View 透明度动画 \u003calpha\u003e AlphaAnimation 改变View的透明度 创建的动画的xml文件. 是放在res/anim这个文件夹下的. View动画描述文件的固有语法如下 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cset xmlns:android=\"http://schemas.android.com/apk/res/android\" android:shareInterpolator=\"true\" android:fillAfter=\"true\"\u003e \u003calpha android:fromAlpha=\"float\" android:toAlpha=\"float\"/\u003e \u003cscale android:fromXScale=\"float\" android:toXScale=\"float\" android:fromYScale=\"float\" android:toYScale=\"float\" android:pivotX=\"float\" android:pivotY=\"float\"/\u003e \u003ctranslate android:fromXDelta=\"float\" android:toXDelta=\"float\" android:fromYDelta=\"float\" android:toYDelta=\"float\"/\u003e \u003crotate android:fromDegrees=\"float\" android:toDegrees=\"float\" android:pivotY=\"float\" android:pivotX=\"float\"/\u003e \u003c/set\u003e 关于动画我们可以只设置一种也可以设置多种的组合. set标签对应着AnimationSet类, 标签中的属性的意义: shareInterpolator 表示集合中的动画是否和集合共享一个插值器. 如果集合不指定插值器, 那么子动画就需要单独制定所需的插值器或者使用默认值 fillAfter 是否保留动画结束之后的状态 translate标签表示平移动画, 对应着TranslateAnimation类 属性值的意义就是from开头的为开始起点, to开头的结束点 scale标签表示缩放动画, 对应着ScaleAnimation类 属性值的意思from开头的表示开始时原图缩放的百分比. 用浮点数表示1表示100%(无变化),0.5表示50%(原来的一般), 2表示200%(原来的两倍). to开头的表示结束时的百分比. pivot表示缩放的轴点. rotate标签表示旋转动画, 对应着RotateAnimation类 fromDegrees旋转的开始角度, toDegrees旋转的结束角度. pivot旋转的轴点 alpha标签表示透明度动画, 对应AlphaAnimation类 fromAlpha表示透明度的起始值, toAlpha表示透明度的结束值. 上面这些标签还有一些通用的属性值. 例如duration执行时间. xml如果声明了之后那么我们就该在代码中应用了. 如下: View btn_main = findViewById(R.id.parent); Animation animation = AnimationUtils.loadAnimation(this, R.anim.temp); btn_main.startAnimation(animation); 同样也可以不需要xml直接在代码中生成动画对象. AlphaAnimation alphaAnimation = new AlphaAnimation(1, 0); alphaAnimation.setDuration(1000); btn_main.startAnimation(alphaAnimation); 在开始动画之前可以给动画添加一个监听setAnimationListener()这样在动画开始结束和每一次循环下一次的时候都可以在回调方法中监听到. ","date":"2016-08-13","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-07-andriod%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/:1:1","tags":["android","笔记"],"title":"《Android 开发艺术探索》 07-Andriod动画深入分析","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-07-andriod%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/"},{"categories":null,"content":"自定义View动画 如果需要自定义View动画, 首先应该继承Animation这个抽象类来派生出一种新动画. 然后重写initialize()和applyTransformation()方法. 在initialize中做一些初始化动作, 在applyTransformation()中进行相应矩阵变换, 很多时候需要采用Camera来简化矩阵变换的过程. 而View动画变化主要就是矩阵的变换过程. 这里举一个Android中ApiDemo的一个自定义View动画. 大概效果就是这样可以参照官网的api也可在包中的MyRotateAnimation ","date":"2016-08-13","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-07-andriod%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/:1:2","tags":["android","笔记"],"title":"《Android 开发艺术探索》 07-Andriod动画深入分析","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-07-andriod%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/"},{"categories":null,"content":"帧动画 帧动画是顺序播放一组预先定义好的图片, 类似于电影. 系统提供了AnimationDrawable来使用帧动画. 同样在xml中声明, 在res/drawable/包下创建文件, 并替换每个drawable图片即可 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003canimation-list xmlns:android=\"http://schemas.android.com/apk/res/android\" android:oneshot=\"false\"\u003e \u003citem android:drawable=\"@drawable/xx1\" android:duration=\"500\"/\u003e \u003citem android:drawable=\"@drawable/xx2\" android:duration=\"500\"/\u003e \u003citem android:drawable=\"@drawable/xx3\" android:duration=\"500\"/\u003e \u003citem android:drawable=\"@drawable/xx4\" android:duration=\"500\"/\u003e \u003c/animation-list\u003e 将上述的Drawable作为View的背景并通过Drawable来播放动画. AnimationDrawable background = (AnimationDrawable) iv_main.getBackground();background.start(); ","date":"2016-08-13","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-07-andriod%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/:1:3","tags":["android","笔记"],"title":"《Android 开发艺术探索》 07-Andriod动画深入分析","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-07-andriod%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/"},{"categories":null,"content":"View动画的特殊使用场景 前面介绍的View动画都是作用在某一个View对象上的. 还可以针对ViewGroup控制其子元素. 或者针对Activity切换的动画. ","date":"2016-08-13","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-07-andriod%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/:2:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 07-Andriod动画深入分析","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-07-andriod%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/"},{"categories":null,"content":"LayoutAnimation LayoutAnimation作用于ViewGroup上的. 为ViewGroup指定一个动画, 这样当它的子元素出场时都会具有这种动画效果. 常用的使用场景是在ListView和GridView. 使用很简单步骤如下. 在res/anim/文件夹下创建xml文件. \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003clayoutAnimation xmlns:android=\"http://schemas.android.com/apk/res/android\" android:delay=\"0.5\" android:animationOrder=\"random\" android:animation=\"@anim/layout\"\u003e \u003c/layoutAnimation\u003e delay: 子元素开始动画的延迟时间, 传入值是浮点值. 1为100%. 例如如果是0.5 入场动画周期为300ms(下面关联动画的duration时间), 那么每个子元素都需要延迟150ms才能播放入场动画. 而且这个时间会根据item的递增而增加. 比方说第一个为延迟150ms, 第二个就是300ms依次类推. animationOrder: 子元素动画的顺序, 有三种选择normal,reverse,random. reverse表示排在后面的元素先执行入场动画. random随机子元素执行动画. animation: 为子元素指定具体的入场动画. 里面放的就是针对View的animation动画的xml layoutAnimation声明完成之后, 在要作用的ViewGroup标签中增加android:layoutAnimation:\"@anim/xxx\"进行关联即可. 同样也可以通过代码创建LayoutAnimation类来实现. //获得子元素需要执行的View动画 Animation animation = AnimationUtils.loadAnimation(this, R.anim.layout); //创建一个LayoutAnimation动画对象 LayoutAnimationController controller = new LayoutAnimationController(animation); controller.setDelay(0.5f); controller.setOrder(LayoutAnimationController.ORDER_RANDOM); //对ViewGrop进行绑定 listView.setLayoutAnimation(controller); ","date":"2016-08-13","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-07-andriod%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/:2:1","tags":["android","笔记"],"title":"《Android 开发艺术探索》 07-Andriod动画深入分析","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-07-andriod%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/"},{"categories":null,"content":"Activity的切换效果 Activity默认是有一种切换效果的. 如果需要自定义切换效果, 主要用到overridePendingTransition()这个方法, 这个方法必须在startActivity()或者finish()之后调用才会生效 需要的形参有两个, 第一个是被打开时候所需的动画资源id, 第二个是被暂停时,所需的动画资源id. = =. 这里有问题, 试了半天不好使, 就没写具体步骤…. ","date":"2016-08-13","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-07-andriod%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/:2:2","tags":["android","笔记"],"title":"《Android 开发艺术探索》 07-Andriod动画深入分析","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-07-andriod%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/"},{"categories":null,"content":"属性动画 属性动画是API新加入的特性, 和View动画不同, 它对作用对象进行了扩展, 属性动画可以对任何对象做动画. 属性动画不再像View动画那样只能支持四种简单的交换 . 属性动画中有valueAnimator. ObjectAnimator, AnimatorSet等概念 ","date":"2016-08-13","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-07-andriod%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/:3:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 07-Andriod动画深入分析","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-07-andriod%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/"},{"categories":null,"content":"使用属性动画 属性动画可以对任何对象的属性进行动画而不仅仅是View, 动画默认时间间隔为300ms, 默认帧率10ms/帧. 可以达到的效果为: 在一段时间间隔内完成对象从一个属性值到另一个属性值的改变. 属性动画是从API11增加的. 如: 改变一个对象的背景色属性, 典型的改变View的背景色, 下面的动画可以让背景颜色的渐变, 动画会无限循环而且会有反转效果. ObjectAnimator colorAnim = ObjectAnimator.ofInt(activity_main, \"backgroundColor\", 0xffffa000, 0xffffa0ff); colorAnim.setDuration(5000); colorAnim.setEvaluator(new ArgbEvaluator()); colorAnim.setRepeatCount(ValueAnimator.INFINITE); colorAnim.setRepeatMode(ValueAnimator.REVERSE); colorAnim.start(); 效果这样: 动画集合,5秒内对View旋转平移缩放透明 AnimatorSet animatorSet = new AnimatorSet(); animatorSet.playTogether( ObjectAnimator.ofFloat(iv_main, \"rotationX\", 0,360), ObjectAnimator.ofFloat(iv_main, \"rotationY\", 0,360), ObjectAnimator.ofFloat(iv_main, \"rotation\", 0,360), ObjectAnimator.ofFloat(iv_main, \"translationX\", 0,200), ObjectAnimator.ofFloat(iv_main, \"translationY\", 0,200), ObjectAnimator.ofFloat(iv_main, \"scaleX\", 1,1.5f), ObjectAnimator.ofFloat(iv_main, \"scaleY\", 1,1.5f), ObjectAnimator.ofFloat(iv_main, \"alpha\", 1, 0.25f, 1) ); animatorSet.setDuration(5*1000).start(); 也可以使用xml的形式形式来声明 ","date":"2016-08-13","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-07-andriod%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/:3:1","tags":["android","笔记"],"title":"《Android 开发艺术探索》 07-Andriod动画深入分析","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-07-andriod%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/"},{"categories":null,"content":"理解插值器和估值器 TimeInterpolator时间插值器, 作用是根据时间流逝的百分比来计算当前属性值改变的百分比. 系统预置的有 LinearInterpolator(线性插值器:匀速动画) AccelerateDecelerateInterpolator(加速减速插值器:动画两头慢中间快) DecelerateInterpolator(减速插值器:动画越来越慢) TypeEvaluator 类型估值算法, 也叫估值器. 作用是根据当前属性改变的百分比来计算改变后的属性值. 系统预置的估值器有 IntEvaluator 整形估值器 FloatEvaluator 浮点型估值器 ArgbEvaluator Color属性估值器 属性动画中的插值器和估值器都很重要, 他们是实现非匀速动画的重要手段 属性动画要求对象的该属性有set``get方法. 插值器和估值器算法除了系统提供的外. 也可以自定义. 实现方式也很简单, 因为插值器和估值算法都是一个接口, 且内部都只有一个方法, 我们只要派生一个类实现接口接可以. 具体就是: 自定义插值器需要实现Interpolator或者TimeInterpolator. 自定义估值算法需要实现TypeEvaluator ","date":"2016-08-13","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-07-andriod%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/:3:2","tags":["android","笔记"],"title":"《Android 开发艺术探索》 07-Andriod动画深入分析","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-07-andriod%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/"},{"categories":null,"content":"属性动画的监听器 属性动画提供了监听器用于监听动画的播放过程 主要有两个接口AnimatorUpdateListener和AnimatorListener接口. AnimatorListener 通过接口的定义可以看出, 监听了动画的开始,结束,取消,以及重复播放. 系统为了方便开发提供了AnimatorListenerAdapter类. 他是AnimatorListener的适配器. 这样就不需要非得实现四个抽象方法而是按照我们的需要选择复写. AnimatorUpdateListener 比较特殊, 他会监听整个动画过程, 动画是由许多帧组成的. 每播放一帧onAnimationUpdate就会被调用一次 ","date":"2016-08-13","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-07-andriod%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/:3:3","tags":["android","笔记"],"title":"《Android 开发艺术探索》 07-Andriod动画深入分析","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-07-andriod%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/"},{"categories":null,"content":"对任意属性做动画 问题: 如果需要把一个button控件的宽增加200px. 应该怎么做? View动画只是支持四种基本的属性操作, 而Scale只是缩放. 并且还会对内容进行拉伸并且伴随着y轴的增加. 所以属性动画在这里就可以派上用场. 但是如果直接对width属性进行修改那么不会有效果. 分析一下: 属性动画的原理: 属性动画要求动画作用的对象提供该属性的get和set方法, 属性动画根据外界传递的该属性值的初始值和最终值, 以动画的效果多次调用set每次set的值也是不同. 最终达到终点值. 所以要让动画生效应该满足两个条件: 必须提供setXXX()方法, 如果动画没有传递初始值还要提供getXXX()方法. 这样系统在需要初始属性的时候在取值时不会因为没有getXXX()而发生Crash. set修改的值必须能改通过某种形式反映出来, 比如会带来UI的改变. (如果不满足这条,动画无效果但不会Crash) 那Button本身具备setWidth()为什么会无效果. 这是因为虽然Button提供了方法, 但是这个setWidth()方法并不是改变视图大小的, 他是TextView新添加的方法, View却没有这样的方法. 而setWidth()方法的内部,作用不是设置View的大小, 而是设置TextView的最大宽度和最小宽度, 这个和TextView的宽是两个东西. 这样说控件的宽度对应xml中的layout_width, 而setWidth()对应的就是xml中的width属性. 所以综合上述原因, 满足条件一而不满足条件二. 官网文档中给出了三种解决方案: 给你的对象加上get和set方法, 如果你有权限的话. 用一个类来包装原始对象, 间接为其提供get和set方法. 采用valueAnimator, 监听动画过程,自己实现属性的改变. 虽然简单但是没有权限去SDK内部实现去 可以创建一个内部包装类创建set(),get()方法对View的LayoutParams.width进行修改. 采用ValueAnimator, 监听动画过程, 自己实现属性改变. ValueAnimator本身不作用于任何对象. 但是他可以对一个值做动画. 通过对每个值的分配并会回调函数返回此值, 可以手动进行实现. ","date":"2016-08-13","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-07-andriod%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/:3:4","tags":["android","笔记"],"title":"《Android 开发艺术探索》 07-Andriod动画深入分析","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-07-andriod%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/"},{"categories":null,"content":"属性动画的工作原理 前面说过, 说属性画要求作用的对象提供该属性方法set方法, 属性动画根据传递的该属性的初始值和最终值, 以动画的效果多次去调用set方法. 每次set方法时候传递的值都是不一样的. 也就是随着时间的推移所传递的值会越来越接近终点值. 源码分析: 针对ObjectAnimator的start()为入口 @Override public void start() { // See if any of the current active/pending animators need to be canceled AnimationHandler handler = sAnimationHandler.get(); if (handler != null) { int numAnims = handler.mAnimations.size(); for (int i = numAnims - 1; i \u003e= 0; i--) { if (handler.mAnimations.get(i) instanceof ObjectAnimator) { ObjectAnimator anim = (ObjectAnimator) handler.mAnimations.get(i); if (anim.mAutoCancel \u0026\u0026 hasSameTargetAndProperties(anim)) { anim.cancel(); } } } numAnims = handler.mPendingAnimations.size(); for (int i = numAnims - 1; i \u003e= 0; i--) { if (handler.mPendingAnimations.get(i) instanceof ObjectAnimator) { ObjectAnimator anim = (ObjectAnimator) handler.mPendingAnimations.get(i); if (anim.mAutoCancel \u0026\u0026 hasSameTargetAndProperties(anim)) { anim.cancel(); } } } numAnims = handler.mDelayedAnims.size(); for (int i = numAnims - 1; i \u003e= 0; i--) { if (handler.mDelayedAnims.get(i) instanceof ObjectAnimator) { ObjectAnimator anim = (ObjectAnimator) handler.mDelayedAnims.get(i); if (anim.mAutoCancel \u0026\u0026 hasSameTargetAndProperties(anim)) { anim.cancel(); } } } } if (DBG) { Log.d(LOG_TAG, \"Anim target, duration: \" + getTarget() + \", \" + getDuration()); for (int i = 0; i \u003c mValues.length; ++i) { PropertyValuesHolder pvh = mValues[i]; Log.d(LOG_TAG, \" Values[\" + i + \"]: \" + pvh.getPropertyName() + \", \" + pvh.mKeyframes.getValue(0) + \", \" + pvh.mKeyframes.getValue(1)); } } super.start(); } 这段代码主要就是取消和当前动画相同的动画. 最开始判断了当前动画,等待动画,延迟动画是否有一致的. 如果有那么就给取消. 最后调用了父类方法. 因为ObjectAnimator继承了ValueAnimator,所以继续看一下父类的start() private void start(boolean playBackwards) { if (Looper.myLooper() == null) { throw new AndroidRuntimeException(\"Animators may only be run on Looper threads\"); } mReversing = playBackwards; mPlayingBackwards = playBackwards; int prevPlayingState = mPlayingState; mPlayingState = STOPPED; mStarted = true; mStartedDelay = false; mPaused = false; updateScaledDuration(); // in case the scale factor has changed since creation time AnimationHandler animationHandler = getOrCreateAnimationHandler(); animationHandler.mPendingAnimations.add(this); if (mStartDelay == 0) { // This sets the initial value of the animation, prior to actually starting it running if (prevPlayingState != SEEKED) { setCurrentPlayTime(0); } mPlayingState = STOPPED; mRunning = true; notifyStartListeners(); } animationHandler.start(); } 属性动画需要运行在有Looper的线程中, 最终会调用AnimationHandler.start()方法. AnimationHandler并不是Handler, 他是一个Runnable. 后面会调到JNI层, 然后JNI层还会调回, 然后run方法会被调用, 这个Runable涉及和底层的交互. 略过. 看重点. ValueAnimator的doAnimationFrame()方法, 内部最后调用了animationFrame()方法,而animationFrame()内部调用了animateValue()方法 void animateValue(float fraction) { fraction = mInterpolator.getInterpolation(fraction); mCurrentFraction = fraction; int numValues = mValues.length; for (int i = 0; i \u003c numValues; ++i) { mValues[i].calculateValue(fraction); } if (mUpdateListeners != null) { int numListeners = mUpdateListeners.size(); for (int i = 0; i \u003c numListeners; ++i) { mUpdateListeners.get(i).onAnimationUpdate(this); } } } 看到了calculateValue()方法, 这个就是计算每帧动画所对应的属性的值, 然后看一下set,get方法. 比如之前说的如果没有初始值, 则调用get方法等.. 查看PropertyValuesHolder类的setupValue() private void setupValue(Object target, Keyframe kf) { if (mProperty != null) { Object value = convertBack(mProperty.get(target)); kf.setValue(value); } if (mGetter == null) { Class targetClass = target.getClass(); setupGetter(targetClass); if (mGetter == null) { // Already logged the error - just return to avoid NPE return; } } Object value = convertBack(mGetter.invoke(target)); kf.setValue(value); 当动画的下一帧到来的时, setAnimatedValue()方法会将新的属性值给对象, 调用其set()方法.同样set也是反射调用 void setAnimatedValue(Object target) { if (mProperty != null) { mProperty.set(target, getAnimatedValue()); } if (mSetter != null) { mTmpValueArray[0] = getAnimatedValue(); mSetter.invoke(target, mTmpValueArray); } } ","date":"2016-08-13","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-07-andriod%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/:3:5","tags":["android","笔记"],"title":"《Android 开发艺术探索》 07-Andriod动画深入分析","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-07-andriod%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/"},{"categories":null,"content":"使用动画的注意事项 OOM问题: 在帧动画时候容易发生 内存泄漏: 如果有无限循环的属性动画, 在界面退出的时候一定要停止动画 ,否则activity会无法释放. 而View动画并不存在此问题. 兼容性问题: 主要是3.0以下系统 View动画问题: 因为是对原始View做的影像效果. 并未真正改变View. 所以在动画完成之后.无法GONE掉. 这个时候调用view.clearAnimation()清除View效果即可 不要使用px 动画交互. 系统3.0之前无论是属性动画还是View动画新的位置都无法触发单击事件.需要注意 硬件加速的使用 第8章 理解Window和WindowManager ","date":"2016-08-13","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-07-andriod%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/:4:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 07-Andriod动画深入分析","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-07-andriod%E5%8A%A8%E7%94%BB%E6%B7%B1%E5%85%A5%E5%88%86%E6%9E%90/"},{"categories":null,"content":" 第六章: 梳理种类繁多的Drawable. 并了解相应的自定义Drawable blog相关代码 ","date":"2016-08-12","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-06-android%E7%9A%84drawable/:0:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 06-Android的Drawable","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-06-android%E7%9A%84drawable/"},{"categories":null,"content":"Drawable简介 Drawable表示一种图像的概念. **优点:**使用比自定义View的成本低, 非图片类型的Drawable占用空间较小. Drawable本身是一个抽象类. 是所有Drawable对象的基类, 每个具体的Drawable都是其子类. Drawable内部宽高通过getIntrinsicWidth和getIntrinsicHeight这两个方法获得. 需要注意这个内部宽高的概念针对不同的类型的Drawable, 对于图片形成的Drawable内部宽高就是图片的宽高. 而颜色所形成的Drawable没有内部宽高的概念. Drawable的内部宽高不等于它的大小. 当作为View的背景的视图, Drawable会被拉伸至View的同等大小. ","date":"2016-08-12","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-06-android%E7%9A%84drawable/:1:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 06-Android的Drawable","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-06-android%E7%9A%84drawable/"},{"categories":null,"content":"Drawable的分类 ","date":"2016-08-12","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-06-android%E7%9A%84drawable/:2:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 06-Android的Drawable","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-06-android%E7%9A%84drawable/"},{"categories":null,"content":"BitmapDrawable 表示一张图片, 在开发中直接引用原始图片也可, 下面给出在XML中描述稍微完整的声明 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cbitmap xmlns:android=\"http://schemas.android.com/apk/res/android\" android:src=\"@mipmap/ic_sample\" android:antialias=\"true\" android:dither=\"true\" android:filter=\"true\" android:gravity=\"top\" android:mipMap=\"true\" android:tileMode=\"repeat\" \u003e \u003c/bitmap\u003e src: 图片的资源文件id(AS下可能不会自动提示mipmap,直接写入即可) antialias: 图片抗锯齿.属性值boolean 开启可以让图片变得平滑. dither: 抖动效果. 属性值Boolean. 当图片的像素配置和手机屏幕的像素配置不一致时,开启此选项可以让高质量的图片在低质量的屏幕上继续保持较好效果. 例如图片模式为ARGB8888,而设备屏幕所支持为RGB555. 开启可以让图片不会过于失真. filter: 过滤效果. 当图片尺寸被拉伸或者压缩,可以保持较好的效果. gravity: 可以对图片进行定位. 可以使用|组合属性使用. 可供使用的属性 可选项 含义 top 放在顶部, 不改变图片大小 bottom 放在底部, 不改变图片大小 left 放在左端, 不改变图片大小 right 放在右端, 不改变图片大小 center_vertical 使图片竖直居中, 不改变图片大小 fill_vertical 图片竖直方向填充容器 center_horizontal 使图片水平居中, 不改变图片大小 fill_horizontal 图片水平方向填充容器 center 图片同时水平和垂直居中, 不改变图片大小 fill 图片水平和竖直方向均填充容器, 这是默认值 clip_vertical 表示竖直方向的裁剪, 较少使用 clip_horizontal 表示水平方向的裁剪, 较少使用 mipmap: 纹理映射 默认为false tileMode: 平铺模式. 有四种值: disable关闭平铺模式(默认值), repeat普通平铺开启, mirror平铺的同时,平铺图片做镜面效果. clamp在原始图片最右边像素向右延伸, 最下边像素向下延伸.如图: NinePatchDrawable 表示一张.9格式的图片, .9图片可以自动的根据所需要的宽高进行相应的缩放并保证不失真. 和BitmapDrawable使用一样直接引入图片即可. xml方式如下: \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cnine-patch xmlns:android=\"http://schemas.android.com/apk/res/android\" android:src=\"xxxx\" android:dither=\"true\"/\u003e ","date":"2016-08-12","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-06-android%E7%9A%84drawable/:2:1","tags":["android","笔记"],"title":"《Android 开发艺术探索》 06-Android的Drawable","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-06-android%E7%9A%84drawable/"},{"categories":null,"content":"ShapeDrawable 这是一种通过颜色来构成的图片, 它可以为纯色的图形, 也可以具有渐变的图形. 以下是一个简单使用方法 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cshape xmlns:android=\"http://schemas.android.com/apk/res/android\" android:shape=\"rectangle\"\u003e \u003c!--圆角--\u003e \u003ccorners android:radius=\"50dp\"/\u003e \u003cpadding android:top=\"5dp\"/\u003e \u003c!--填充--\u003e \u003csolid android:color=\"@color/colorPrimary\"/\u003e \u003c!--gradient 和solid 互斥属性谁放在后面谁才有效--\u003e \u003c!--渐变--\u003e \u003cgradient android:angle=\"90\" android:startColor=\"#f00\" android:centerColor=\"#0f0\" android:endColor=\"#00f\"/\u003e \u003c!--边框--\u003e \u003cstroke android:width=\"30dp\" android:color=\"#ff0000\" /\u003e \u003c/shape\u003e 来说说具体的属性都有什么 shape: 表示图片的形状, 有四个选项: rectangle()矩形, oval(椭圆), line(横线), ring(圆环). 默认值为矩形. 另外line和ring这两个选项必须要通过\u003cstroke\u003e标签来指定线的宽度和颜色等信息, 否则无法达到预期效果.当ring这个形状还需要添加几个属性innerRadius圆环内半径, thickness圆环的厚度,外半径减去内半径的距离. 还有两个半分比的属性.效果一样. useLevel:基本都是用false, 否则可能无法到达预期的显示效果,除非被当做LevelListDrawable.如下图可以看看几个方式的样子 \u003ccorner\u003e 表示shape的四个角度. 它只适用于矩形shape. 支持属性总共有五个,一个Radius和四个顶角如topLeftRadius等等. Radius的优先级最低, 会被其他属性覆盖. \u003cgradient\u003e 它与\u003csolid\u003e标签是互相互斥的. 其中solid表示纯色填充, 而gradient则表示渐变效果. 有如下属性: android:angle –渐变的角度, 默认为0, 其值必须为45的倍数. 0表示从左到右, 90表示从下到上. android:centerX –渐变的中心点横坐标(范围0~1) android:centerY –渐变的中心点纵坐标(范围0~1) android:startColor –渐变的起始色 android:centerColor –渐变的中间色 android:endColor –渐变的结束色 android:gradientRadius –渐变半径, 仅当android:type=“radial\"时有效,**并且当type=“radial”**的时候必须声明此属性,否则崩溃 android:useLevel –一般为false.当Drawable作为StateListDrawable使用时为true android:type –渐变的类型, 有linear(线性渐变), radial(径向渐变), sweep(扫描线渐变)三种, 默认为线性渐变 看看type不同的格式什么样子 \u003csolid\u003e 表示纯色填充, 通过android:color来指定颜色 \u003cstroke\u003e shape的描边,有四个属性. width描边的宽度, color描边的颜色, dashWidth组成虚线的线段的宽度, dashGap组成虚线的线段之间的间隔. \u003cpadding\u003e 这个表示空白, 但是他表示的不是shape的空白, 而是包含它的View的空白, 有上下左右四个属性 \u003csize\u003e Drawable有两个方法获得固有高度. getIntrinsicWidth(), getIntrinsicHeight(). 就是如果是图片Drawable那就是图片的属性大小. 如果不是那就是返回-1. 如果size标签设置了大小. 在方法返回的时候就不再是-1. 但是作为View的背景, shape还会被拉伸或者缩为View的大小. ","date":"2016-08-12","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-06-android%E7%9A%84drawable/:2:2","tags":["android","笔记"],"title":"《Android 开发艺术探索》 06-Android的Drawable","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-06-android%E7%9A%84drawable/"},{"categories":null,"content":"LayerDrawable 对应的标签是\u003clayer-list\u003e, 他表示一个层次化得Drawable集合.通过将不同的Drawable放置在不同的层面上从而达到一种叠加的效果. 一个这种标签可以包含多个item, 每个item表示一个Drawable. item的结构很简单上下左右四个属性加上id属性和drawable属性. 可以直接通过drawable属性引用一个Drawable也可以在标签写个子标签生成一个. ","date":"2016-08-12","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-06-android%E7%9A%84drawable/:2:3","tags":["android","笔记"],"title":"《Android 开发艺术探索》 06-Android的Drawable","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-06-android%E7%9A%84drawable/"},{"categories":null,"content":"StateListDrawable StateList对应\u003cselector\u003e标签, 也是Drawable集合. 这个我们经常使用在开发中的按钮状态选择器. \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cselector xmlns:android=\"http://schemas.android.com/apk/res/android\" android:constantSize=\"true\" android:dither=\"true\" android:variablePadding=\"false\" \u003e \u003c!-- 只是列举一下 \u003citem android:state_pressed=\"true\" android:drawable=\"xxx\"/\u003e \u003citem android:state_focused=\"true\" android:drawable=\"xxx\"/\u003e \u003citem android:state_hovered=\"true\" android:drawable=\"xxx\"/\u003e \u003citem android:state_pressed=\"true\" android:drawable=\"xxx\"/\u003e \u003citem android:state_selected=\"true\" android:drawable=\"xxx\"/\u003e \u003citem android:state_checkable=\"true\" android:drawable=\"xxx\"/\u003e \u003citem android:state_checked=\"true\" android:drawable=\"xxx\"/\u003e \u003citem android:state_enabled=\"true\" android:drawable=\"xxx\"/\u003e \u003citem android:state_activated=\"true\" android:drawable=\"xxx\"/\u003e \u003citem android:state_window_focused=\"true\" android:drawable=\"xxx\"/\u003e --\u003e \u003c/selector\u003e select标签对应有三个属性 constantSize: 用于StateListDrawable的固有大小是否不随着其状态改变而改变的, 因为状态的改变会切换不同的item的drawable, 而不同的drawable具有不同的固有大小. 如果为true那就是整个StateListDrawable固有大小是内部所有Drawable的最大固有大小的值. false会随之变化, 默认为false dither: 是否开启抖动效果, 默认为true variablePadding: 表示padding是否随着状态的改变而改变, padding取得值是所有Drawable的最大值. 默认为false. 不会随之改变. \u003citem\u003e标签也比较简单, 指定一个drawable,并加一个状态判断值. 下面给出常见的状态判断 状态 含义 android:state_pressed 表示按下状态, 比如Button被按下后没有松开时的状态 android:state_focused 表示View已经获取了焦点 android:state_selected 表示用户选择了View android:state_checked 表示用户选中了View, 一般适用于CheckBox这类在选中和非选中之间切换的 android:state_enabled 表示View当前是否可用 默认状态的一定要放在最后一条, 因为系统是按照从上到下的顺序查找. 只要找到任何一个匹配状态的那么久结束了. ","date":"2016-08-12","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-06-android%E7%9A%84drawable/:2:4","tags":["android","笔记"],"title":"《Android 开发艺术探索》 06-Android的Drawable","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-06-android%E7%9A%84drawable/"},{"categories":null,"content":"LevelListDrawable LevelListDrawable对应于\u003clevel-list\u003e标签, 也表示一个Drawable集合, 集合中每一个Drawable都有一个等级的概念, 根据不同的等级LevelListDrawable会切换不同的对应的Drawable. \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003clevel-list xmlns:android=\"http://schemas.android.com/apk/res/android\"\u003e \u003citem android:drawable=\"@mipmap/ic_sample\" android:maxLevel=\"2\" android:minLevel=\"2\"/\u003e \u003citem android:drawable=\"@mipmap/ic_launcher\" android:maxLevel=\"1\" android:minLevel=\"1\" /\u003e \u003c/level-list\u003e 这里就相当于给每一个Drawable设定一个标识. level-list会根据这个标识去自己的item中查找. 默认等级为0, Level的取值在0~10000. 在给每个Item声明等级的时候尽量最大和最小等级保持一致. 让每个item都可以有一个唯一标识等级, 而避免有一些公共拥有等级的Item导致出现和我们预期的不符. 如果作为了背景, 那么获得Drawable对象通过getLevel(), setLevel()来得到和设置不同的等级做到切换图片的效果. 如果是ImageView那么通过前景设置其等级就可以,一定别忘了把Drawable设置前景再通过这种方式实现. ","date":"2016-08-12","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-06-android%E7%9A%84drawable/:2:5","tags":["android","笔记"],"title":"《Android 开发艺术探索》 06-Android的Drawable","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-06-android%E7%9A%84drawable/"},{"categories":null,"content":"TransitionDrawable 对应着\u003ctransition\u003e标签, 它用于实现两个Drawable之间的淡入淡出效果. \u003ctransition xmlns:android=\"http://schemas.android.com/apk/res/android\"\u003e \u003citem android:drawable=\"@mipmap/ic_sample\"/\u003e \u003citem android:drawable=\"@mipmap/ic_launcher\"/\u003e \u003c/transition\u003e TransitionDrawable drawable = (TransitionDrawable) iv_main.getBackground(); drawable.startTransition(5000); 这个没什么好说的了, 很简单. 注意一下如果是给ImageView设置前景的话那么不要用getBackground()来获取了,通过getDrawable()来获取. ","date":"2016-08-12","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-06-android%E7%9A%84drawable/:2:6","tags":["android","笔记"],"title":"《Android 开发艺术探索》 06-Android的Drawable","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-06-android%E7%9A%84drawable/"},{"categories":null,"content":"InsetDrawable InsetDrawable对应\u003cinset\u003e标签, 它可以将其他Drawable内嵌到自己当中, 并可以在四周留出一定的距离. 当一个View希望自己的背景比自己的实际区域小的时候, 可以使用这个来实现.(相当于给使用的View增加了margin效果) LayerDrawable也可以实现此效果 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cinset xmlns:android=\"http://schemas.android.com/apk/res/android\" android:insetBottom=\"20dp\" android:insetTop=\"50dp\" android:insetRight=\"20dp\" android:insetLeft=\"20dp\"\u003e \u003cshape \u003e \u003csolid android:color=\"#ffff00\"/\u003e \u003c/shape\u003e \u003c/inset\u003e ","date":"2016-08-12","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-06-android%E7%9A%84drawable/:2:7","tags":["android","笔记"],"title":"《Android 开发艺术探索》 06-Android的Drawable","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-06-android%E7%9A%84drawable/"},{"categories":null,"content":"ScaleDrawable ScaleDrawable对应\u003cscale\u003e标签, 他可以根据自己的等级level将制定的Drawable缩放到一定比例. \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cscale xmlns:android=\"http://schemas.android.com/apk/res/android\" android:drawable=\"@mipmap/ic_sample\" android:scaleHeight=\"10%\" android:scaleWidth=\"10%\" android:scaleGravity=\"center\"\u003e \u003c/scale\u003e 并在代码中设置等级, 默认为0是不显示ScaleDrawable ScaleDrawable drawable = (ScaleDrawable) findViewById(R.id.activity_main).getBackground(); drawable.setLevel(1); 其中scaleHeight和scaleWidth需要的是百分比值. 有点别扭, 如果你设置了10%, 那么实际的意义就是缩放了原大小的10%, 相当于去掉了设置的值. 最终呈现出来的是1-设定的百分比. 就是展现了90%. 而设置的等级会影响最终的图片大小, 等级越大图片越大. 最好等级控制到0~10000 最后. ","date":"2016-08-12","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-06-android%E7%9A%84drawable/:2:8","tags":["android","笔记"],"title":"《Android 开发艺术探索》 06-Android的Drawable","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-06-android%E7%9A%84drawable/"},{"categories":null,"content":"ClipDrawable ClipDrawable对应于\u003cclip\u003e标签, 他可以根据自己当前的等级来裁剪Drawable, 裁剪的方向通过android:clipOrientation和android:gravity这两个属性来共同控制. \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cclip xmlns:android=\"http://schemas.android.com/apk/res/android\" android:clipOrientation=\"horizontal\" android:drawable=\"@mipmap/ic_sample\" android:gravity=\"center\"\u003e \u003c/clip\u003e 首先android:clipOrientation 如果参数添加水平 horizontal. 实际上是竖直切割, 保留垂直方向的完整. 如果是Vertical反之. 看图吧. 而gravity有的属性和BitmapDrawable中的gravity一样. 这里现在是android:clipOrientation=\"horizontal\"它是以水平方向做的垂直切割. 那么通过给gravity设置左 中 右就是left, center, right可以达到不同的效果. 如图 重要的一点还有动态代码设置等级, 要是不设置等级就是默认的0, 0就是切割掉100%的部分,所以剩下的部位为0也就是空的 ClipDrawable drawable = (ClipDrawable) findViewById(R.id.activity_main).getBackground(); drawable.setLevel(5000); 这个等级的数还是1~10000. 等级为0那么意味着裁剪Drawable的**100%**部分. 什么东西没有.空的 等级为5000那么意味着裁剪Drawable的**50%**部分, 我上面的演示的图片都是以等级为5000为标准测试的 等级为10000那么就意味的裁剪部分为Drawable的**100%**部分, 也就是完全显示了. 可以看出来了, 综合上面的看出, 上面的gravity的方向可以认为是从那边开始进行裁剪保留. ","date":"2016-08-12","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-06-android%E7%9A%84drawable/:2:9","tags":["android","笔记"],"title":"《Android 开发艺术探索》 06-Android的Drawable","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-06-android%E7%9A%84drawable/"},{"categories":null,"content":"自定义Drawable 一般Drawable都是作为View的背景图, 或者ImageView的显示图片. 其工作原理核心就是draw()方法. 而系统会调用Drawable的draw()来绘制View的背景, 所以我们通过重写draw()来实现自定义Drawable. 一般draw(), setAlpha(), setColorFilter(), 和getOpacity()都是要实现的 , draw()里面的具体实现和我们View的onDraw()很相似. 可以参考ShapeDrawable和BitmapDrawable的源码去仿造实现. 在自定义的时候注意: 如果要定义的Drawable有固有的大小值, 那么最好重写getIntrinsicWidth()和getIntrinsicHeight()这两个方法. 因为它会影响到View的wrap_content布局. 最后内部大小不一定等于Drawable的实际大小, Drawable实际大小可以通过getBound()来获取. 下一章: Andriod动画深入分析 ","date":"2016-08-12","objectID":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-06-android%E7%9A%84drawable/:3:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 06-Android的Drawable","uri":"/posts/android-%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-06-android%E7%9A%84drawable/"},{"categories":null,"content":" 第五章:桌面小部件和使用RemoteViews跨进程更新界面 blog相关代码 ","date":"2016-08-11","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-05-%E7%90%86%E8%A7%A3remoteviews/:0:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 05-理解RemoteViews","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-05-%E7%90%86%E8%A7%A3remoteviews/"},{"categories":null,"content":"RemoteView的应用 **简介:**在开发中, 通知栏都知道是通过NotificationManager的notify方法实现. 桌面小部件则是通过AppWidgetProvider实现. 后者本质上是一个广播.更新他们无法像以前那样.这是因为不是一个进程,小部件是SystemServer进程. 为了跨进程更新界面,RemoteViews提供了一系列的set方法… ","date":"2016-08-11","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-05-%E7%90%86%E8%A7%A3remoteviews/:1:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 05-理解RemoteViews","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-05-%E7%90%86%E8%A7%A3remoteviews/"},{"categories":null,"content":"RemoteViews通知栏的应用 先使用系统默认的样式. –! 先不记录notification了. 发现书上的方法在编译环境23版本以上无效. 23以下是没有问题的. notification.setLatestEventInfo()此方法已经被删除了. 贴出自定义布局通知栏代码利用remoteViews /** * 打开自定义布局的通知栏 */ private void displayRemoteViews() { Notification notification = new Notification(); notification.icon = R.mipmap.ic_launcher; notification.tickerText = \"我是小部件\"; notification.when = System.currentTimeMillis(); notification.flags = Notification.FLAG_AUTO_CANCEL; Intent intent = new Intent(getApplicationContext(), MainActivity.class); PendingIntent pedingIntent = PendingIntent.getActivity(getApplicationContext(), 0, intent, PendingIntent.FLAG_UPDATE_CURRENT); RemoteViews remoteViews = new RemoteViews(getPackageName(), R.layout.layout_notification); remoteViews.setTextViewText(R.id.tv_msg, \"我是文字信息\"); remoteViews.setImageViewResource(R.id.iv_icon, R.mipmap.favicon); notification.contentView = remoteViews; notification.contentIntent = pedingIntent; PendingIntent openActivity2PendingIntent = PendingIntent.getActivity(this, 0, new Intent(this, OpenActivity.class), PendingIntent.FLAG_UPDATE_CURRENT); remoteViews.setOnClickPendingIntent(R.id.tv_open, openActivity2PendingIntent); NotificationManager manager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE); manager.notify(2, notification); } 传入了一个自定义布局里面有一个imageView两个textView. 如下图: ","date":"2016-08-11","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-05-%E7%90%86%E8%A7%A3remoteviews/:1:1","tags":["android","笔记"],"title":"《Android 开发艺术探索》 05-理解RemoteViews","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-05-%E7%90%86%E8%A7%A3remoteviews/"},{"categories":null,"content":"RemoteView在桌面小部件上的应用 AppWidgetProvider是系统提供的用于实现桌面小部件的类, 继承BroadcaseReceiver.可以当成广播理解. 桌面小部件的开发步骤 1.定义小部件界面 在创建一个布局xml当做这个小部件要展示的样子 2.定义小部件配置信息 在res/xml文件夹下新建一个xxx_info.xml的文件 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cappwidget-provider xmlns:android=\"http://schemas.android.com/apk/res/android\" android:initialLayout=\"@layout/layout_widget\" android:minHeight=\"100dp\" android:minWidth=\"100dp\" android:updatePeriodMillis=\"60000\" \u003e \u003c/appwidget-provider\u003e initiaLayout: 小工具所要使用的初始化布局 minHeight``minWidth: 指定小工具的尺寸 updatePeriodMillis: 自动刷新的时间, 单位毫秒 3.定义小部件的实现类 /** * Created by suzeyu on 16/8/11. * 定义小部件的实现类 */ public class MyAppWidgetProvider extends AppWidgetProvider { public static final String TAG = MyAppWidgetProvider.class.getName(); public static final String CLICK_ACTION = \"com.szysky.note.androiddevseek_05.action.CLICK\"; @Override public void onReceive(final Context context, Intent intent) { super.onReceive(context, intent); Log.i(TAG, \"onReceive: 接收到广播--\u003e\"+intent.getAction()); //是触发的自己点击时发送的action那么就让小部件旋转 if (intent.getAction().equals(CLICK_ACTION)){ Toast.makeText(context, \"准备旋转\", Toast.LENGTH_SHORT).show(); AsyncTask.execute(new Runnable() { @Override public void run() { Bitmap srcBmp = BitmapFactory.decodeResource(context.getResources(), R.mipmap.favicon); AppWidgetManager widgetManager = AppWidgetManager.getInstance(context); for (int i = 0; i \u003c 37; i++) { float degree = (i * 10) % 360; RemoteViews remoteViews = new RemoteViews(context.getPackageName(), R.layout.layout_widget); remoteViews.setImageViewBitmap(R.id.iv_main, rotateBmp(context, srcBmp, degree)); if (i==36){ Intent intentClick = new Intent(); intentClick.setAction(CLICK_ACTION); PendingIntent peddingIntent = PendingIntent.getBroadcast(context, 0, intentClick, 0); remoteViews.setOnClickPendingIntent(R.id.iv_main, peddingIntent); } widgetManager.updateAppWidget(new ComponentName(context, MyAppWidgetProvider.class), remoteViews); SystemClock.sleep(50); } } }); } } /** * 旋转一个bitmap */ private Bitmap rotateBmp(Context context, Bitmap srcBmp, float degree) { Matrix matrix = new Matrix(); matrix.reset(); matrix.setRotate(degree); return Bitmap.createBitmap(srcBmp, 0, 0, srcBmp.getWidth(), srcBmp.getHeight(), matrix, true); } /** * 当自定义的小桌面被添加 这个方法只有在本实例中只有被添加的时候才调用 */ @Override public void onUpdate(Context context, AppWidgetManager appWidgetManager, int[] appWidgetIds) { super.onUpdate(context, appWidgetManager, appWidgetIds); final int counter = appWidgetIds.length; Log.i(TAG, \"小桌面更新了 counter=\"+counter); for (int i = 0; i \u003c counter; i++) { int appWidgetID = appWidgetIds[i]; onWidgetUpdate(context, appWidgetManager, appWidgetID); } } /** * 桌面小部件更新 这个方法只有在本实例中只有被添加的时候才调用 */ private void onWidgetUpdate(Context context, AppWidgetManager appWidgetManager, int appWidgetID) { Log.i(TAG, \"onWidgetUpdate: id==\"+appWidgetID); RemoteViews remoteViews = new RemoteViews(context.getPackageName(), R.layout.layout_widget); remoteViews.setImageViewBitmap(R.id.iv_main, BitmapFactory.decodeResource(context.getResources(), R.mipmap.favicon)); Intent intentClick = new Intent(); intentClick.setAction(CLICK_ACTION); PendingIntent pendingIntent = PendingIntent.getBroadcast(context, 0, intentClick, 0); remoteViews.setOnClickPendingIntent(R.id.iv_main, pendingIntent); appWidgetManager.updateAppWidget(appWidgetID, remoteViews); } } 直接说用途把, 小部件被添加到桌面的时候, 会先走onUpdate()回调,这个时候执行方法通过RemoteViews()构建一个布局,并更新桌面上新的布局和设置了点击事件,然后走onReceive() . 如果当我们点击的小部件的时候, 会触发广播中的onReceive()然后进行图片的旋转.这就是上述代码的大体流程. 4.最后要在清单文件中声明小部件 \u003creceiver android:name=\".MyAppWidgetProvider\"\u003e \u003cmeta-data android:name=\"android.appwidget.provider\" android:resource=\"@xml/widget_provider_info\"/\u003e \u003cintent-filter\u003e \u003caction android:name=\"android.appwidget.action.APPWIDGET_UPDATE\"/\u003e \u003caction android:name=\"com.szysky.note.androiddevseek_05.action.CLICK\"/\u003e \u003c/intent-filter\u003e \u003c/receiver\u003e 第一个action则是作为小部件的表示而必须存在的. 第二个action就是要识别设定的单击行为. 然后就可以在主屏幕上长按添加小部件查看效果了 嫌麻烦就直接扣代码,这是链接 AppWidgetProvider这个类还有其他生命周期的回调, 其实就是当广播到来之后, AppWidgetProvider会自动根据广播的Action通过","date":"2016-08-11","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-05-%E7%90%86%E8%A7%A3remoteviews/:1:2","tags":["android","笔记"],"title":"《Android 开发艺术探索》 05-理解RemoteViews","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-05-%E7%90%86%E8%A7%A3remoteviews/"},{"categories":null,"content":"PendingIntent概述 PendingIntent和Intent的区别: PendingIntent: 等待意图, 有一个Intent将在某个待定的时刻发生. Intent: 是立刻发生. 使用场景 最典型的就是给RemoteViews添加单击事件, 因为RemoteViews运行在远程进程中, 因此RemoteViews不同于普通的View, 所以无法直接向View那样通过setOnClickListener()方法那样设置单击事件. 要想给RemoteViews设置单击事件, 就必须使用PendingIntent, PendingIntent通过send()和cancel()来发送和取消特定的待定Intent. PendingIntent支持三种待定意图: 启动Activity, 启动Service, 和发送广播 对应着PendingIntent三个静态方法 getActivity(),getService(), getBroadCast(). 当这三种方法返回的PendingIntent待定意图发生时候, 对应的效果就是我们日常开启这三大组件的情形. 上述三个方法都需要四个参数. 需要说一下第二个参数requestCode和第四个参数flags. 其中requestCode表示PendingIntent发送方的请求码, 多数情况下设为0即可, 另外requestCode会影响到flags的效果. flags: 常用的类型有: FLAG_ONE_SHOT, FLAG_UPDATE_CURRENT, FLAG_NO_CREATE, FLAG_CANCEL_CURRENT. 在此之前首先要明确一个概念, PendingIntent的匹配规则, 在什么情况下两个PendingIntent是相同的. PendingIntent匹配规则: 如果两个PendingIntent的内部Intent相同并且requestCode也相同那么这两个PendingIntent就是想同的. requestCode是int值不需要解释. 而Intent匹配规则是: 如果两个Intent的ComponentName和intent-filter都相同, 那么这两个Intent就是相同的. Extras是不参与Intent的匹配规则. FLAG_ONE_SHOT: 当前描述的PendingIntent只能被使用一次, 然后它就会被自动cancle, 如果后续还有相同的PendingIntent, 那么它们的send方法就会调用失败. 对于通知栏消息来说, 如果采用此标记, 那么同类的通知只能使用一次, 后续的通知单击后将无法打开. FLAG_NO_CREATE: 当前描述的PendingIntent不会主动创建, 如果当前PendingIntent之前不存在, 那么getActivity, getService, getBroadcast方法会直接返回null, 即获取PendingIntent失败. 这个标记很少见, 它无法单独使用,因此日常中没有太多意义. FLAG_CANCEL_CURRENT: 当前描述的PendingIntent如果已经存在, 那么他们都会被cancel, 然后系统会创建一个新的PendingIntent. 对于通知栏消息来说, 那些被cancel的消息单击后将无法打开. FLAG_UPDATE_CURRENT: 当前描述的PendingIntent如果已经存在, 那么他们都会自动被更新, 即它们的Intent中的Extra会被换成新的. 规则说了接下来结合实际使用说明: 如果manager.notify(1, notification),如果参数1的id是常量,那么多次调用notify()只能弹出一个通知, 后续的通知会把前面的通知全部替代, 如果每次id都是不一样的, 那么多次调用notify()就会弹出多个通知. 所以如果notify()是常量, 那么不管PendingIntent是否匹配, 后面的通知都会直接替换前面的通知. 如果notify()每次不同, 那么当pendingIntent不匹配时(这里指的匹配就是上面介绍的Intent和requestCode是否同时相同), 不管采用何种标记, 这些通知之间都不会互相干扰. 但是如果PendingIntent匹配时就要用到去按照之前说的标记区别来划分 FLAG_ONE_SHOT–\u003e 那么后续通知中的PendingIntent会和第一条通知保持一致, 包括Extras, 单击任何一条通知后, 剩下的通知均无法再打开, 当所有的通知都被清除后, 会再次重复这个过程. FLAG_CANCEL_CURRENT–\u003e 那么只有最新的通知可以打开, 之前弹出的所有通知均无法打开 FLAG_UPDATE_CURRENT–\u003e 那么之前弹出的通知中的PendingIntent会被更新, 最终他们和最新的一条通知保持完全的一致, 包括其中的Extras,并且这些通知都是可以打开的. ","date":"2016-08-11","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-05-%E7%90%86%E8%A7%A3remoteviews/:1:3","tags":["android","笔记"],"title":"《Android 开发艺术探索》 05-理解RemoteViews","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-05-%E7%90%86%E8%A7%A3remoteviews/"},{"categories":null,"content":"RemoteViews的内部机制 RemoteViews的作用是在其他进程中显示并更新View界面. 最常用的构造函数就是public RemoteViews(String packageName, int layoutId), 注意RemoteViews目前并不能支持所有的View类型, 目前支持如下(不包括其子类): Layout FrameLayout, LinearLayout, RelativeLayout, GridLayout View TextView, ImageView, ImageButton, Button, AnalogClock, Chronometer, ProgressBar, ViewFlipper, ListView, GridView, StackView, AdapterViewFlipper, ViewStub RemoteViews没有提供findviewById()方法, 只有一系列的set()方法. 方法名 作用 setTextViewText() 设置TextView的文本 setTextViewSize() 设置TextView的字体大小 setTextColor() 设置TextView的字体颜色 setImageViewResource() 设置imageView的图片资源 setImageViewBitmap() 设置imageView的图片 setInt() 反射调用View对象的参数类型为int的方法 setLong() 反射调用View对象的参数类型为long的方法 setBoolean() 反射调用View对象的参数类型为boolean的方法 setOnClickPendingIntent() 为View添加单击事件, 事件类型只能PendingIntent RemoteViews的工作流程 通知栏和桌面小部件分别由NotificationManager和AppWidgetManager管理, 而这两个管理者都是通过Binder分别和SystemServer进程中的NotificationManagerService以及AppWidgetService进行通信. 由此可见,通知栏和桌面小部件中的布局文件实际上是在NotificationManagerService以及AppWidgetService中被加载的, 而他们运行在系统的SystemServer中, 这就和我们的进程构成了进程间通信. 最开始RemoteViews会通过Binder传递到SystemServer进程, RemoteViews实现了Parcelable接口. 系统根据RemoteViews中的包名等信息去得到该应用的资源, 然后通过LayoutInflate去加载RemoteViews中的布局文件. 在SystemServer进程中加载后的布局文件是一个普通的View, 只不过相对于我们的进程他是一个RemoteViews而已. 接着系统会对View执行一系列界面更新任务, 这些任务就是之前的设置的set(). set方法对View所做的更新不是立即执行, 在RemoteViews内部会记录所有的更新操作, 具体的执行时机要等到RemoteViews被加载以后才能执行, 这样RemoteViews就可以在SystemServer进程中显示, 这就是我们看到的通知栏或者桌面小部件. 当需要更新RemoteViews时, 我们需要调用set方法并通过NotificationManager和AppWidgetManager来提交更新任务, 具体的更新操作也是在SystemServer进程中完成的. 为什么不支持所有的View和其操作? 因为代价太大, View的方法太多, 另外就是大量的IPC操作会影响效率. 为了解决这个问题, 系统并没有通过Binder直接支持View的跨进程访问, 而是提供了一个Action的概念, Action代表一个View操作, Action同样实现了Parcelable接口. 系统首先将View操作封装到Action对象并将这些对象跨进程传输到远程进程, 接着在远程进程中执行Action对象中的具体操作. 在我们的应用中每调用一次set(), RemoteViews中就会添加一个对应的Action对象, 当我们通过NotificationManager和AppWidgetManager来提交我们的更新时, 这些Action对象就会传输到远程进程并在远程进程中一次执行. 如图 远程进程通过RemoteViews的apply方法来进行View的更新操作, RemoteViews的apply方法内部则会去遍历所有的Action对象并调用他们的apply方法, 具体的View更新操作是由Action对象的apply方法来完成的. 上述做法的好处是显而易见的, 首先不需要定义大量的Binder接口, 其次通过远程进程中批量执行RemoteViews的修改操作从而避免了大量的IPC操作, 这就提高了程序的性能. 接下来从源码角度分析. 首先最长用到的setTextViewText(),源码如下 public void setTextViewText(int viewId, CharSequence text) { setCharSequence(viewId, \"setText\", text); } 接收的参数比较简单,继续跟进setCharSequence()方法. public void setCharSequence(int viewId, String methodName, CharSequence value) { addAction(new ReflectionAction(viewId, methodName, ReflectionAction.CHAR_SEQUENCE, value)); } 从这里实现看到, 内部并没有对View进程直接的操作, 而是添加一个ReflectionAction()一个看名字类似反射类型的对象. 接下看addAction() private void addAction(Action a) { //省略部分代码... if (mActions == null) { mActions = new ArrayList\u003cAction\u003e(); } mActions.add(a); // update the memory usage stats a.updateMemoryUsageEstimate(mMemoryUsageCounter); } 这里看到, 在RemoteViews内部有一个mActions成员, 它是一个ArrayList, 外界每调用一次set(), RemoteViews就会为其创建一个Action对象并加入到这个集合中, 这里仅仅将Action对象保存了起来, 并未对View进行实际的操作, 这一点在上面的理论分析中已经提到过. 接下来再看ReflectionAction的实现之前, 先看一下RemoteViews的apply()方法以及Action类的实现. public View apply(Context context, ViewGroup parent, OnClickHandler handler) { RemoteViews rvToApply = getRemoteViewsToApply(context); View result; final Context contextForResources = getContextForResources(context); Context inflationContext = new ContextWrapper(context) { @Override public Resources getResources() { return contextForResources.getResources(); } @Override public Resources.Theme getTheme() { return contextForResources.getTheme(); } @Override public String getPackageName() { return contextForResources.getPackageName(); } }; LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE); // Clone inflater so we load resources from correct context and // we don't add a filter to the static version returned by getSystemService. inflater = inflater.cloneInContext(inflationContext); inflater.setFilter(this); result = inflater.inflate(rvToApply.getLayoutId(), parent, false); rvToApply.performApply(result, parent, handler); return result; } 这段代码首先","date":"2016-08-11","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-05-%E7%90%86%E8%A7%A3remoteviews/:2:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 05-理解RemoteViews","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-05-%E7%90%86%E8%A7%A3remoteviews/"},{"categories":null,"content":"RemoteViews的意义 可以模拟一个通知栏效果并实现跨进程的UI更新. 恩, 详情去看书吧, 不写了在书的239页 下一章: Android中的 Drawable ","date":"2016-08-11","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-05-%E7%90%86%E8%A7%A3remoteviews/:3:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 05-理解RemoteViews","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-05-%E7%90%86%E8%A7%A3remoteviews/"},{"categories":null,"content":" 拨开炫酷的外表, 看看衣服里面的View是怎样工作的 blog相关代码 ","date":"2016-08-10","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-04-view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:0:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 04-view的工作原理","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-04-view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"ViewRoot和DecorView 这是在View三大流程之前(measure, layout, draw),需要了解的概念. ViewRoot对应于ViewRootImpl, 它是连接WindowManager和DecorView的纽带. View的三大流程都是通过ViewRoot来完成的. 当一个Activity对象在ActivityThread被创建后. 会将DecorView添加到Window中, 同时会创建ViewRootImp对象, 并将ViewRootImpl对象和DecorView建立关联. View绘制流程是从ViewRoot的PerformTraversals()开始的. 经过三大流程才能将一个View绘制出来. PerformTraversals()会依次调用performMeasure, performLayout, performDraw. 而前两种内部的调用基本一致,都是先调用measure()/layout(),然后再调用onMeasure()/onLayout()在这个方法中会对所有子元素进行测量和绘制.依次向内部传递. performDraw()有点不同是在draw调用的dispatchDraw(). measure过程: 决定了View宽高, measure后可以通过getMeasureWidth和getMeasureHeight来获取View的宽高. 一般情况下是最终宽高. layout过程: 决定了View的顶点坐标和实际View的宽高. 完成后通过getTop, getBottom, getLeft, getRight获得四个顶点, 通过getWidth,和getHeight获得宽高 draw过程: 只有draw()方法完成之后View的内容才会显示出来. setContentView(R.layout.activity_inside_intercept); ((ViewGroup) getWindow().getDecorView().findViewById(android.R.id.content)).getChildAt(0); 上面第一行可以说无时无刻不存在. 而下面这行在上一章说过就是获得我们设置的布局.那DecorView布局究竟是怎么样的, 下图. DecorView就是一个FrameLayout. 而一般情况下它的布局就如上面图那样(具体和主题有关系). 而我们经常setContentView(xxx). 就是把我们编写的xml的布局添加到了DecorView的android.R.id.content的控件布局中. 所以也就能说通为什么getChildAt(0)会获得我们的的布局. 并且为什么我们用的关联布局的方法是setContent… ","date":"2016-08-10","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-04-view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:1:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 04-view的工作原理","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-04-view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"MeasureSpec 很大程度上决定一个View的尺寸规格, 之所以不是绝对, 是因为这个过程还受父容器的影响. ","date":"2016-08-10","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-04-view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:2:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 04-view的工作原理","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-04-view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"理解MeasureSpec MeasureSpec本身是一个32位的int值, 但是却表示了两种信息. 高2位: 代表了SpecMode, 测量模式 低30位: 代表了SpecSize, 在上述测量模式中的大小 public static class MeasureSpec { private static final int MODE_SHIFT = 30; private static final int MODE_MASK = 0x3 \u003c\u003c MODE_SHIFT; public static final int UNSPECIFIED = 0 \u003c\u003c MODE_SHIFT; public static final int EXACTLY = 1 \u003c\u003c MODE_SHIFT; public static final int AT_MOST = 2 \u003c\u003c MODE_SHIFT; public static int makeMeasureSpec(int size, int mode) { if (sUseBrokenMakeMeasureSpec) { return size + mode; } else { return (size \u0026 ~MODE_MASK) | (mode \u0026 MODE_MASK); } } public static int makeSafeMeasureSpec(int size, int mode) { if (sUseZeroUnspecifiedMeasureSpec \u0026\u0026 mode == UNSPECIFIED) { return 0; } return makeMeasureSpec(size, mode); } public static int getMode(int measureSpec) { return (measureSpec \u0026 MODE_MASK); } public static int getSize(int measureSpec) { return (measureSpec \u0026 ~MODE_MASK); } ..... } 是不是挺有意思. 三种类型分别高二位01, 00, 10来代表. 直接利用位运算. 来实现可以让频繁计算的东西使用最接近计算机的运算方式. 不需要额外的转换. 也避免了过多的对象内存分配. 说一下SpecMode的三种模式 UNSPECIFIED: 父容器不对View有任何的限制,要多大就给多大, 这种情况一般用于系统内部,表示一中测量状态 EXACTLY: 父容器已经检测出View所需要的精确大小, 这个时候View的最终大小就是SpecSize所指定的值. 对应着LayoutParams中的match_parent和具体的数值. AT_MOST: 父容器制定了一个可用的大小及SpecSize, View的大小不能超过这个值, 它对应与LayoutParams中的wrap_content ","date":"2016-08-10","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-04-view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:2:1","tags":["android","笔记"],"title":"《Android 开发艺术探索》 04-view的工作原理","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-04-view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"MeasureSpec和LayoutParams关系 通常设置的LayoutParams,系统会在父容器的的约束下转换成对应的MeasureSpec,然后根据这个MeasureSpec来确定View测量后的宽高. 所以View自身的MeasureSpec是需要LayoutParams和父容器一起组合生成的. 上面讲述的是普通View, 但是顶级View(DecorView)有所不同. DecorView是物理窗口尺寸和自身的LayoutParams决定的. 具体在ViewRootImpl类measureHierarchy()进行生成的. MeasureSpec一旦确定, onMeasure中就可以测量View的宽高. 对于我们日常操作的View View的measure过程是由ViewGroup传递而来的. 看ViewGroup#measureChildWithMargins()方法 protected void measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed) { final MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams(); final int childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec, mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin + widthUsed, lp.width); final int childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec, mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin + heightUsed, lp.height); child.measure(childWidthMeasureSpec, childHeightMeasureSpec); } 上面会对子元素进行measure, 而在此之前,会通过getChildMeasureSpec()来得到子元素的MeasureSpec. 通过调用方法传入的参数看到. 生成View的MeasureSpec和父容器的MeasureSpec, View自身方向的padding``margin, 和自身的LayoutParams这三个因素相关联. 而其中的getChildmeasureSpec()方法: 就是根据父容器的MeasureSpec同时结合View自身的LayoutParams来确定子元素的MeasureSpec.这个方法总结如下: dp/px: 不管父容器的MeasureSpec是什么. View都是EXACTLY(精确模式), 而大小遵循自身LayoutParams的大小. match_parent: 如果父容器是EXACTLY(精确模式),那么子View也是EXACTLY(精确模式)并且大小是父容器的剩余空间. 如果父容器是AT_MOST(最大模式),那么子View也是AT_MOST(最大模式)并且大小不会超过父容器的剩余空间. wrap_content: 不管父容器是什么. View都是AT_MOST(最大模式), 并且大小不能超过父容器剩余空间. 上述没有说明UNSPECIFIED在match_parent和wrap_content中. 因为这个模式主要用于系统多次Measure的情形,一般来说不需要关注. ","date":"2016-08-10","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-04-view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:2:2","tags":["android","笔记"],"title":"《Android 开发艺术探索》 04-view的工作原理","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-04-view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"View的工作流程 主要指measure, layout, draw三大流程. 即测量,布局,绘制. ","date":"2016-08-10","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-04-view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:3:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 04-view的工作原理","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-04-view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"measure过程 这里面存在两种场景: View: 通过了measure方法就完成了测量过程 ViewGroup: 除了测量自己,还会遍历去调用所有子元素的measure方法. 各个子元素在递归去执行这个流程 View的measure过程 View的measure过程由其measure()方法来完成, measure()方法是一个final类型, 而在内部调用了onMeasure()这个可不是final, 所以也可以自定义的时候复写. 看一下内部. protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec), getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec)); } setMeasureDimension()会设置View宽高的测量值. 这里需要看一下getDefaultSize()这个方法. public static int getDefaultSize(int size, int measureSpec) { int result = size; int specMode = MeasureSpec.getMode(measureSpec); int specSize = MeasureSpec.getSize(measureSpec); switch (specMode) { case MeasureSpec.UNSPECIFIED: result = size; break; case MeasureSpec.AT_MOST: case MeasureSpec.EXACTLY: result = specSize; break; } return result; } 看到如果这个view是EXACTLY(精准模式), 那么返回的大小就是SpecSize. UNSPECIFIED一般用于系统测量先不说. 而AT_MOST(最大模式)的时候. 虽然是不同模式但是默认情况下和精确模式是一样的结果. getSuggestedMinimumWidth()和getSuggestedMinimumHeight(). 看一下实现. protected int getSuggestedMinimumWidth() { return (mBackground == null) ? mMinWidth : max(mMinWidth, mBackground.getMinimumWidth()); } protected int getSuggestedMinimumHeight() { return (mBackground == null) ? mMinHeight : max(mMinHeight, mBackground.getMinimumHeight()); } 首先会看是否设置了背景. 无背景: 那么宽度为mMinWidth,这个值对应布局中的android:minWidth属性,默认为0. 有背景: 那么取mMinWidth和mBackground.getMinimumHeight()最大值. 而getMinimumHeight()根据看一下: public int getMinimumHeight() { final int intrinsicHeight = getIntrinsicHeight(); return intrinsicHeight \u003e 0 ? intrinsicHeight : 0; } 原来getMinimumHeight()返回的就是Drawable的原始高度. 如果没有就返回0. 关于原始高度举个例子ShapeDrawable无原始宽高, BitmapDrawble有原始宽高就是图片的尺寸. 整理getDefaultSize(): 直接继承View的自定义控件需要重写onMeasure()方法并设置wrap_content时的自身大小,否则在布局中使用wrap_content虽然View自身的MeasureSpec的低30位保存了父容器计算自身的剩余大小. 但是在自定义的时候如果不进行处理wrap_content,那么就会调用默认setMeasureDimension()方法. 而默认中方法的实参传递的是getDefaultSize()这个方法中对AT_MOST这种模式没有处理. 直接沿用和精确模式的大小(相当于设置了wrap_content却得到了match_parent的显示结果) 可以针对这个问题, 做出对应的编码进行解决: @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { super.onMeasure(widthMeasureSpec, heightMeasureSpec); int widthSpaceSize = MeasureSpec.getSize(widthMeasureSpec); int widthSpaceMode = MeasureSpec.getMode(widthMeasureSpec); int heightSpaceSize = MeasureSpec.getSize(heightMeasureSpec); int heightSpaceMode = MeasureSpec.getMode(heightMeasureSpec); //设置两个默认值宽高 int defaultHeight = 100; int defaultWidth = 100; // 针对AT_MOST模式进行特殊处理 if (widthSpaceMode == MeasureSpec.AT_MOST \u0026\u0026 heightSpaceMode == MeasureSpec.AT_MOST){ setMeasuredDimension(defaultWidth, defaultHeight); }else if (widthSpaceMode == MeasureSpec.AT_MOST){ setMeasuredDimension(defaultWidth, heightSpaceSize); }else if (heightSpaceMode == MeasureSpec.AT_MOST){ setMeasuredDimension(widthMeasureSpec, defaultHeight); } } ViewGroup的Measure 对于ViewGroup不光会测量自己,还会遍历调用所有的子元素的measure(). 和View不同的是ViewGroup是一个抽象类,它没有重写onMeasure,但提供了measureChildren()的方法. 这个measureChildren()方法内部比较简单就是遍历自己的孩子然后调用-\u003emeasureChild() 这个measureChild()这个方法前面贴过源码. 就是取出子元素的LayoutParams,并调用-\u003egetChildMeasureSpec(). 通过传入子元素的LayoutParams里面的宽高属性, 子元素的padding和margin, 父元素当前(当前ViewGroup)的MeasureSpec属性来计算出子元素的MeasureSpec最后调用-\u003echild.measure()传入之前计算的测量规格. ViewGroup为什么没有定义测量的具体过程? 因为具体的测量过程需要交给子类去实现的. 比如LinearLayout,RelativeLayout. 看一下LinearLayout的onMeasure()是如何定义的. @Override protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) { if (mOrientation == VERTICAL) { measureVertical(widthMeasureSpec, heightMeasureSpec); } else { measureHorizontal(widthMeasureSpec, heightMeasureSpec); } } 根据设置的排列方式这里分之了两种测量方法. 稍微看一下大概轮廓,选择measureVertical()不贴源码了这个方法300行呢! 首先这个方法会遍历每个子元素并执行-\u003emeasureChildBeforeLayout()方法.这个方法内部会调用子元素的measure(), 这样子元素会依次测量. 并且会通过mTotalLenght这个变量来存储LinearLayout在竖直方向上的初步高度, 每测量一个就会增加. 当子元素测量完之后,LinearLayout会测量自己的大小. 在对自己进行测量的时候. 如果布局中的高度采用的是match_parent或者具体数值, 那么它的测量过程和View一样,即高度为specSize. 如果布局中采用wrap_content那么高度就是所有的子元素总和但是不能超过父元素剩余空间, 还有竖直方向LinearLayout的padding. 具体可参考resolveSizeAndSta","date":"2016-08-10","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-04-view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:3:1","tags":["android","笔记"],"title":"《Android 开发艺术探索》 04-view的工作原理","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-04-view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"正确获取宽高方法 首先明确一点:View的measure和Activity的生命周期方法不是同步执行.所以无法保证在某个生命周期(onCreate,onStart)获取到正确的测量宽高 onWindowFocusChanged() view.post(runnable) ViewTreeObserve view.measure() onWindowFocusChanged():View已经初始化完毕,宽高已经准备好. 这里需要注意只要Activity的焦点发生变化此方法就会被调用.所以如果你的界面会频繁的进行onPause和onResume.并且里面有很多关联依赖的方法. 那就请注意这不是一个好办法. 通过post可以将一个runnable投递到消息队列的尾部,然后等待Looper调用此runnable的时候.View已经初始化完毕. 使用ViewTreeObserver. 当View的可见性发生了改变的时候.onGlobalLayout()将发生回调.注意伴随着View树的状态改变等,这个回调方法可能会被调用多次. 使用代码如下 ViewTreeObserver viewTreeObserver = tv_main.getViewTreeObserver(); viewTreeObserver.addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() { @Override public void onGlobalLayout() { tv_main.getViewTreeObserver().removeOnGlobalLayoutListener(this); tv_main.getMeasuredHeight(); tv_main.getMeasuredWidth(); } }); view.measure(widthMeasureSpec, heightMeasureSpec) 也可以手动进行测量,但是需要分情况处理. match_parent 当View是此属性的时候无法使用measure(),首先使用这种方法需要的参数,是通过父容器和子元素组合来生成的子元素的MeasureSpec属性. 所以在外部我们不知道父元素的参数值得时候只能处理不需要父元素数据就可以生成子元素的MeasureSpec的模式 所以很清楚, 这个match_patch这个模式,在给其子元素构造MeasureSpec的时候需要得值parentSize,所以得到的也是无效. 具体数值px/dx 假设这里是100px, 首先构成宽高对应的MeasureSpec属性 int widthSpec = View.MeasureSpec.makeMeasureSpec(100, View.MeasureSpec.EXACTLY); int heightSpec = View.MeasureSpec.makeMeasureSpec(100, View.MeasureSpec.EXACTLY); tv_main.measure(widthSpec, heightSpec); wrap_content int widthSpec = View.MeasureSpec.makeMeasureSpec(((1 \u003c\u003c 30)-1), View.MeasureSpec.AT_MOST); int heightSpec = View.MeasureSpec.makeMeasureSpec(((1 \u003c\u003c 30)-1), View.MeasureSpec.AT_MOST); tv_main.measure(widthSpec, heightSpec); 通过(1«30)-1 可以构成一个MeasureSpec低30位的最大值. 用理论上View能支持的最大值去构造 关于网上一些在make的使用传入UNSPECIFIED,属于违背了内部实现的规范.不用最好 关于网上另一种measure()直接传入LayoutParams.WRAP_CONTENT. 其实也只有当子元素为wrap_content和子元素为match_parent并且父元素是wrap_conetnt时会碰巧有效. ","date":"2016-08-10","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-04-view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:3:2","tags":["android","笔记"],"title":"《Android 开发艺术探索》 04-view的工作原理","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-04-view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"layout过程 在ViewGroup中会先通过layout()方法确定本身的位置. 然后调用onLayout()方法遍历所有的子元素,并调用子元素的layout()方法确定子元素的位置…依次循环. 提出View的layout方法, 这里抽取部分代码 public void layout(int l, int t, int r, int b) { int oldL = mLeft; int oldT = mTop; int oldB = mBottom; int oldR = mRight; boolean changed = isLayoutModeOptical(mParent) ? setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b); if (changed || (mPrivateFlags \u0026 PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) { onLayout(changed, l, t, r, b);} } 这样来看,大致流程通过setFrame()方法来设定View的四个顶点的位置, 即mLeft,mTop,mBottom,mRight,这四个顶点一旦确定.当前View的位置也就确定. 然后会调用onLayout()方法. 这个方法是确定子元素的View位置. 这里的和onMeasure()类似, onLayout()具体实现和具体的布局有关, 所以View和ViewGroup均没有真正实现onLayout()方法. 看一下LinearLayout的onLayout()源码 @Override protected void onLayout(boolean changed, int l, int t, int r, int b) { if (mOrientation == VERTICAL) { layoutVertical(l, t, r, b); } else { layoutHorizontal(l, t, r, b); } } 和onMeasure()一样分支,接下来跟进layoutVertical()贴出主要代码 void layoutVertical(int left, int top, int right, int bottom) { //省略一部分... for (int i = 0; i \u003c count; i++) { final View child = getVirtualChildAt(i); if (child == null) { childTop += measureNullChild(i); } else if (child.getVisibility() != GONE) { final int childWidth = child.getMeasuredWidth(); final int childHeight = child.getMeasuredHeight(); final LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) child.getLayoutParams(); int gravity = lp.gravity; if (gravity \u003c 0) { gravity = minorGravity; } //省略一部分... if (hasDividerBeforeChildAt(i)) { childTop += mDividerHeight; } childTop += lp.topMargin; setChildFrame(child, childLeft, childTop + getLocationOffset(child), childWidth, childHeight); childTop += childHeight + lp.bottomMargin + getNextLocationOffset(child); i += getChildrenSkipCount(child, i); } } } 上面代码大体逻辑: 首先遍历所有孩子并调用setChildFrame()来为子元素指定对应的位置. 其中childTop会逐渐增大, 这就意味着后面的子元素会被放置在靠下的位置. 而setChildFrame()内部仅有一行代码, 就是调用子元素的layout()并传入它自身应该存放的位置. private void setChildFrame(View child, int left, int top, int width, int height) { child.layout(left, top, left + width, top + height); } 而在setChildFrame()中传入的宽高就是子元素的测量宽高. 而在子元素的layout()中通过setFrame()来设置元素的四个顶点. getWidth()layout中的宽 和getMeasureWidth()中的宽永远一样么? 在一般情况下,测量measure和layout时候的值是完全一样的. 因为layout()中接受的参数就是通过测量的结果获取到的. 并且内部直接通过setFrame()赋值到自己的四个成员变量上. 但是如果对layout()进行了复写.如下 @Override protected void layout(int l, int t, int r, int b) { super.layout( l, t+200, r, b+200); } 如果进行了这样的复写, 那么最终宽高永远会与测量的出来的值相差200. ","date":"2016-08-10","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-04-view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:3:3","tags":["android","笔记"],"title":"《Android 开发艺术探索》 04-view的工作原理","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-04-view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"draw过程 这个过程只是将View绘制到屏幕上面. 绘制背景background.draw(canvas) 绘制自己onDraw() 绘制childrendispatchDraw() 绘制装饰onDrawScrollBars() View绘制过程传递是通过dispatchDraw()实现的. 传递了自己的画布. 这个方法会遍历子元素并且调用元素的draw() View一个特有的方法setWillNotDraw(), 这个方法是设置了true那么系统会进行相应的优化. 在View中默认是关闭的. 而ViewGroup默认是开启的. 如果我们继承了自定义ViewGroup如果还需要绘制自己的内容那么需要显示的关闭此标记. ","date":"2016-08-10","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-04-view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:3:4","tags":["android","笔记"],"title":"《Android 开发艺术探索》 04-view的工作原理","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-04-view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"自定义View ","date":"2016-08-10","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-04-view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:4:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 04-view的工作原理","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-04-view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"自定义View的分类 相关代码 1.继承View重写onDraw方法 这种方法主要用于实现一些不规则的效果, 不方便组合布局实现,或者又有动态显示的一些图形. 需要自己绘制那么就重写onDraw()方法. 这种方法需要自己支持wrap_content和padding 2.继承ViewGroup派生特殊Layout 这种方式用于实现自定义布局, 这种布局的实现稍微复杂,需要合适的处理ViewGroup的测量,布局这两个过程,并同时处理子元素的测量和布局过程. 3.继承特定的View(TextView) 比较常见, 一般用于扩展已有的View的功能. 这种不需要自己处理wrap_content和padding 4.继承特定ViewGroup(LinearLayout) 当某种效果看起来像几种View的组合在一起的时候,可以采用这种方式. 这种方式不需要自己处理ViewGroup的测量和布局. 其实这种方式和2没什么区别, 主要是2更接近于底层的View实现. ","date":"2016-08-10","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-04-view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:4:1","tags":["android","笔记"],"title":"《Android 开发艺术探索》 04-view的工作原理","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-04-view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"自定义View的须知 让View支持wrap_content 最好让你的View支持padding -\u003e 如果直接继承View,在draw()中不处理padding,那么属性是无法起作用的. 还有继承ViewGroup的控件需要在onMeasure和onLayout中考虑padding和子元素的margin会造成的影响. 尽量不要在View中使用Handler -\u003e 内部已经提供了post系列方法. 除非很明确要是用Handler发送消息. View中如果有线程或者动画,需要及时的停止.-\u003e 当包含此View的Activity退出或者此View被remove的时候,View的onDetachedFromWindow()会被调用,可以适当处理防止内存泄漏. View带有的滑动嵌套时,需要处理好滑动冲突. ","date":"2016-08-10","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-04-view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:4:2","tags":["android","笔记"],"title":"《Android 开发艺术探索》 04-view的工作原理","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-04-view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"},{"categories":null,"content":"自定义View实例 1.自定义View派生类 首先写一个类继承View, 并在ondraw()画一个圆. 并设置margin属性. 效果没有问题,因为margin属性是由父容器控制的. **问题1:**这里把android:layout_width=\"wrap_content\"设置根据内容. 发现无效. 不管是设置match_parent也好,wrap_content也好父容器都会给分配自己剩余空间的大小给子容器作为specSize的空间大小这时需要手动处理. 因为不处理那就是相当于和match_parent填充父容器的效果一样. 所以增添对onMeasure()方法中的AT_MOST模式的制定默认大小, 然后在运行, ok,如下 **问题2:**这时加上属性padding=20dp发现无效. 无变化. 之前说过margin是交给父容器分配的.padding确实要自己要分配处理的. 这时需要在onDraw()来处理. 处理后如下 **问题3:**有时候我们需要提供自定义属性. 例如android:id=这种. 接下来添加自定义属性. 在values目录下创建自定义属性的xml. 名字随便当最好attrs.xml或者attrs_xxx_xxx.xml. \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cresources\u003e \u003cdeclare-styleable name=\"CircleView\"\u003e \u003cattr name=\"circle_color\" format=\"color\"/\u003e \u003c/declare-styleable\u003e \u003c/resources\u003e 上面相当于,定义了一个CircleView的属性集合. 在这个集合里面会有自定义属性. 这里的format格式可以是指定尺寸的dimension, 资源id引用的reference, 基本类型string, integer ,boolean等. 声明好了属性在我们自定义View中就可以引用处理了. 如构造方法中. public CircleView(Context context, AttributeSet attrs) { super(context, attrs, defStyleAttr); //获得一个自定义的对应属性值集合 TypedArray typedArray = context.obtainStyledAttributes(attrs, R.styleable.CircleView); //取出属性集合中的某个属性值 mColor = typedArray.getColor(R.styleable.CircleView_circle_color, Color.GREEN); //释放资源 typedArray.recycle(); init(); } 在布局中使用即可. 先声明schemas. xmlns:app=\"http://schemas.android.com/apk/res-auto\" ,使用app来替代之前的类似android前缀的引导. 继承View的派生类就到此为止了. 继承ViewGroup就不说了, 可以看第三章中的仓库代码的那个自定义View大致实现ViewPager的滑动 下一节: 理解RemoteViews ","date":"2016-08-10","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-04-view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/:4:3","tags":["android","笔记"],"title":"《Android 开发艺术探索》 04-view的工作原理","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-04-view%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"},{"categories":null,"content":" Anroid中的事件是怎样进行的 blog相关代码 ","date":"2016-08-08","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B003-view%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/:0:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 03-View的事件体系","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B003-view%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/"},{"categories":null,"content":"View的基础知识 ","date":"2016-08-08","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B003-view%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/:1:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 03-View的事件体系","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B003-view%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/"},{"categories":null,"content":"View的位置参数 一个View的位置主要由四个顶点构成, 或者可以就是两个点就可以确定. 分别为左上点,右下角每个点都对应x,y两个属性. 因为默认都是矩形, 所以两个点就可以确定. 一个View的大小可以利用四个属性可知. 分别对应getLeft(),getRight(),getTop(),getBottom系统提供的函数. 一个控件的宽: getRight() - getLeft() 一个控件的高: getTop() - getBottom() 在Android3.0中, View增加了几个属性:x , y, translationX, translationY x , y: 表示View的左上角坐标点(最终坐标点). translationX, translationY: 表示View的左上点相对于父容器的偏移量(默认是0). 而这些参数的换算关系为: x = left + translationX; y = top + translationY; ","date":"2016-08-08","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B003-view%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/:1:1","tags":["android","笔记"],"title":"《Android 开发艺术探索》 03-View的事件体系","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B003-view%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/"},{"categories":null,"content":"MotionEvent和TouchSlop MotionEvent是指手指在接触屏幕之后产生的一系列事件 最常见事件类型是ACTION_DOWN,ACTION_MOVE,ACTION_UP 一次事件可以有不同的持续时间, 和不同的事件类型. 例如 按下抬起 : DOWN –\u003e UP 按下移动抬起 : DOWN -\u003e MOVE -\u003e MOVE -\u003e … -\u003eUP …. 而在移动时可以根据MotionEvent提供的参数获对应的xy取值. *getX/getY: 返回相对于当前View左上角的x,y坐标. getRawX/getRawY: 返回的是针对整个屏幕的左上角的x,y坐标. TouchSlop是系统可以识别的最小滑动距离单位 只有手指两次滑动大于这个TouchSlop,系统才认为是滑动. ViewConfiguration.get(getContent).getSealedTouchSlop()可以获得这个系统值默认8dp. 用途: 在自定义的时候, 可以参考系统的默认值, 来作为实际的滑动定义. ","date":"2016-08-08","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B003-view%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/:1:2","tags":["android","笔记"],"title":"《Android 开发艺术探索》 03-View的事件体系","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B003-view%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/"},{"categories":null,"content":"VelocityTracker GestureDetector 和Scroller VelocityTracker 速度追踪 用于追踪手指在滑动过程中的速度,包括水平和数值方向的速度 使用方式: 在View的OnTouchEvent方法中: //获得速度追踪对象 VelocityTracker velocity = VelocityTracker.obtain(); velocity.addMovement(event); //计算速度 并获取计算值 velocity.computeCurrentVelocity(1000); //设定一个时间间隔值 float xVelocity = velocity.getXVelocity(); float yVelocity = velocity.getYVelocity(); 必须要先计算并设定计算速度的时间单元值,才可以获得速率. 公式: 速度 = (终点位置 - 起点位置) / 时间间隔值 可以看到, 计算的速度是根据我们自己添加的时间间隔值计算的. 并且速度可以为负值,如果向左滑动. 当不需要的时候, 调用clear()重置并回收内存. velocity.clear(); velocity.recycle(); GestureDetector 手势检测 用于辅助检测用户的单击, 滑动, 长按, 双击等行为. 使用如下 创建GestureDetector对象并实现OnGestureDetector接口. GestureDetector mGestureDetector = new GestureDetector(this); // 解决长按屏幕后无法拖动的现象 mGestureDetector.setIsLongpressEnabled(false); 然后接管目标View的onTouchEvent()方法. 在onTouchEvent()方法中 boolean consume = mGestureDetector.onTouchEvent(event); return consume; 然后根据需求可以选择性的实现OnGestureListener和OnDoubleTapListener接口 接口的方法说明: 方法名 描述 所属接口 onDown 按下 OnGestureListener onShowPress 按下 但是未松开或者拖动.强调状态 OnGestureListener onSingleTapUp 抬起 表示单击行为, 双击中也会触发 OnGestureListener onScroll 按下并拖动 拖动行为 OnGestureListener onLongPress 长按 OnGestureListener onFling 按下屏幕病快速滑动后松开 OnGestureListener onDoubleTap 双击,两次连续单击组成, 与onSingleTapConfirmed无法共存 OnDoubleTapListener onSingleTapConfirmed 严格意义上的单击 双击中的单击无法触发 OnDoubleTapListener onDoubleTapEvent 表示发生了行为 OnDoubleTapListener 实际开发中:根据喜好来使用. 即使不使用GestureDetector辅助手势检测类,一样可以实现. 建议: 如果要监听双击这种行为就是用此类. Scroller 弹性滑动对象 用于实现View的弹性滑动. 在开发中, 当需要把View从一个点移动到另一个点的时候. 如果使用scrollTo/scrollBy进行滑动时, 都是瞬间完成. 没有过度动画, 给用户感觉很生硬. 使用Scroller 可以实现有过渡的滑动.Scroller本身无法让View弹性滑动, 需要和View的computerScroll进行配合使用. 下面会说到 ","date":"2016-08-08","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B003-view%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/:1:3","tags":["android","笔记"],"title":"《Android 开发艺术探索》 03-View的事件体系","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B003-view%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/"},{"categories":null,"content":"View的滑动 实现滑动的方式有三种: 通过View本身的scrollTo/scrollBy方法实现滑动 通过动画给View施加平移效果来实现动画 通过改变View的LayoutParams使View重新布局实现滑动 ","date":"2016-08-08","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B003-view%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/:2:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 03-View的事件体系","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B003-view%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/"},{"categories":null,"content":"scrollTo/scrollBy 首先要明确一点: 这两个方法只能改变View的内容位置,而不能改变View本身在布局中的位置 而且方法中都是以像素值来进行移动的. scrollTo: 针对当前View的绝对位置进行移动. scrollBy: 根据当前View的内容值进行相对位置移动. 看一下scrollBy的源码调用 public void scrollBy(int x, int y) { scrollTo(mScrollX + x, mScrollY + y); } 其实本质上scrollBy调用了scrollTo方法 而mScrollX/mScrollY是什么? 这个就是当前View的内容 与这个View实际布局位置(原始位置)的差值. 而当前View内容这个东西就是让用户看到的效果发生改变. 但是如果这个View可以被点击. 那么能触发点击的位置是View的实际所在布局位置. 而不是View的内容显示的位置. ","date":"2016-08-08","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B003-view%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/:2:1","tags":["android","笔记"],"title":"《Android 开发艺术探索》 03-View的事件体系","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B003-view%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/"},{"categories":null,"content":"使用动画 使用动画来对View进行移动,主要就是操作View的translationX/translationY属性 可以使用普通动画和属性动画. 普通动画是对View进行影像的移动. 可以通过设置fillAfter=true,来让影像在动画结束时候保留最终结果.而不是还原到起始位置. 而属性动画会对真实位置也进行改变. ObjectAnimator.ofFloat(tagerView,\"translationX\",0,100).setDuration(100).start() ","date":"2016-08-08","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B003-view%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/:2:2","tags":["android","笔记"],"title":"《Android 开发艺术探索》 03-View的事件体系","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B003-view%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/"},{"categories":null,"content":"改变布局参数 这个比较简单, 获得View的LayoutParams参数.进行修改,改好之后再赋值回去. MarginLayoutParams params = (MarginLayoutParams)mTextView.getLayoutParams(); params.width += 100; params.leftMargin += 100; mTextView.requestLayout(); //或者mTextview.setLayoutParams(params); 关于这三种方式的简单总结 scrollTo/scrollBy: 操作简单, 适合对View内容的滑动 动画: 操作简单,主要适用于没有交互的View和实现复杂的动画效果. 修改布局参数: 操作稍微复杂,适用于有交互的View. ","date":"2016-08-08","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B003-view%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/:2:3","tags":["android","笔记"],"title":"《Android 开发艺术探索》 03-View的事件体系","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B003-view%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/"},{"categories":null,"content":"弹性滑动 使用Scroller 一个简单的使用方法如下: Scroller mScroller = new Scroller(mContent); // 封装一个方法, 接收要移动到的目标点 x和y private void smoothScrollTo(int destX, int destY){ int scrollX = getScrollX(); int deltaX = destX - scrollX; // 1000ms内逐渐滑向destX mScroller.startScroll(scrollX, 0, deltaX, 0, 1000); invalidate(); } //复写View的computeScroll方法 public void computeScroll(){ if(mScroller.computeScrollOffset()){ scrollTo(mScroller.getCurrX(), mScroller.getCurrY()); postInvalidate() } } 源码中Scroller类中startScroll()方法,其实没有实际操作什么,只是保存了调用方法时,传递的几个参数. 如: 开始结束点,时间等. 那动画究竟是怎么实现的? 复写的computeScroll()又有什么用? 流程顺序这样的: 当调用了startScroll()系统只是保存了一些信息, 但是下面调用invalidate(). 这个方法都知道是会导致View的重绘, 在View的draw()方法中又会去调用computeScroll()方法,本身computeScroll()是一个空实现,但是这里进行了复写. 而这个方法我们复写的时候调用了scrollTo()方法! ok这样View就会真正的移动了! 但是还有一点这次滚动只是整个滚动事件的一个小部分,后续的怎么触发的? 就是下面又调用了postInvalidate(), 又会重新绘制重新调用computeScroll()这个复写过的空实现方法. 而Scroller类中的computeScrollOffset()可以直接返回这个滚动的动作是否全部完成. 源码实现思路就是根据时间的流逝的百分比来计算出当前ScrollX和ScrollY的值. // 核心代码 x就是时间流逝的百分比 mCurrX = mStartX + Math.round(x * mDeltaX); mCurrY = mStartY + Math.round(x * mDeltaY); 小结Scroller的工作原理: Scroller本身不可以实现滑动, 需要和View的ComputeScroll()配合使用来完成弹性滑动. 通过不断的在computeScroll()调用View的重绘方法. 每次绘制时候的当前时间与开始时间的时间差与设定的执行动画时间的百分比,算出每一次需要scroll到的坐标点, 然后通过调用**scrollTo()**来实现每一次的小滚动效果. 通过一连串的滚动达到了平滑的效果. 这就是Scroller工作机制. 完全实现了解耦操作. 这个过程没有任何一处对View进行引用,甚至连内部计时器都没有. 通过动画 可以直接使用ObjectAnimator.ofFloat(tagerView,\"translationX\",0,100).setDuration(100).start() 也可以利用动画的特性, 实现与Scroller原理近似的方法. final int startX = 100; final int endX = 200; ValueAnimator valueAnimator = ValueAnimator.ofInt(0, 1).setDuration(1000); valueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() { @Override public void onAnimationUpdate(ValueAnimator animation) { int offset = (int) animation.getAnimatedFraction(); mTextview.scrollTo(startX+offset, 0); } }); 让系统算出每个时间片我们需要移动的距离, 并回调给我们.让我们自己实现. 如果是一组动画在相同的时间执行的绝对值相同我们就可以在onAnimationUpdate()一起进行调用. 使用延时策略 核心思想就是通过发送一些列延时消息从而达到一种渐进的效果. 可以使用: Handler, View的postDelayed()方法, 或者线程的sleep() ","date":"2016-08-08","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B003-view%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/:3:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 03-View的事件体系","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B003-view%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/"},{"categories":null,"content":"View事件分发机制 ","date":"2016-08-08","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B003-view%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/:4:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 03-View的事件体系","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B003-view%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/"},{"categories":null,"content":"点击事件传递规则 所谓点击事件的事件分发,就是对MotionEvent事件的分发过程,传递给某一个View. 在事件传递中有三个方法是贯穿始终的 dispatchTouchEvent():进行事件的分发 如果事件能传递到View那么此方法一定会被调用,返回值受当前View的onTouchEvent()和下级View的dispatchTouchEvent()的影响. 表示是否消耗当前事件. onInterceptTouchEvent(): 判断是否拦截事件,如果当前View拦截了某个事件,那么在同一个事件序列中, 此方法不会被再次调用, 返回结果表示是否拦截当前事件. onTouchEvent(): 在dispatchTouchEvent中被调用. 用来处理点击事件, 返回结果表示是否消耗当前事件,如果不消耗, 则在同一个事件序列中, 当前View无法再次接收到事件. 如果把源码中的各种判断去掉, 只留最核心的代码, 那么就如下: public boolean dispatchTouchEvent(MotionEvent event) { boolean consume = false; //表示这个事件最终的处理结果 if (onInterceptTouchEvent(event)){ //事件被拦截自己处理 consume = onTouchEvent(event); }else{ //事件被分发到子view的dispatchTouchEvent()中 consume = child.dispatchTouchEvent(event); } return consume; } OnTouchListener() , onTouchEvent() , OnClickListener() 的优先级 上面说了普遍情况下的事件分发. 如果这个View同时还添加了OnTouchListener和OnClickListener. 此时的优先级如下: OnTouchListener –\u003e onTouchEvent –\u003e OnClickListener 而onTouchEvent()能否被最终调用取决于设置了OnTouchListener()中的onTouch()的返回值, 如果onTouch()返回的结果是false,那么onTouchEvent()会被调用. 如果返回true那么onTouchEvent()不会被调用. 而最后被调用的OnClickListener()方法是在onTouchEvent()被调用的. 所以如果onTouchEvent()方法如果执行, 那么对应的添加的onClickLisener()才会被调用. 所以如果在OnTouchListener()中的onTouch()返回true那么onTouchEvent()不会被调用,内部调用OnClickListener也就更无法被调用. 一个事件的传递过程遵循如下 Activity -\u003e Window -\u003e View 如果事件一直不拦截,传递到了最里层的View而最里层的View的onTouchEvent()也返回false不消费, 那么事件就会向上级的onTouchEvent()传递,如果还返回false就依次传递. 对于事件机制的规则: 事件序列是指按下到抬起之间发生的一系列事件. 默认一个事件序列只能被一个View拦截并消耗. (例外:采用非常规,在onTouchEvent强行传递给其他View. 不推荐) 如果View决定拦截,那么这个事件序列只能由它自己处理. 并且它的onInterceptTouchEvent()不会再被调用 如果View不在ACTION_DOWN事件时返回true, 那么同一个事件序列都不会再交给它来处理.并且事件会重新传递到父元素的onTouchEvent()再次调用方法. 如果View不消耗除ACTION_DOWN以外的事件,那么这个点击事件会消失,而父元素的onTouchEvent()不会被调用,并且当前View可以持续收到后续的事件,最终这些消失的事件会传递到activity处理. ViewGroup默认不拦截任何事件, 源码中ViewGroup的onInterceptTouchEvent()默认返回false View没有onInterceptTouchEvent(), 因为它没有子View,所以直接调用onTouchEvent() View的onTouchEvent默认都会消耗事件返回true. 除非它不可点击的(需要clickable,longClickable同时为false). View的longClickable默认都为false. 而clickable需要区分控件, 如Button默认为true, TextView默认为false. View的enable属性不影响onTouchEvent的默认返回值, 哪怕一个View是disable状态. 只要它的clickable或者longClickable有一个为true. 那么它的onTouchEvent()就返回true. onClick会发生的前提是当前View为可点击, 并且他收到了down和up事件. 事件传递的过程是由外向内的. 通过requestDisallowInterceptTouchEvent()可以在子元素中干预父元素的事件分发过程,但是ACTION_DOWN事件除外. ","date":"2016-08-08","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B003-view%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/:4:1","tags":["android","笔记"],"title":"《Android 开发艺术探索》 03-View的事件体系","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B003-view%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/"},{"categories":null,"content":"事件分发的源码解析 1.Activity对点击事件的分发过程 事件的起始Activity的dispatchTouchEvent()进行分发,具体的工作交由内部的Window来完成. window会将事件传递给decor view. 而decor view一般是当前界面的底层容器(平常setContentView中传递的布局),可通过Activity.getWindow.getDecorView()获得. window是怎样将事件传递给ViewGroup的? 首先Window类为一个抽象类,而类中的调用的分发方法也为抽象方法. 所以需要找到实现类. Window的唯一实现类PhoneWindow. 这个类会在被实例化的时候会被重构. PhoneWindow#superDispatchTouchEvent(ev)方法中将事件传递给了DecorView. decorView就是挂载我们的layout布局的顶级View,继承FrameLayout. ((ViewGroup)getWindow().getDecorView().findViewById(android.R.id.content)).getChildAt(0); 这个方法可以获取到Activity所设置的View. 所以之间的关系很清楚了. 事件先交给最顶级的DecorView然后交由我们设置的View. 2.ViewGroup对事件的处理 在父元素中判断子元素是否能接收点击事件的主要由两个因素衡量: 子元素是否在播放动画和点击事件的坐标是否落在子元素的区域内.dispatchTransformedTouchEvent()实际就是调用子View的dispatchTouchEvent. 而在事件从孩子到父元素(子View在onTouchEvent返回false). 其实也是调用了dispatchTransformedTouchEvent(). 区别就在于向内传递参数3是传入的不是空值, 向外传传入的是null.看下面代码: private boolean dispatchTransformedTouchEvent(MotionEvent event, boolean cancel, View child, int desiredPointerIdBits) { if (child == null) { handled = super.dispatchTouchEvent(event); } else { handled = child.dispatchTouchEvent(event); } } 3.View对事件的处理 View对事件的判断首先是检测是否有onTouchListener如果有那么就调用其中的onTouch()方法. 然后\u0008执行onTouchEvent()这里有个判断条件,如果在onTouchListener()返回true. 那么if中的条件判断第一个就不会成立,也就不会再调用onTouchEvent()方法.如下: if (li != null \u0026\u0026 li.mOnTouchListener != null \u0026\u0026 (mViewFlags \u0026 ENABLED_MASK) == ENABLED \u0026\u0026 li.mOnTouchListener.onTouch(this, event)) { result = true; } if (!result \u0026\u0026 onTouchEvent(event)) { result = true; } 然后在onTouchEvent()中首先是查看View处理不可用状态. 这里需要注意一下, 虽然View不可用但是如果点击标记或者长按点击标记都是true. 那么事件也会被消费.如下 if ((viewFlags \u0026 ENABLED_MASK) == DISABLED) { ..... // A disabled view that is clickable still consumes the touch // events, it just doesn't respond to them. return (((viewFlags \u0026 CLICKABLE) == CLICKABLE || (viewFlags \u0026 LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags \u0026 CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE); } 如果View设置有代理, 那么还会执行TouchDelegate的onTouchEvent() 然后对点击状态进行处理.首先如果点击和长按有一个为true那么就会消费事件. 即onTouchEvent()返回true. 然后在ACTION_UP中会触发performClick()如果设置了onClickListener()那么就会在此处进行判断并调用onClick(). 上面一直说的LONG_CLICKABLE与CLICKABLE. 长按标记默认为false. 点击标记和View是否是可点击View有关系. 如button可点击默认就是true. 否者反之. 在使用时可以通过setClickable和setLongClickable对View的这两个标记进行修改. 这里还要注意还有一种赋值方式. 如果设置了setOnClickListener()或者setOnLongClickListener()监听的话那么会自动将其对应的属性置为true. ","date":"2016-08-08","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B003-view%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/:4:2","tags":["android","笔记"],"title":"《Android 开发艺术探索》 03-View的事件体系","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B003-view%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/"},{"categories":null,"content":"View的滑动冲突 ","date":"2016-08-08","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B003-view%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/:5:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 03-View的事件体系","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B003-view%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/"},{"categories":null,"content":"滑动冲突的解决方式 外部拦截法 是指点击事件都是需要先经过父容器的拦截处理, 如果父容器需要此事件就拦截,不需要就下放. 外部拦截需要重写父容器的onInterceptTouchEvent方法 简述一下: 如果使用这样拦截法. 那么首先 ACTION_DOWN这个事件,父容器必须返回false, 即不拦截ACTION_DOWN事件, 因为一旦父容器拦截了这个事件, 那么后续的ACTION_MOVE,ACTION_UP事件都会交由父容器来处理了. 这个时候这个事件序列剩余部分无法传递给子元素了. ACTION_MOVE这个事件,就可以根据实际的需求来决定是否需要拦截. 如果需要拦截就返回true.否则false. ACTION_UP这个事件必须返回false, 因为ACTION_UP事件本身没有太多意义. 内部拦截法 是指父容器不拦截任何事件, 所有的事件都需要传递给子元素, 如果子元素需要此事件就直接消费. 否则就交由父容器进行处理, 由于这种方法和Android中的事件分发机制不一致, 需要配合requestDisallowInterceptTouchEvent()方式才能正常工作. 需要重写子元素的dispatchTouchEvent 这种拦截法的使用规则: 子View中的dispatchTouchEvent()进行复写. ACTION_DOWN事件中: 让父容器拒绝拦截所有事件, 调用parent.requestDisallowInterceptTouchEvent(true) ACTION_MOVE事件中: 进行条件的拦截判断, 如果在某一种场景需要拦截,那么就调用方法允许父容器拦截事件. return 时, 调用super.dispatchTouchEvent(event) 父容器的onInterceptTouchEvent()进行ACTION_DOWN返回false, 其余都是返回true的复写. 说明一点, 为什么父容器不连Action_down一并的用true复写. 因为ACTION_DOWN这个事件是不受INTERCEPT_FLAG这个标记影响的的, 就是不管拦截标记是否是何值, 按下事件必然会执行, 所以如果这里返回true, 那么就代表着, 这个事件序列的后续部分将由父容器进行处理, 而子容器无法收到这个事件. ","date":"2016-08-08","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B003-view%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/:5:1","tags":["android","笔记"],"title":"《Android 开发艺术探索》 03-View的事件体系","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B003-view%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/"},{"categories":null,"content":"实例演练 实例演练的代码 实现效果:类似ViewPager中嵌套ListView的效果 首先需要一个父容器, 这里使用作者提供的一个类MyHorizontalScrollView,这个类类似于ViewPager是继承ViewGroup自定义的, 支持左右滑动. 因为这个类对拦截进行了处理,所以这里把onInterceptTouchEvent()实现的方法注释掉让这个自定义ViewGroup走默认的分发模式. 达到一会使用可以出现滑动冲突的场景. (关于这个类的其他代码,会在下一章笔记中说明,这里不需要关心) 然后子容器是一个TextView+ListView. 分析存在的问题 由于ViewGroup默认的是不拦截事件的. 在自己的onTouchEvent进行了事件的处理来实现左右滑动. 但是这里有有一个前提, 那就是事件一直传递到最里层并且最里层的View不会把事件消费掉.这样父容器才会实现预期的效果. 但是这里放了一个listview, TextView. 运行代码看一下实际情况. 发现如下情况: ","date":"2016-08-08","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B003-view%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/:6:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 03-View的事件体系","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B003-view%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/"},{"categories":null,"content":"外部拦截解决 外部拦截法相关代码在仓库的outside包中 接下来就解决这个问题. 既然打算外部拦截法,那么首先继承这个MyHorizontalScrollView类, 复写其中的onInterceptTouchEvent()进行相应的处理. 需要解决的就是在:滑动过程中水平距离差比垂直距离差大,父容器就要拦截事件 @Override public boolean onInterceptTouchEvent(MotionEvent ev) { boolean intercept = false; int x = (int) ev.getX(); int y = (int) ev.getY(); switch (ev.getAction()){ case MotionEvent.ACTION_DOWN: if (!mScroller.isFinished()){ mScroller.abortAnimation(); //优化滑动效果 intercept = true; } break; case MotionEvent.ACTION_MOVE: int deltaX = x - mLastYIntercept; int deltaY = y - mLastYIntercept; //根据绝对值判断是否需要拦截 if (Math.abs(deltaX) \u003c Math.abs(deltaY)){ intercept = false; }else{ intercept = true; } break; case MotionEvent.ACTION_UP: intercept = false; break; default: break; } //赋值给mLast是防止在onTouchEvent第一次move移动时候跳屏 mLastX = mLastXIntercept = x; mLastY = mLastYIntercept = y; return intercept; } ","date":"2016-08-08","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B003-view%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/:6:1","tags":["android","笔记"],"title":"《Android 开发艺术探索》 03-View的事件体系","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B003-view%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/"},{"categories":null,"content":"内部拦截解决 内部拦截法相关代码在仓库的inside包中 上面总结过使用内部拦截法. 主要就是允许父容器在onIntercept()中的MOVE和UP事件中一直返回true表示拦截事件. 而在子容器中进行对父容器的requestDisallowIntercept标记的修改. 来控制事件的分发.(DOWN事件不能返回true,会导致子View永远收不到事件) 子容器这里ListView进行继承并复写dispatchTouchEvent(),来控制父容器的requestDisallowIntercept标记. @Override public boolean dispatchTouchEvent(MotionEvent ev) { int x = (int) ev.getX(); int y = (int) ev.getY(); switch (ev.getAction()){ case MotionEvent.ACTION_DOWN: //相当于进行初始化每次发生一个事件序列时, 都对不容器进行重置不允许拦截 mInSide2HorizontalScrollview.requestDisallowInterceptTouchEvent(true); break; case MotionEvent.ACTION_MOVE: int deltaX = x - mLastX; int deltaY = y - mLastY; if (Math.abs(deltaX) \u003e Math.abs(deltaY)){ //当水平距离大的时候 允许父容器拦截 mInSide2HorizontalScrollview.requestDisallowInterceptTouchEvent(false); } break; default: break; } mLastX = x; mLastY = y; return super.dispatchTouchEvent(ev); } 同时修改一下父容器的onInterceptTouchEvent()方法 @Override public boolean onInterceptTouchEvent(MotionEvent ev) { int x = (int) ev.getX(); int y = (int) ev.getY(); switch (ev.getAction()){ case MotionEvent.ACTION_DOWN: if (!mScroller.isFinished()){ mScroller.abortAnimation(); return true; } mLastX = x; mLastY = y; return false; default: return true; } } 好啦 结束了 慢慢消化…. ","date":"2016-08-08","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B003-view%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/:6:2","tags":["android","笔记"],"title":"《Android 开发艺术探索》 03-View的事件体系","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B003-view%E7%9A%84%E4%BA%8B%E4%BB%B6%E4%BD%93%E7%B3%BB/"},{"categories":null,"content":" ","date":"2016-08-02","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B002-ipc%E6%9C%BA%E5%88%B6/","tags":["android","笔记"],"title":"《Android 开发艺术探索》 02-IPC机制","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B002-ipc%E6%9C%BA%E5%88%B6/"},{"categories":null,"content":" 第二章: Android中的IPC机制,深入记录Bundle, 文件共享, AIDL, Messenger, ContentProvider, Socket等进程间的通信. blog相关代码 ","date":"2016-08-02","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B002-ipc%E6%9C%BA%E5%88%B6/:0:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 02-IPC机制","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B002-ipc%E6%9C%BA%E5%88%B6/"},{"categories":null,"content":"Android IPC简介 IPC是Inter-Process Communication缩写,含义为进程间通信. 按照操作系统中的描述,线程是cpu调度的最小单元,而进程一般指一个执行单元. 进程中可以有一个或者多个线程. 不同的操作系统有着不同的IPC机制: Windows: 通过剪切板, 管道, 信号量来进行进程间通信 Linux: 通过命名管道, 共享内存, 信号量等来进行进行进程间通信 android: 虽然基于Linux内核,但是使用了独有的Binder机制, 也可以Socket进行通信 使用场景: 可能有些模块因为特殊原因需要运行在单独的进程中; 或者为了加大一个应用可使用的内存; 又或者我们需要去另外一个进程去获取数据,必然需要跨进程. ","date":"2016-08-02","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B002-ipc%E6%9C%BA%E5%88%B6/:1:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 02-IPC机制","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B002-ipc%E6%9C%BA%E5%88%B6/"},{"categories":null,"content":"Android中的多进程的模式 ","date":"2016-08-02","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B002-ipc%E6%9C%BA%E5%88%B6/:2:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 02-IPC机制","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B002-ipc%E6%9C%BA%E5%88%B6/"},{"categories":null,"content":"开启多进程模式 如果你想在一个应用中使用多个进程,通过清单文件给四大组件添加android:process属性,就可以很方便的开启多进程. 还有一种非常规的创建方式,通过JNI在native层去fork一个新的进程.这种只做了解. 例如这样,当我们依次打开MainActivity, SecondActivity, ThirdActivity.此时应该打开了三个进程. 我们来检测一下, 你可以直接使用DDMS来查看进程,这里使用命令行来测试 $ adb shell ps | grep com.szysky 你可以直接使用adb shell ps这会把系统所有进程展示出来, 你可以加上过滤信息| grep xxx xxx替换你需要过滤出来信息即可 你可能已经发现在创建新进程的时候使用两种不同的方式 当以:开头的进程,属于当前应用的私有进程,其他应用的组件不可以和它跑在同一个进程 当不以:开头,那么进程属于全局进程,其他应用通过ShareUID方法可以和它跑在同一个进程 Android系统会为每一个应用分配唯一的UID. 相同UID的应用才能共享数据. 但是两个应用通过ShareUID跑在同一个进程是有要求的. 除了具有相同的ShareUID并且还要签名相同才可以. 这时如果不在同一进程他们之间可以共享data目录,组件信息等. 如果还在同一进程, 那么他们还能共享内存数据. ","date":"2016-08-02","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B002-ipc%E6%9C%BA%E5%88%B6/:2:1","tags":["android","笔记"],"title":"《Android 开发艺术探索》 02-IPC机制","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B002-ipc%E6%9C%BA%E5%88%B6/"},{"categories":null,"content":"进程模式的运行机制 开启多进程简单,但是如果不能处理好其中的特性,那么受伤的总会是你. 先说第一个比较严重的问题. 静态变量不在共享. 还是直接三个类的例子,如果在mainActivity中对静态变量进行修改, 在SecondActivity取出这个静态发现是main没修改之前的. 这说明两个进程间即使是静态属性也是无法共享. 其实这是因为这两个类运行在两个进程间,而每个单独的进程又会分配一个独立的虚拟机, 所以每个虚拟机在内存分配上有不同的地址空间.对于不同虚拟机访问同一个对象就会产生多份副本. 副本之间互相独立不干扰彼此. 一般情况下多进程可能面临的问题: 静态成员和单例模式完全失效 线程同步机制完全失效 SharedPreferences的可靠性下降 Application会多次创建 2中因为不是一块内存,所以不管是锁对象还是锁全局都无法保证线程同步,因为不是同一个对象. 3中因为Sp不支持两个进程同时读写,因为底层是通过读写XML文件实现的,并发可能会触发异常. 4中运行在多个进程中,那么就会创建多个虚拟机,每个虚拟机都有一个对应Application并需要启动加载这个文件. 一个应用的多进程:它就相当于两个不同的应用采用了ShareUID的模式. 每个进程都会拥有独立的虚拟机, Application以及内存空间 ","date":"2016-08-02","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B002-ipc%E6%9C%BA%E5%88%B6/:2:2","tags":["android","笔记"],"title":"《Android 开发艺术探索》 02-IPC机制","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B002-ipc%E6%9C%BA%E5%88%B6/"},{"categories":null,"content":"IPC基础概念 关于IPC主要包含三方面的内容: Serializable接口, Parcelable接口, 以及Binder ","date":"2016-08-02","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B002-ipc%E6%9C%BA%E5%88%B6/:3:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 02-IPC机制","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B002-ipc%E6%9C%BA%E5%88%B6/"},{"categories":null,"content":"Serializable接口 Serializable是Java提供的一个序列化接口,这个一个空接口. 如果我们想使用只需要实现Serializable接口,并声明一个long类型的常量serialVersionUID(不声明也是可以,但是在反序列化会出现错误). javabean 的实现 public class Student implements Serializable{ public static final long serialVersionUID = 123456789L; //.....省略创建属性,打印等操作 } 序列化的代码如下图,并附上结果. 好了说一下serialVersionUID这个属性. 即使我们不声明系统会根据当前类结构(成员变量等)生成一个hash为serialVersionUID, 虽然这样也可以但是如果在你把一个对象序列化的到磁盘的一个文件的时候. 对这个对象增加了一个成员变量,那么在反序列的时候就会报错. 因为当你反序列化的时候对象如果没有serialVersionUID还会重新计算.这时反序列化的hash和序列化的hash就不一致了. 关于根据当前类结构计算hash值,有两点需要注意: 静态成员变量属于类不属于对象,所以不参与序列化的过程 其次用transient关键字标记的成员变量不参与序列化的过程. 系统默认的序列化过程是可以改变的,通过实现writeObject和readObject可以重写默认的序列化和反序列化过程. 这里就不详细说明 ","date":"2016-08-02","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B002-ipc%E6%9C%BA%E5%88%B6/:3:1","tags":["android","笔记"],"title":"《Android 开发艺术探索》 02-IPC机制","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B002-ipc%E6%9C%BA%E5%88%B6/"},{"categories":null,"content":"Parcelable接口 系统已经为我们提供了很多实现了Parcelable接口的类,他们都可以直接序列化. 例如intent, Bundle, Bitmap, 同时List和Map也可以序列化.前提是他们里面的每个元素都可以序列化. 实现Parcelable接口主要复写四个, 我们可以直接定义好javabean直接让AS帮我们实现. writeToParcel() 主要完成序列化功能 CREATOR 主要完成反序列化 接收参数parcel的构造函数 用于从序列化后的对象中创建原始对象 describeContents() 几乎所有情况下都返回0,只有当前对象中存在文件描述符时返回1 关于Parcelable和Serializable的取舍 Serializable: 适合序列化到设备或者序列化后通过网络传输. Parcelable: 主要用在内存序列化上. 不需要大量的I/O操作,所以在内存中使用高效. ","date":"2016-08-02","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B002-ipc%E6%9C%BA%E5%88%B6/:3:2","tags":["android","笔记"],"title":"《Android 开发艺术探索》 02-IPC机制","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B002-ipc%E6%9C%BA%E5%88%B6/"},{"categories":null,"content":"了解Binder 代码层面: Binder是Android中的一个类,它实现了IBinder接口 IPC角度: Binder是Android中的一种跨进程通信方式. 物理设备角度: Binder也可以认为是一种虚拟的物理设备,设备驱动是/dev/binder Framework角度: Binder是ServiceManager连接各种Manager和相应的ManagerService的桥梁. Android应用角度:Binder是客户端和服务端进行通信的媒介. 日常开发中,Binder主要用在Service包括AIDL和Messenger. 而普通的Service中的Binder不涉及进程间的通信,无法触及Binder的核心. 而Messenger底层其实就是AIDL.所以我们利用AIDL来分析Binder的工作机制 ","date":"2016-08-02","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B002-ipc%E6%9C%BA%E5%88%B6/:3:3","tags":["android","笔记"],"title":"《Android 开发艺术探索》 02-IPC机制","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B002-ipc%E6%9C%BA%E5%88%B6/"},{"categories":null,"content":"创建AIDL实例 新建三个文件 Book.java Book.aidl 和IBookManager.aidl 首先创建一个Book类并实现Parcelable接口,然后在这个类所在的包上右键,如图所示 如果名字不能为Book,可以先随便写一个,创建之后修改. 然后按图修改, 文件声明完,我们只需要重新Make一下工程就可以.Build --\u003e Rebuild Project或者Make Project Make之后会在app -\u003e build -\u003e generated -\u003e source -\u003e aidl -\u003e debug -\u003e … 出现系统自动生成好的java类. 我们需要对其进行分析 看下图了解一个大体结构 上图圈出了两个部分,部分二应该很清楚就是我们定义在aidl中的两个抽象方法. 而部分一在图上的内部类Stub写了说明. 我们自定义的两个抽象方法,在内部类中用了两个整形int值来标识两个抽象方法,用在transact()中可以识别客户端请求哪个方法. 这个继承了IInterface的接口的核心实现:就是内部类Stub和Stub的内部代理Proxy 先看一下内部类的结构图: 说明直接放图,写在代码上,在git上的根目录的aidl的java类说明文件夹也有添加了注释的类. 有两点需要注意: 客户端发起远程请求时,当前线程会被挂起直到服务器进程返回数据,所以注意线程是否在意耗时 由于服务端Binder方法运行在Binder线程池中,所以不管Binder方法是否耗时都应该采用同步方式,因为已经在一个线程中了 我们也可以手动实现Binder类,这里不再细说,在git仓库的项目中有一个manual包里面是关于手动实现Binder的代码. 其实 不管是手动实现Binder也好,或者AIDL文件实现Binder也好. 其实两者的工作原理都是一样的, AIDL文件的存在意义是系统为我们提供了一种快速实现Binder的工具,仅此而已. ","date":"2016-08-02","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B002-ipc%E6%9C%BA%E5%88%B6/:3:4","tags":["android","笔记"],"title":"《Android 开发艺术探索》 02-IPC机制","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B002-ipc%E6%9C%BA%E5%88%B6/"},{"categories":null,"content":"Binder生命状态的监听 由于Binder是运行在服务端,如果服务端进程异常终止,那么我们到服务端的Binder连接也就断裂(Binder死亡).就会导致调用失败,所里系统提供了死亡代理的方法 就是当Binder死亡时,我们就会收到通知,这个时候就可以重新发起连接请求而恢复连接 首先创建监听的DeathRecipient对象 IBinder.DeathRecipient mDeat = new IBinder.DeathRecipient() { // 当Binder死亡的时候,系统会回调binderDied()方法 @Override public void binderDied() { if (mBookManager == null) return ; //清除掉已经无用的Binder连接 mBookManager.asBinder().unlinkToDeath(mDeat,0); mBookManager == null; //TODO 进行重新绑定远程服务 } }; 当客户端绑定远程服务成功的时候,给binder设置死亡代理 xxxxManager.Stub.asInterface(binder); binder.linkToDeath(mDeat,0); linkToDeath的第二个参数是个标志位,直接设0即可. 另外也可以通过Binder的方法isBindAlive也可以判断Binder是否死亡. ","date":"2016-08-02","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B002-ipc%E6%9C%BA%E5%88%B6/:3:5","tags":["android","笔记"],"title":"《Android 开发艺术探索》 02-IPC机制","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B002-ipc%E6%9C%BA%E5%88%B6/"},{"categories":null,"content":"Android的几种跨进程的方式 ","date":"2016-08-02","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B002-ipc%E6%9C%BA%E5%88%B6/:4:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 02-IPC机制","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B002-ipc%E6%9C%BA%E5%88%B6/"},{"categories":null,"content":"使用Bundle 由于Bundle实现了Parcelable接口,所以在四大组件中的三大组件(Activity, Service, Receiver)都支持在Intent中传递Bundle. 所以如果在一个进程中启动了另一个进程的三大组件,就可以在Bundle中附加我们需要的信息通过Intent发送出去. 当然传递的类型必须是能够被序列化的, 例如基本数据类型,实现了Parcelable和Serializable接口的对象和一些Android支持的特殊对象. ","date":"2016-08-02","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B002-ipc%E6%9C%BA%E5%88%B6/:4:1","tags":["android","笔记"],"title":"《Android 开发艺术探索》 02-IPC机制","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B002-ipc%E6%9C%BA%E5%88%B6/"},{"categories":null,"content":"使用文件共享 练习代码对应仓库中的userbundle包中. 文件共享适合在对数据同步要求不高的进程之间进行通信,并且要妥善的处理并发读写的问题. 两个进程通过读/写同一个文件来交换数据. 例如进程A把数据写入文件中,而进程B从文件中读取出来数据. Android是基于Linux系统, 所以对于并发读写文件可以没有限制的执行. 这里不像Windows系统,对于一个文件如果加了排斥锁将会导致其他线程无法对其进行访问. 关于这部分的练习, 在之前练习Binder的时候已经练习过了. 代码在项目中的MainActivity中 虽然序列化反序列达到的效果是可以恢复对象里面的属性值,但是反序列每回都是一个新的对象. SharePreferencess是Android提供的一个轻量级方案,通过键值对存储数据,底层采用XML文件来进行存储. 存储路径/data/data/package name/shared_prefs目录下. 也属于文件的一种,但是由于系统对SP的读写存在一定的缓存策略,内存中会有一份缓存,所以多进程下,系统对它的读写也就变得不可靠. ","date":"2016-08-02","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B002-ipc%E6%9C%BA%E5%88%B6/:4:2","tags":["android","笔记"],"title":"《Android 开发艺术探索》 02-IPC机制","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B002-ipc%E6%9C%BA%E5%88%B6/"},{"categories":null,"content":"使用Messenger Messenger(信使). 不同的进程中可以传递Message对象, 在Message中放入我们需要传递的数据,就可实现进程间传递. Messenger是一种轻量级的IPC方案,它的底层实现AIDL. 看一些构造函数 public Messenger(Handler target) { mTarget = target.getIMessenger(); } public Messenger(IBinder target) { mTarget = IMessenger.Stub.asInterface(target); } 无论是IMessenger还是Stub.asInterface. 可以明显看出AIDL的痕迹. 因为Messenger对AIDL进行了封装,使得在使用时更加简单,并且它的处理方式是一次处理一个请求,因此服务器端不用考虑线程同步因为服务端不存在并发执行的情形. 具体实现Messenger 1.服务端 创建一个Service作为服务端来处理客户端的请求, 同时创建一个Handle并通过它来创建一个Messenger对象,然后在Service的onBind()方法中返回这个Messenger对象底层的Binder. 最后这个组件在清单文件中声明加上android:process=\"com.szysky.test\"属性.已达到模拟多进程的场景 public class MessengerService extends Service { /** * 编写一个类继承Handler,并对客户端发来的消息进行处理操作进行添加 */ private static class MessengerHandler extends Handler{ private static final String TAG = \"MessengerHandler\"; @Override public void handleMessage(Message msg) { switch (msg.what){ //客户端发来的信息标识 case MessengerActivity.FROM_CLIENT: Log.d(TAG, \"handleMessage: receive msg form clinet--\u003e\" +msg.getData().getString(\"msg\")); //对客户端进行reply回答 // 1. 通过接收到的到客户端的Message对象获取到Messenger信使 Messenger client = msg.replyTo; // 2. 创建一个信息Message对象,并把一些数据加入到这个对象中 Message replyMessage = Message.obtain(null, MessengerActivity.FROM_SERVICE); Bundle bundle = new Bundle(); bundle.putString(\"reply\", \"我是服务端发送的消息,我已经接收到你的消息了,你应该在你的客户端可以看到\"); replyMessage.setData(bundle); // 3. 通过信使Messenger发送封装好的Message信息 try { client.send(replyMessage); } catch (RemoteException e) { e.printStackTrace(); } break; default: super.handleMessage(msg); } } } /** * 创建一个Messenger信使 */ private final Messenger mMessenger = new Messenger(new MessengerHandler()); @Nullable @Override public IBinder onBind(Intent intent) { return mMessenger.getBinder(); } } 别忘了清单文件 \u003cservice android:name=\".message.MessengerService\" android:process=\"com.szysky.test\"/\u003e 2.客户端 直接用一个activity作为客户端, 首先绑定之前创建的服务端的Service, 绑定成功时通过ServiceConnection对象接收到服务端返回的IBinder,用IBinder对象创建一个Messenger. 通过这个Messenger就可以往服务端发送消息. 如果我们需要服务端也能够回应客户端. 那么就要在客户端同之前服务端一样通过Handle创建一个Messenger对象, 并把这个Messenger在通过连接成功返回的IBinder创建的Message对象通过replyTo参数传递给服务器. 这个服务器就可以通过replyTo参数来回应客户端. /** * 声明一个本进程的信使 用来监听并处理服务端传入的消息 */ private Messenger mGetReplyMessenger = new Messenger(new Handler(){ @Override public void handleMessage(Message msg) { switch (msg.what){ case FROM_SERVICE: Log.d(TAG, \"handleMessage: 这里是客户端:::\"+msg.getData().getString(\"reply\")); break; default: super.handleMessage(msg); } } }); /** * 创建一个服务监听连接对象 并在成功的时候给服务器发送一条消息 */ private ServiceConnection mConnection = new ServiceConnection() { //绑定成功回调 @Override public void onServiceConnected(ComponentName name, IBinder service) { // 利用服务端返回的binder对象创建Messenger并使用此对象想服务端发送消息 Messenger mService = new Messenger(service); Message obtain = Message.obtain(null, FROM_CLIENT); Bundle bundle = new Bundle(); bundle.putString(\"msg\", \"你好啊, 我是从客户端来\"); obtain.setData(bundle); // 需要把接收服务端回复的Messenger通过Message的replyTo传递给服务端 obtain.replyTo = mGetReplyMessenger; try { mService.send(obtain); } catch (RemoteException e) { e.printStackTrace(); } } @Override public void onServiceDisconnected(ComponentName name) { } }; //进行远端服务的连接 Intent intent = new Intent(MessengerActivity.this, MessengerService.class); bindService(intent, mConnection, Context.BIND_AUTO_CREATE); 本例测试代码在仓库对应项目的message包中 在使用Messenger进行数据传递必须将数据放入到Message中. 而Messenger和Message都实现了序列化接口. 所以可以在进程间通信. Message的能使用的载体只有what, arg1, arg2, Bundle 以及replyTo. 这里有一个载体需要注意object,它在同一个进程很实用,但是在版本2.2之前是不支持跨进程的,虽然进行了改进之后,但是也只是支持系统提供实现的某些对象才可以. 所以使用的时候需要注意. 顺便绘制了一个Messenger通信的流程图, 可以对代码的调用顺序理解的更清楚. ","date":"2016-08-02","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B002-ipc%E6%9C%BA%E5%88%B6/:4:3","tags":["android","笔记"],"title":"《Android 开发艺术探索》 02-IPC机制","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B002-ipc%E6%9C%BA%E5%88%B6/"},{"categories":null,"content":"使用AIDL 虽然Messenger使用方便, 但是要清楚它是以串行的方式处理客户端发来的消息,如果有大量并发的请求. 或者需求是跨进程调用服务端的方法时. 就无法使用Messenger. 这个时候就该AIDL 对于使用AIDL的流程简单梳理一遍 服务端 服务端创建一个Service用来监听客户端的连接请求, 然后创建一个AIDL文件,将暴露给客户端的接口在这个AIDL文件中声明,最后在Service中实现这个AIDL接口并在onBind()返回即可. 客户端 绑定服务端的Service,绑定成功后,将服务端返回来的Binder对象转成AIDL接口所属的类型,接着就可以直接调用AIDL中的方法了. AIDL相关代码在仓库项目的java路径下的aidl包中,包中可能是包含实现订阅的代码,可以通过git回退到’使用AIDL实现简单的进程通信’版本查看基础实现 详细代码在上面仓库中都有,这里不全部贴出来,记录一下需要注意的地方. AIDL中所支持的类型 基本数据类型 String 和 CharSequence List: 只支持ArrayList, 里面每个元素都必须能被AIDL支持 Map: 只支持HashMap, 里面的每个元素都必须被AIDL支持 Parcelable: 所有实现了Parcelable接口的对象 AIDL: 所有的AIDL接口本身也可以在AIDL文件中使用 这里请注意,上面支持类型中Parcelable和AIDL比较特殊,自定义的Parcelable对象和AIDL对象必须要显示的import引入, 这是AIDL的规范需要遵循, 如下Book类 import com.szysky.note.androiddevseek_02.aidl.Book;//必须Book的全限定名 interface IBookManager { List\u003cBook\u003e getBookList(); void addBook(in Book book); //这里标明输入型 } 如果用到了自定义对象实现了Parcelable那么就需要创建一个同名的aidl文件 package com.szysky.note.androiddevseek_02.aidl; parcelable Book; AIDL中除了基本数据类型外,其他类型的参数必须标上方向out , in, inout.分别表示输入,输出,输入输出型. 按需而定可以节省不必要的操作在底层实现的开销. 最后一点AIDL接口中只支持方法,不支持声明静态常量. 在服务端用了CopyOnWriteArrayList数组来保存所有书籍. 这个集合的特性是支持并发读写. 在说Binder的时候提到过, AIDL方法是在服务端Binder线程池中执行的, 所以当多个客户端同时连接,会存在多线程并发的问题. 所以使用CopyOnWriteArrayList集合可以进行自动的线程同步.与之相似的还有ConcurrentHashMap这个在LRU机制中使用到过 这里有知识点. 之前说过AIDL中能过使用的只有ArrayList. 而CopyOnWriteArrayList也并不是ArrayList的子类. 其实AIDL所支持的是抽象的List, 而List只是一个接口, 虽然服务端返回的是CopyOnWriteArrayList,但是在Binder中会按照List的规范去访问数据并最终形成一个新的ArrayList传递给客户端. 看下面的log图在客户端接收返回的CopyOnWriteArrayList实际上是ArrayList类型 git仓库的代码的aidl包中 最后保存的是实现了客户端和服务端的观察者模式(可以通过git版本切换之前代码), 通过客户端注册监听接口, 在服务端每当有新书来的时候,通知已经注册了的客户端. 需要注意的几点 线程问题 当有新书的时候,服务端回调的是客户端实现的接口里面的方法. 这个方法实际是在客户端的线程池中执行的. 所以要处理处理UI的问题, 解决方案可以创建一个Handler,将其切换到客户端的主线程中 private INewBookArrivedListener mNewBookListener = new INewBookArrivedListener.Stub() { @Override public void onNewBookArrived(Book book) throws RemoteException { // 如果有新书 那么此方法会被回调, 并且由于调用处服务端的Binder线程池, 所以给主线程的Handler发送消息,以切换线程 mhandler.obtainMessage(NEW_BOOK_ARRIVED, book).sendToTarget(); } }; 对象不一致,导致接触绑定失败 服务端不能再用CopyOnWriteArrayList来记录绑定过的客户端. 因为这里一定要清楚对象是不能跨进程的当我们客户端注册监听传入一个监听对象到服务端, 在解绑的时候再次传入一个进行判断与注册时相同的对象时删除达到解除绑定效果时是无效的. 因为服务端在注册和解绑的时候是两个反序列化的对象完全不一致. RemoteCallbackList是系统专门提供的用于删除跨进程listener的接口. 接收的是一个泛型,支持管理任意的AIDL接口,从声明就可以看出, 因为AIDL接口都继承IInterface 内部实现是一个Map结构 key是IBinder类型, value是Callback类型. ArrayMap\u003cIBinder, Callback\u003e mCallbacks= new ArrayMap\u003cIBinder, Callback\u003e(); IBinder key = listener.asBinder(); Callback value = new Callback(listener, cookie); //这里的Callback封装了真正的监听对象 不管是注册还是解注册,多进程到服务端都会生成不同的对象. 但是这些不同的对象有一个共同点, 底层的Binder对象是同一个, 利用这个特性可解决上面的问题. RemoteCallbackList 当客户端进程终止后, 它能够自动移出客户端所注册的listener. 并且内部实现了线程同步的功能, 所以在注册和解注册的时候不需要做额外的线程工作. 在使用的使用,虽然名字有List但是他并不是一个List我们要遍历的通知监听者的时候,要使用bigenBroadcast和finishBroadcase成对出现. //遍历集合 去调用客户端方法 int N = mListeners.beginBroadcast(); for (int i = 0; i\u003cN; i++){ INewBookArrivedListener listener = mListeners.getBroadcastItem(i); if (listener != null){ listener.onNewBookArrived(newBook); } } mListeners.finishBroadcast(); 当客户端调用远程服务的方法,被调用的方法运行在服务端的Binder线程池中,同时客户端会被挂起, 所以你如果在主线程(客户端的onServiceConnected和onServiceDisconnected就是UI线程)调用服务端的耗时方法, 你多点几次就很容易出现ANR. 比方说在服务端的getBookList()睡上十秒,可以复现ANR. 监听死亡状态: 在整理Binder的时候有说了一种DeathRecipient的方式,下两种都可以 onServiceDisconnected() UI线程被回调 binderDied() 在客户端的Binder线程池中被回调 还记得在绑定的时候bindService(intent,mConnection, Context.BIND_AUTO_CREATE);其中参数3如果设置这个模式, 当服务或线程死亡,还会重新启动的. 权限验证 在服务端的**onBinder()**回调中判断权限. 在服务端实现的AIDL接口中的**onTransact()**进行包名判断或者权限 第一种: 先清单文件中注册一个自定义的权限 \u003cpermission android:name=\"com.szysky.permission.ACCESS_BOOK_SERVICE\" android:protectionLevel=\"normal\"/\u003e 在清单文件中添加这个权限的使用资格 \u003cuses-permission android:name=\"com.szysky.permission.ACCESS_BOOK_SERVICE\"/\u003e 然后在**onBinder()**进行判断,如果没有那么就返回null, 这样客户端是无法绑定服务的 public IBinder onBind(Intent intent) { //做一下权限的验证 在清单文件中声明了一个, 并添加了使用权限 int check = checkCallingOrSelfPermission(\"com.szysky.permission.ACCESS_BOOK_SERVICE\"); if (check == PackageManager.PERMISSION_DENIED){ return null; } return mBinder; } 第二种 可以判断客户端的包名是否满足我们的","date":"2016-08-02","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B002-ipc%E6%9C%BA%E5%88%B6/:4:4","tags":["android","笔记"],"title":"《Android 开发艺术探索》 02-IPC机制","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B002-ipc%E6%9C%BA%E5%88%B6/"},{"categories":null,"content":"使用ContentProvider 相关代码在仓库项目的java路径下的provider包中 ContentProvider是Android提供专门用于不用应用进行数据共享的方式. 它的底层同样也是Binder. 因为系统封装, 所以它的使用比起AIDL要简单很多. 要实现一个内容提供者, 只需要写一个类继承ContentProvider,并复写六个抽象方法. 其中有四个是CURD操作方法. 一个**onCreate()用来做初始化. 一个getType()**用来返回一个Uri请求所对应的MIME类型,比如图片还是视频等. 如果我们不关心那么可是直接返回NULL或者*/*. 这六个方法根据Binder工作原理,都是运行在ContentProvider的进程中. 除了**onCreate()**是被系统回调运行在主线程, 其余的都在Binder的线程池中. 主要存储方式是表格的形式, 也可以支持文件格式,例如图片视频, 可以返回这类文件的句柄给外界来访问ContentProvider中的文件信息. 清单文件的声明 \u003cprovider android:authorities=\"com.szysky.note.androiddevseek_02.provider\" android:name=\".provider.BookProvider\" android:permission=\"com.szysky.PROVIDER\"/\u003e authorities: 后面的值是指定这个ContentProvider的唯一标识. permission: 添加一个权限认证, 对于访问者必须添加了这个使用权限的声明. 查询的时候通过Uri对authorities声明值得解析就可以找到对应的ContentProvider Uri uri = Uri.parse(\"content://com.szysky.note.androiddevseek_02.provider\"); getContentResolver().query(uri, null, null, null, null); 为了后续操作, 这里利用SQLiteOpenHelper来管理数据库,并创建两个表user和book,代码在仓库有,这里不写实现过程. 由于有两个表支持被访问, 所以应该为每一个不同的表设定单独的Uri和Uri_Code 并将其关联. 这样外界访问的时候可以根据Uri得到Uri_Code. 也就在ContentProvider知道要处理的具体事件. 在新建的ContentProvider类中进行关联, 如下 private static final String AUTHORITY = \"com.szysky.note.androiddevseek_02.provider\"; /** * 指定两个操作的Uri */ private static final Uri BOOK_CONTENT_URI = Uri.parse(\"content://\" +AUTHORITY + \"/book\"); private static final Uri USER_CONTENT_URI = Uri.parse(\"content://\" +AUTHORITY + \"/user\"); /** * 创建Uri对应的Uri_Code */ private static final int BOOK_URI_CODE = 1; private static final int USER_URI_CODE = 2; /** * 创建一个管理Uri和Uri_Code的对象 */ private static final UriMatcher sUriMatcher = new UriMatcher(UriMatcher.NO_MATCH); static { //进行关联 sUriMatcher.addURI(AUTHORITY, \"book\",BOOK_URI_CODE); sUriMatcher.addURI(AUTHORITY, \"user\",USER_URI_CODE); } 针对query方法进行演示,其他三个类似,代码有全部实现的例子, 在自定义Provider文件中. /** * 通过自动以的Uri来判断对应的数据库表名 */ private String getTableName(Uri uri){ String tableName = null; switch (sUriMatcher.match(uri)){ case BOOK_URI_CODE: tableName = DbHelper.BOOK_TABLE_NAME; break; case USER_URI_CODE: tableName = DbHelper.USER_TABLE_NAME; break; default:break; } return tableName; } /** * 在query中, 获取到Uri传入要查询的具体表名, 使用SQLiteOpenHelper来进行query的查询,并把结果返回 */ public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs, String sortOrder) { //获取表名 String tableName = getTableName(uri); if (tableName == null) throw new IllegalArgumentException(\"不被支持的Uri参数--\u003e\"+uri ); return mDb.query(tableName, projection, selection, selectionArgs, null, null, sortOrder,null); } 如果需要监听Provider内容的变化, 那么可以在Provider中update, delete, insert. 中操作完数据库之后. 使用getContentResolver().notifyChange(uri,null);来通知外界当前ContentProvider中数据已经发生改变. 而外部要想观察其变化. 使用ContentResolver的rigisterContentObserver方法来注册观察者. 线程安全问题 如果只有一个SQLiteDataBase对象被使用, 那么增删改查不会出现线程安全问题, 因为其内部对数据库的操作是有同步处理. 但是如果多个SQLiteDataBase对象来操作数据库就无法保证其线程安全. 这个时候就要注意了. ","date":"2016-08-02","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B002-ipc%E6%9C%BA%E5%88%B6/:4:5","tags":["android","笔记"],"title":"《Android 开发艺术探索》 02-IPC机制","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B002-ipc%E6%9C%BA%E5%88%B6/"},{"categories":null,"content":"使用Socket Socket也称为套接字. 是网络通信中的概念, 它分为流式套接字和用户数据包套接字两种. 分别对应于网络的传输控制层中TCP和UDP协议. 使用Socket通信, 需要在清单文件添加权限的申请 \u003c!--Socket通信额外需要的线程--\u003e \u003cuses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\"/\u003e \u003cuses-permission android:name=\"android.permission.INTERNET\"/\u003e 服务端 需要启动服务, 并且在线程中建立TCP服务, 然后监听一个端口. 当客户端建立连接的时候就会生成一个Socket流. 可以保持后续的持续通信. 每一个客户端都对应一个Socket. 如果客户端断开连接. 服务端需要做好相应的Socket流关闭并结束通话线程. 可以通过在客户端断开的时候服务端的接收字节流会是null来判断连接是否还存活. 首先需要开启一个新线程, Runnable接口这样实现, 以下是伪代码, 没有捕捉异常 // 监听 3333 端口 ServerSocket serverSocket = new ServerSocket(3333); // 判断服务是否断开 没有断开就继续监听端口 while (!mIsServiceDestoryed) { //这个是阻塞方法, 当有新的客户端连接,才会返回Socket值 final Socket accept = serverSocket.accept(); // 有了新的客户端 那就需要创建一个新的线程去维护 new Thread() { public void run() { // 这里做对一个Socket的具体操作 responseClient(accept); }}.start(); } private void responseClient(Socket client) throws IOException { //接收客户端消息 BufferedReader in = new BufferedReader(new InputStreamReader(client.getInputStream())); //发送到客户端 , 设置true参数就不需要手动的刷新输出流 PrintWriter out = new PrintWriter(new BufferedWriter(new OutputStreamWriter(client.getOutputStream())),true); out.println(\"欢迎来到直播间\"); //判断服务标志是否销毁, 没有销毁那么就一直监听此链接的Socket流 while (!mIsServiceDestoryed) { String str = in.readLine(); //这是一个阻塞方法 //判断如果取出来的是null,那么就说明连接已经断开 if (str == null) break; // 对客户端进行回复 out.println(\"我是回复消息\"); } //准备关闭一系列的流 ...... } 最后就是要在onDestroy()中把循环中判断服务存活的标识置为false, 让开启的线程都能自动走完关闭. 客户端 在onCreate()先startService开启TCP的服务, 然后开启一个线程准备连接Socket. 可以加上失败重连的的机制. 只要获取到了Socket, 就和之前服务端一样获取输入输出流进行对应的操作. 贴出客户端的核心代码, Runnable接口实现的 ,同样是伪代码 Socket socket = null; // 试图连接服务器, 如果失败休眠一秒重试 while(socket == null){ try { // 如果可以连接 3333 端口成功那么socket就不为null, 此循环也就结束 socket = new Socket(\"localhost\", 3333); mClientSocket = socket; // 获得输出流, 并设置true,自动刷新输出流里面的内容 mPrintWrite = new PrintWriter(new BufferedWriter(new OutputStreamWriter(mClientSocket.getOutputStream())),true ); } catch (IOException e) { SystemClock.sleep(1000); e.printStackTrace(); } } //准备接收服务器的消息. BufferedReader in = new BufferedReader(new InputStreamReader(mClientSocket.getInputStream())); //获得了socket流的读入段 只要activity不关闭一直循环读 while(!SocketActivity.this.isFinishing()){ // readLine()同样也是阻塞方法 String strLine = in.readLine(); if (strLine != null){ //TODO 获取到了服务端发来的数据, 做一些事情 //.... } } //走到这里 说明界面已经不存在, 进行扫尾动作 in.close(); mPrintWrite.close(); socket.close(); demo图例Socket相关代码存在仓库的socket包中 ","date":"2016-08-02","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B002-ipc%E6%9C%BA%E5%88%B6/:4:6","tags":["android","笔记"],"title":"《Android 开发艺术探索》 02-IPC机制","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B002-ipc%E6%9C%BA%E5%88%B6/"},{"categories":null,"content":"各种IPC的差异以及选择 名称 优点 缺点 使用场景 Bundle 简单易用 只能传输Bundle支持的数据类型 四大组件间的进程间通信 文件共享 简单易用 不适合高并发场景,并且无法做到进程间的即时通 无法并发访问情形, 交换简单的数据实时性不高的场景 AIDL 功能强大 使用稍复杂,需要处理好线程同步 一对多通信且有RPC需求 ContentProvider 在数据源访问方面功能强大,支持一对多并发数据共享 可以理解为受约束的AIDL,主要提供数据源的CRUD操作 一对多的进程间的数据共享 Messenger 功能一般, 支持一对多串行通信,支持实时通信 不能很好处理高并发,不支持RPC,数据通过Message进行传输, 因此只能传输Bundle支持的数据类型 低并发的一对多即时通信,无RPC需求,或者无需要返回结果的RPC需求 Socket 功能强大,可以通过网络传输字节流,支持一对多并发实时通信 实现细节稍微有点繁琐,不支持直接的RPC 网络数据交换 下一章: View的事件体系 ","date":"2016-08-02","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B002-ipc%E6%9C%BA%E5%88%B6/:5:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 02-IPC机制","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B002-ipc%E6%9C%BA%E5%88%B6/"},{"categories":null,"content":" ","date":"2016-08-01","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B001-activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E6%A8%A1%E5%BC%8F/","tags":["android","笔记"],"title":"《Android 开发艺术探索》 01-Activity的生命周期和模式","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B001-activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E6%A8%A1%E5%BC%8F/"},{"categories":null,"content":" 第一章: Activity的启动模式详解,与Intent-filter的匹配 blog相关代码仓库 ","date":"2016-08-01","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B001-activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E6%A8%A1%E5%BC%8F/:0:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 01-Activity的生命周期和模式","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B001-activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E6%A8%A1%E5%BC%8F/"},{"categories":null,"content":"Activity的生命周期 onCreate: 声明周期的第一个方法.做一些初始化的动作,例如setContentView onRestart: 表示Activity重新启动.当界面从不可见变为可见时调用,场景Home键切换,从任务栈返回 onStart: 表示Activity正在被启动.Activity为理论可见(取决上层界面是否透明),但不是前台无法操作. onResume: 表示Activity已经可见,并且为前台. 与onStart主要是前台后台,有无焦点的区别 onPause: 表示Activity正在停止. 做一些存储数据,停止动画操作.不能太耗时,这会影响新的Activity启动,onPause()必须先执行完,新Activity的onResume()才会执行. onStop: 表示Activity即将停止,可以做稍微重量级的回收工作,同样不能太耗时. onDestroy: 表示Activity即将被销毁. 可以做一些最终的资源释放 场景 当界面A打开界面B时的生命周期调用顺序: A的onPause()-\u003e B的onCreate() -\u003e B的onStart() -\u003e B的onResume() -\u003e A的onStop(). onStart()和onStop() 是针对Activity是否可见的角度回调 onResume()和onPause() 是针对Activity是否位于前台的角度回调的 ","date":"2016-08-01","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B001-activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E6%A8%A1%E5%BC%8F/:1:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 01-Activity的生命周期和模式","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B001-activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E6%A8%A1%E5%BC%8F/"},{"categories":null,"content":"异常情况下的生命周期 ","date":"2016-08-01","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B001-activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E6%A8%A1%E5%BC%8F/:2:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 01-Activity的生命周期和模式","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B001-activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E6%A8%A1%E5%BC%8F/"},{"categories":null,"content":"当系统配置发生改变的时候 Activity就会因为异常情况被销毁并重新创建.例如横竖屏切换,语言切换等. 当异常状态发生的时候. 在界面销毁前会调用onSaveInstanceState()进行当前界面的数据保存,如文本输入的数据,listView滚动的位置等. 在重建后会调用onRestoreInstanceState()进行因为异常重建的原始数据的恢复. 准确的说onSaveInstanceState() 会在onStop()之前执行, 而onRestoreInstanceState会在onStart之后执行. 当屏幕发生旋转时,声明周期调用过程如下: 这里我们要清楚,当发生了异常情况下,系统会帮我们自动恢复大部分的数据,但是如果我们想要自己从异常中恢复.那么我们可以通过onCreate()和onRestoreInstanceState()中的参数Bundle来进行值得保存. 当正常情况下onCreate中的Bundle类型参数是为null的. 而onRestoreInstanceState是不会被调用的. 当异常发生后的重建,onCreate,onRestoreInstanceState都会被触发,并且其中的Bundle类型参数都不为null ","date":"2016-08-01","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B001-activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E6%A8%A1%E5%BC%8F/:2:1","tags":["android","笔记"],"title":"《Android 开发艺术探索》 01-Activity的生命周期和模式","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B001-activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E6%A8%A1%E5%BC%8F/"},{"categories":null,"content":"资源内存不足时低优先级的Activity被杀死 这种场景不好模拟,但是在存储和恢复的过程是与上面的过程一致的. 关于Activity的优先级的高低 前台Activity–正在和用户交互的Activity,优先级最高 可见但是非前台Activity–比如Activity中弹出了一个对话框,导致Activity可见但是无法操作. 后台Activity–已经被暂停的Activity,比如执行了onStop,优先级最低. ","date":"2016-08-01","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B001-activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E6%A8%A1%E5%BC%8F/:2:2","tags":["android","笔记"],"title":"《Android 开发艺术探索》 01-Activity的生命周期和模式","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B001-activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E6%A8%A1%E5%BC%8F/"},{"categories":null,"content":"禁止异常重建Activity 如果不想Activity重建.可以通过清单文件中对activity标签进行配置. android:configChanges=\"orientation|screenSize\" 当给一个Activity声明了上述的属性之后,当手机旋转的时候,activity不会重建,也就没有任何声明周期方法的回调, 但是会调用onConfigurationChanged()方法. orientation: 屏幕方向发生了改变,手机旋转 screenSize: 屏幕的尺寸信息发生改变,此属性和编译版本有关系,当minSdkVersion和targetSdkVersion均低于13,此选项不会导致界面重启.如果高于那么会重启. 所以这两个最好成对出现. 日常开发中我们比较常用的local,orientation,keyboardHidden,uiMode. local为本地语言切换. uiMode界面模式发生切换,如夜间模式(API8中增加) ","date":"2016-08-01","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B001-activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E6%A8%A1%E5%BC%8F/:2:3","tags":["android","笔记"],"title":"《Android 开发艺术探索》 01-Activity的生命周期和模式","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B001-activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E6%A8%A1%E5%BC%8F/"},{"categories":null,"content":"Activity的启动模式 当我们打开的activity会被系统以任务栈的形式来存储起来.后进先出.当每一个任务栈为空的时候这个栈就会被回收 standard: 默认模式,就是新进入的压在已存在的界面之上. singleTop: 栈顶复用模式. singleTask: 栈内复用模式 singleInstance: 栈内单例模式 singleTop 如果新Activity已经位于任务栈的栈顶,那么此Activity不会被重新创建,同时onNewIntent()会被回调. 如果使用此模式,那么在任务栈中栈顶到栈低为CBA的情况下,再次打开C,那么C界面的onCreate()和onStart()不会被调用,真正的调用时onPause()–\u003eonNewIntent()–\u003eonResume() singleTask 如果用栈内复用,当打开C时候,会查询所有的任务栈,如果有任务栈包含C,那么把这个任务栈移动到所有栈的首位,并清除掉这个栈内C到栈顶的其他Activity,最后调用C的onNewIntent()方法. 如果没有那就直接在所需任务栈的栈顶创建C的实例. 这里由于singleTask默认具有clearTop的效果,所以会清除C以上activity的出栈. 这里和具体的启动模式有关. 所需任务栈: 和一个参数有关系,TaskAffinity.这个参数标识了一个Activity所需要的任务栈的名字,默认情况下所有的Activity的所需的任务栈的名字都为应用包名. 这里我们可以通过命令adb shell dumpsys activity测试一下,打开顺序为MainActivity–\u003eModeSingleTopArc 当我们不指定taskAffinity的所需栈的时候,查看任务栈的结果为: 如果指定了taskAffinity 这个时候任务栈的状况为: \u003cactivity android:name=\".launchmode.ModeSingleTaskAct\" android:launchMode=\"singleTask\" android:taskAffinity=\".nishibendan\"/\u003e 一般情况下TaskAffinity属性一般和singleTask启动模式或者allowTaskReparenting属性配对使用,其他情况下使用没有意义. 另外任务栈分为前台任务栈和后台任务栈,后台任务栈中的activity属于暂停状态,用户可以切换将后台调到前台. singleInstance 这个模式是加强版的singleTask,除了singleTask具有的属性之外,还具有创建新栈的能力,这个栈只有这一个实例. 就是说如果假设EActivity没有被创建过,那么创建时,首先会创建一个新的任务栈,然后创建实例放入这个新的栈内,然后下一个实例不会和这个EActivity所属栈共存,会创建一个新的栈继续存放. ","date":"2016-08-01","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B001-activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E6%A8%A1%E5%BC%8F/:3:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 01-Activity的生命周期和模式","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B001-activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E6%A8%A1%E5%BC%8F/"},{"categories":null,"content":"给Activity添加启动模式 通过清单文件中activity标签添加android:launchMode=\"singleTask|singleTop|singleInstance\" 通过代码中startActivity(Intent)中的intent通过addFlags(Intent.FLAG_ACTIVITY_NEW_TASK) 优先级 代码设置优先于xml布局中的设置. 限定范围不同 xml无法直接为其设置FLAG_ACTIVITY_CLEAR_TOP. 代码添加flag无法添加singleInstance模式. 注意: 如果通过代码添加添加Intent.FLAG_ACTIVITY_NEW_TASK和xml中设置singleTask是不一样的.代码动态添加是没有clean_top的效果,看图: ","date":"2016-08-01","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B001-activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E6%A8%A1%E5%BC%8F/:3:1","tags":["android","笔记"],"title":"《Android 开发艺术探索》 01-Activity的生命周期和模式","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B001-activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E6%A8%A1%E5%BC%8F/"},{"categories":null,"content":"Activity的Flags 影响启动模式的标识位: 可以设定Activity的启动模式 影响运行时的标识位: 可以影响运行的Activity的运行状态 FLAG_ACTIVITY_NEW_TASK相对于xml中的singleTask,但是动态的时候需要给intent添加两个标志位,否则无法达到效果,如下 intent3.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK); intent3.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP); FLAG_ACTIVITY_SINGLE_TOP相对于xml中的singleTop FLAG_ACTIVITY_CLEAR_TOP在同一个任务栈中所有位于它上面的Activity都要出栈,此标志一般和singleTask一起出现. 如果启动模式为standard它连同上面的都要出栈,之后系统会创建一个新的实例放入栈顶. ","date":"2016-08-01","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B001-activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E6%A8%A1%E5%BC%8F/:3:2","tags":["android","笔记"],"title":"《Android 开发艺术探索》 01-Activity的生命周期和模式","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B001-activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E6%A8%A1%E5%BC%8F/"},{"categories":null,"content":"IntentFilter匹配规则 显示调用: 需要指定组件信息如包名,类名. 隐式调用: 不需要指定组件信息, Intent需要匹配目标组件IntentFilter中所设置的过滤信息即可. IntentFilter的过滤信息有action,category,data. 一个Activity可以有多个Intentfilter,只要intent能匹配任意一组intent-filter即可成功启动. 关于每一项的具体匹配规则 action: 本身是字符串. Intent匹配中存在action且必须和过滤规则中的其中一个action相同,那么action就算匹配ok. xml中必须有一个action声明. category: 本身是字符串.Intent匹配中intent可以不存在category,但是如果添加了category那么必须要和定义的intent-filter中的category一致,否则失败. 如果我们在Intent不添加的时候,那么系统会自动为我们添加一个预定义的属性android.intent.category.DEFAULT. xml中需添加这个默认的category属性. data: xml过滤规则中可以不声明,如果声明只要匹配了一个就可以.一般情况下data有两部分组成mimeType和URI. mimeType指媒体类型,URI规则如下: \u003cscheme\u003e://\u003chost\u003e:\u003cport\u003e/[path] 如下实例: scheme:表示URI的模式,例如http, file, content. http://www.baidu.com:80/search/info 最简单的隐式打开 //代码中 Intent intent = new Intent(); intent.setAction(\"com.test1\"); startActivity(intent); //xml中 \u003cactivity android:name=\".intentfilter.FilterAct\"\u003e \u003cintent-filter\u003e \u003caction android:name=\"com.test1\"/\u003e \u003ccategory android:name=\"android.intent.category.DEFAULT\"/\u003e \u003c/intent-filter\u003e \u003c/activity\u003e 一个比较完整的匹配代码 //代码中 Intent intent = new Intent(); intent.setAction(\"com.test1\"); intent.addCategory(\"com.category1\"); //intent.setDataAndType(Uri.parse(\"content://\"),\"audio/plain\");//如果过滤规则中没有声明URI的属性,那么会有默认值content和file的属性 intent.setDataAndType(Uri.parse(\"http://\"),\"audio/plain\"); startActivity(intent); //xml中 \u003cactivity android:name=\".intentfilter.FilterAct\"\u003e \u003cintent-filter\u003e \u003caction android:name=\"com.test1\"/\u003e \u003caction android:name=\"com.test2\"/\u003e \u003ccategory android:name=\"com.category1\"/\u003e \u003ccategory android:name=\"com.category2\"/\u003e \u003ccategory android:name=\"android.intent.category.DEFAULT\"/\u003e \u003cdata android:mimeType=\"text/plain\"/\u003e \u003cdata android:mimeType=\"audio/plain\" android:scheme=\"http\"/\u003e \u003c/intent-filter\u003e \u003c/activity\u003e 在进行data属性匹配的时候尽量使用setDataAndType, 因为源码中setData和setType会把彼此属性置为null. Intent-filter匹配规则对于Service和BroadcastReceiver也是同样. 不过建议Service的使用尽量使用显示调用服务. ","date":"2016-08-01","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B001-activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E6%A8%A1%E5%BC%8F/:4:0","tags":["android","笔记"],"title":"《Android 开发艺术探索》 01-Activity的生命周期和模式","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B001-activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E6%A8%A1%E5%BC%8F/"},{"categories":null,"content":"判断是否有匹配的Intent PackageManager的resolveActivity()方法 Intent的resolveActivity()方法 使用演示: ResolveInfo resolveInfo = getPackageManager().resolveActivity(intent, PackageManager.MATCH_DEFAULT_ONLY); 参数二使用PackageManager.MATCH_DEFAULT_ONLY,意义在仅仅匹配哪些在intent-filter中声明 \u003ccategory android:name=\"android.intent.category.DEFAULT\"/\u003e,只要使用这个标记不返回null,那么startActivity就一定可以打开. 如果不用这个标记就会把没有设置default的匹配出来.从而导致判断失败.因为不含有DEFAULT这个category的Activity是无法接收隐式Intent的 这样如果返回的为null,那就是没有匹配到,如果不为null那就是可以匹配. 下一章: IPC机制 ","date":"2016-08-01","objectID":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B001-activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E6%A8%A1%E5%BC%8F/:4:1","tags":["android","笔记"],"title":"《Android 开发艺术探索》 01-Activity的生命周期和模式","uri":"/posts/android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2-%E7%AC%94%E8%AE%B001-activity%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E5%92%8C%E6%A8%A1%E5%BC%8F/"},{"categories":null,"content":" ","date":"2016-07-18","objectID":"/posts/retrofit-%E4%B8%80-%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/","tags":["android","Retrofit"],"title":"Retrofit(一)-入门使用","uri":"/posts/retrofit-%E4%B8%80-%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"体验RESTFul风格的请求, Retrofit ","date":"2016-07-18","objectID":"/posts/retrofit-%E4%B8%80-%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/:0:0","tags":["android","Retrofit"],"title":"Retrofit(一)-入门使用","uri":"/posts/retrofit-%E4%B8%80-%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"简介 Retrofit出自Square公司. 是一个基于RESTFul风格的网络请求库. 关于RESTFul风格,就是不同的请求操作通过在域名之后追加不同字段来区分.相对于服务器每一个请求都对应一个文件夹或者文件. 对同一个接口增删改查充分发挥对一个文件的PUT, POST, DELETE, GET. ","date":"2016-07-18","objectID":"/posts/retrofit-%E4%B8%80-%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/:1:0","tags":["android","Retrofit"],"title":"Retrofit(一)-入门使用","uri":"/posts/retrofit-%E4%B8%80-%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"1.Retrofit的快速使用 这里针对的Retrofit2.0说明.在Retrofit2.0中是内部依赖于OkHttp,已经导入OkHttp3,所以不需要再如Retrofit1.x中需要额外导入okhttp. 首先添加网络权限这个必须的 ``` \u003cuses-permission android:name=\"android.permission.INTERNET\"/\u003e ``` 添加Gradle依赖 在app/build.gradle文件中dependencies{}添加依赖. Retrofit官网,可查看最新版本 ``` compile 'com.squareup.retrofit2:retrofit:2.0.1' ``` 创建Api请求接口 在Retrofit中每一个请求都会对应一个Interface接口. 进行网络请求的时候通过传入我们自定义的接口.class来实现不同的网络请求. 假设我们需要请求的API为完整形式为: https://api.github.com/repos/square/retrofit/contributors 其中square和retrofit可变参数. 那么我们可以这样定义请求接口. 创建一个IAPIGitHub接口 ``` public interface IAPIGitHub { @GET(\"repos/{owner}/{repo}/contributors\") Call\u003cResponseBody\u003e send(@Path(\"owner\") String owner,@Path(\"repo\") String repo); } ``` 首先注解@GET就是表示get请求方式.其中参数追加的字符串为域名后面的需要拼接的地址.这里需要注意可以直接放入一个完整路径,如果你不是很了解,那么请注意一定不要在参数字符串首位以/斜杠开始这里后面会详细说明. 在请求地址注解的参数中如果有需要动态设置的变量那么这个变量用{}括起来. 在下面的抽象方法的形参中,使用@Path注解声明在使用的时候动态传入,@Path注解中的参数必须要与@GET注解路径中的花括号括起来的一一对应. 这样才能知道以后传入的参数对应的是哪一个. 创建Retrofit并发送请求 创建实例 ``` Retrofit retrofit = new Retrofit.Builder() .baseUrl(\"https://api.github.com/\") .build(); ``` baseUrl就是域名, 会拼接之后API接口的地址. 这里注意baseUrl中的地址最好是以/斜杠结尾.后面会说明. ``` //传入之前创建的API接口的class文件,创建接口对象 GitHubApi repo = retrofit.create(IAPIGitHub.class); //调用API的抽象放方法, 生成请求对象 Call\u003cResponseBody\u003e call = repo.send(mUserName, mRepo); //调用enqueue,采用异步方式请求 call.enqueue(new Callback\u003cResponseBody\u003e() { @Override public void onResponse(Call\u003cResponseBody\u003e call, Response\u003cResponseBody\u003e response) { //网络请求返回的结果 String result = response.body().string(); } @Override public void onFailure(Call\u003cResponseBody\u003e call, Throwable t) {} }); ``` 如果想取消一个操作的 call.cancel(); 到此一个简单的请求就结束了. 接下来看一看Retrofit的不一样的地方. ","date":"2016-07-18","objectID":"/posts/retrofit-%E4%B8%80-%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/:2:0","tags":["android","Retrofit"],"title":"Retrofit(一)-入门使用","uri":"/posts/retrofit-%E4%B8%80-%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"2.网络请求log 只需要添加日志拦截器,我们就可以取出从请求到结束的所有信息,包括请求头,请求体,响应头,响应体. 添加Gradle依赖 因为Retrofit与日log拦截独立,所以需要我们手动导入. ``` compile 'com.squareup.okhttp3:logging-interceptor:3.4.1' ``` 实例化我们自己的OkHttp实例 我们知道Retrofit2.0是基于OkHttp的封装. 那么也就可以在实例化Retrofit得时候传入我们自己定义的OkHttp实例. 因为日志拦截是OkHttp的功能. 如下 ``` //创建okhttp的日志拦截器 OkHttpClient okhttpClient = new OkHttpClient(); //只有在debug调试环境中才会显示过滤日志 if (BuildConfig.DEBUG) { HttpLoggingInterceptor logging = new HttpLoggingInterceptor(); logging.setLevel(HttpLoggingInterceptor.Level.BODY); okhttpClient = okhttpClient.newBuilder().addInterceptor(logging).build(); } ``` 然后在我们创建Retrofit实例的时候添加上我们自定义的okhttp ``` Retrofit retrofit = new Retrofit.Builder() .client(okhttpClient) .baseUrl(\"https://api.github.com/\") .build(); ``` 看一些过滤的结果: 注意我这里使用的是百度API一个查询手机号归属地的接口. 免费API接口地址. 可以注册一下用这个测试. 在上面的setLevel中. 传入了一个HttpLoggingInterceptor.Level.BODY,这里还有两个属性 Level.BODY: 一个完整的日志过滤,从发送请求到接收响应. Level.BASIC: 只有最基本的请求地址信息. Level.HEADERS:部分完整, 不包含response响应体. ","date":"2016-07-18","objectID":"/posts/retrofit-%E4%B8%80-%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/:3:0","tags":["android","Retrofit"],"title":"Retrofit(一)-入门使用","uri":"/posts/retrofit-%E4%B8%80-%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"3.Convert转换器 在上面我们在接收response响应的时候是默认的ResponseBody对象, 返回的是一个json字符串. 但是在创建Retrofit的时候我们可以添加转换器. 例如,把之前返回的json字符串直接在response响应的时候转成我们需要的对象类型!! 以下是Retrofit中convert支持的类型. 下面演示使用GSON转换器的例子: 1.添加Gradle依赖 上面给出了多种支持类型,这里主要添加的转换类型依赖包必须和Retrofit依赖的版本一致!! ``` compile 'com.squareup.retrofit2:converter-gson:2.0.1' ``` 2.创建Javabean对象,并创建API请求接口 这里还是以之前查询手机归属地的API说明. 创建接口返回json字符串的javabean对象. 然后创建一个API请求所对应的请求接口. 大体和之前默认基本相似,看下图 然后创建Retrofit对象,这里要注意加上addConverterFactory(GsonConverterFactory.create()),如下 然后就如同上面步骤一样. 加载API接口class,调用接口抽象方法, 调用enqueue使请求入队. 不同之处.在callback的response回调用,response.body()返回的就是一个之前定义请求接口的指定的泛型,我们的javabean对象. 注意: 当解析发生错误时: 在结果不能被解析的情况下，response.body()会返回null 这里需要特别处理 当请求响应码(这里指最初的请求,并不是服务器接口内部自定义的响应码)为404,403等. response也会被回调,在response.errorBody().string()中可以获取错误信息 ","date":"2016-07-18","objectID":"/posts/retrofit-%E4%B8%80-%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/:4:0","tags":["android","Retrofit"],"title":"Retrofit(一)-入门使用","uri":"/posts/retrofit-%E4%B8%80-%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"4.@URL组合和@Path 上面说过在使用baseurl地址最好以/结尾, 而接口地址追加最好不用/开头. 这里说说原因 Retrofit2.0中对于baseUrl和@URL的拼接,是根据路径的不同何以组合多种. 如下 String BASE_URL = http://apis.baidu.com/apistore/;这句表示域名下的名字叫apistore的文件夹 String BASE_URL = http://apis.baidu.com/apistore;这样会报错!! baseUrl不能指定为一个文件 String BASE_URL = http://apis.baidu.com/; 和下面一样效果, 估计对域名会自动判断分隔符,没有加上,有就不处理 String BASE_URL = http://apis.baidu.com; 所以总结下来关于baseUrl最好以/结尾, 可以指向一个文件夹,但不能指向一个文件. 接下来看看@GET,@POST,PUT…,注解中写的的拼接地址与baseUrl的组合效果. 其实就是后续追加的如果是/开始那么就表示绝对路径,根目录下(域名地址). 反之那么就表示相对路径,只是追加在baseUrl的后面. 在开发中我们经常用的就是指定基础域名已/结尾. 拼接地址通常用相对路径,不用/开头. 其实上面再@Get(\"xxxxx/xxxx\")这种形式相当于如下 ``` @GET() Call\u003cRequestBody\u003e send(@Url String urlStr); ``` 可以看出没有什么区别,实际场景如何使用按照需求. 那么如果我们知道一整个完整路径,但是中间的某一个为动态的应该怎么做? 这里就可以利用@Path 例如这样 http://apis.baidu.com/xxx/demo 这里的xxx可能为dev也可能为master. 需要动态传入 各个场景使用不同的方法, 还是看自家服务器的接口来定什么样的请求吧. ","date":"2016-07-18","objectID":"/posts/retrofit-%E4%B8%80-%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/:5:0","tags":["android","Retrofit"],"title":"Retrofit(一)-入门使用","uri":"/posts/retrofit-%E4%B8%80-%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"5.添加请求头 利用@Headrs添加一组字符串请求头,如下 ","date":"2016-07-18","objectID":"/posts/retrofit-%E4%B8%80-%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/:6:0","tags":["android","Retrofit"],"title":"Retrofit(一)-入门使用","uri":"/posts/retrofit-%E4%B8%80-%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"6.Get请求 在前面的例子中,演示的是get请求方式,例如: 单一参数请求 这里请求的路径: http://apis.baidu.com/mobilenumber/mobilenumber 因为在定义接口使用了@Query注解,所以请求后的变成了http://apis.baidu.com/mobilenumber/mobilenumber?phone=xxxx @Query: 用来进行如网页表单查询时,在域名? 进行的追加的键值对值. 当我们准备发送请求的时候就会填入键值对key对应的value值,这里相当于上面的手机号码. 多个参数请求 你可能也已经发现了,如果表单的键值对有许多,比如5对,那么如果使用上面@Query注解,在定义请求接口的时候就需要定义5个形参,而实际调用的时候就需要传入5个参数!!这明显不符合代码编写规范. 所以square又给我们一种方式解决此类问题@QueryMap QueryMap: 声明一个map集合,key和value都是String. 在使用的时候只需传入一个map集合,内部会遍历出来追加到请求地址后面. 看下面演示. ","date":"2016-07-18","objectID":"/posts/retrofit-%E4%B8%80-%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/:7:0","tags":["android","Retrofit"],"title":"Retrofit(一)-入门使用","uri":"/posts/retrofit-%E4%B8%80-%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"7.Post请求 关于get和post的请求我们应该清楚,get只能在拼接请求地址.而post既可以拼接地址,也可以在请求体里面发送内容.而请求体里面写入的内容就不再像get请求拼接那样局限性很高. 我们可以在请求体里面放入表单键值对, 图像二进制, json字符串… @FormUrlEncoded 用@FormUrlEncoded注解来发送表单数据 用@Field注解和参数来指定每个表单项的Key，value为参数的值 代码如下: 用Charles对app进行抓包查看请求头的信息,如下: 我们看到在AS的控制台中Content-Length: 19 就是指name=master\u0026id=1234这些内容19个字节. 所以其实也就是HTTP协议中POST请求Content-Type: application/x-www-form-urlencoded类型的方式. @Multipart @Multipart注解来发送Multipart数据 @Part注解来定义需要发送的文件 @Multipart @PUT(\"/user/photo\") User updateUser(@Part(\"photo\") TypedFile photo, @Part(\"description\") TypedString description); ","date":"2016-07-18","objectID":"/posts/retrofit-%E4%B8%80-%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/:8:0","tags":["android","Retrofit"],"title":"Retrofit(一)-入门使用","uri":"/posts/retrofit-%E4%B8%80-%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":"8.拦截器Interceptor 在之前的log日志过滤其实就是使用了拦截器. 不过拦截器对象添加了Retrofit为我们提供现成的log日志拦截器. 我们可以自己创建一个Interceptor,如下 ``` OkHttpClient client = new OkHttpClient(); client.interceptors().add(new Interceptor() { @Override public Response intercept(Chain chain) throws IOException { Response response = chain.proceed(chain.request()); // Do anything with response here return response; //一定不要返回null,会直接抛出异常 } }); ``` 然后在创建Retrofit的builder链式调用添加到client()中. ","date":"2016-07-18","objectID":"/posts/retrofit-%E4%B8%80-%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/:9:0","tags":["android","Retrofit"],"title":"Retrofit(一)-入门使用","uri":"/posts/retrofit-%E4%B8%80-%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/"},{"categories":["android"],"content":" ","date":"2016-07-12","objectID":"/posts/mac%E7%B3%BB%E7%BB%9Fandroid%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81/","tags":["android"],"title":"mac系统android编译源码","uri":"/posts/mac%E7%B3%BB%E7%BB%9Fandroid%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81/"},{"categories":["android"],"content":"= =!! 太痛苦, 放弃保智商…. ","date":"2016-07-12","objectID":"/posts/mac%E7%B3%BB%E7%BB%9Fandroid%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81/:0:0","tags":["android"],"title":"mac系统android编译源码","uri":"/posts/mac%E7%B3%BB%E7%BB%9Fandroid%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81/"},{"categories":["android"],"content":"操作环境 mac系统: OS X EI Captian 10.11.5 下载源码: Android 6.0.1 结果: mac环境配置环境, 虚拟机可以启动, 真机使用构建的镜像没有试验. 源码导入ok,调试没做. 首先丢出链接: Google官方源码构建教程 (自备梯子). 我就直接记录我的操作步骤,不说明原因,因为我也不会! ","date":"2016-07-12","objectID":"/posts/mac%E7%B3%BB%E7%BB%9Fandroid%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81/:0:1","tags":["android"],"title":"mac系统android编译源码","uri":"/posts/mac%E7%B3%BB%E7%BB%9Fandroid%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81/"},{"categories":["android"],"content":"step_1 首先mac文件系统模式是不区分大小写, 但是git托管不是. 所以创建一个大小写敏感的磁盘镜像 ``` $ sudo hdiutil create -type SPARSE -fs 'Case-sensitive Journaled HFS+' -size 80g ~/android.dmg ``` tip: 这里推荐80g的大小, 首先源码就40多G, 编译之后72G(如果只想看看源码那就50G够了,但是如果想调试,刷机,模拟步骤最好80G,有人说如果可以删除AOSP根目录下的.repo文件夹,可以省出27G,至于有没有影响请自行测试). ","date":"2016-07-12","objectID":"/posts/mac%E7%B3%BB%E7%BB%9Fandroid%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81/:0:2","tags":["android"],"title":"mac系统android编译源码","uri":"/posts/mac%E7%B3%BB%E7%BB%9Fandroid%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81/"},{"categories":["android"],"content":"step_2 把刚刚创建的镜像挂起. 可以直接在~/根目录下双击刚刚创建的android.dmg.sparseimage,也可以如下 ``` $ sudo hdiutil attach ~/android.dmg.sparseimage -mountpoint /Volumes/android ``` ","date":"2016-07-12","objectID":"/posts/mac%E7%B3%BB%E7%BB%9Fandroid%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81/:0:3","tags":["android"],"title":"mac系统android编译源码","uri":"/posts/mac%E7%B3%BB%E7%BB%9Fandroid%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81/"},{"categories":["android"],"content":"step_3 设置文件的限制.官网提示设置。Mac 系统下默认只能同时打开 1024 个文件，而在进行 Android 源码编译时有可能会超出这个限制，因此需要解除这个限制。在~/.bash_profile中添加以下内容： ``` # set the number of open files to be 1024 ulimit -S -n 1024 ``` ","date":"2016-07-12","objectID":"/posts/mac%E7%B3%BB%E7%BB%9Fandroid%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81/:0:4","tags":["android"],"title":"mac系统android编译源码","uri":"/posts/mac%E7%B3%BB%E7%BB%9Fandroid%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81/"},{"categories":["android"],"content":"step_4 安装必须的关联工具 Xcode 点我下载有的帖子说Xcode版本不能太高, 但博主这里没有出现问题. MacPorts 点我下载主要安装make , git 和 GPG ``` $ POSIXLY_CORRECT=1 sudo port install gmake libsdl git gnupg ``` ","date":"2016-07-12","objectID":"/posts/mac%E7%B3%BB%E7%BB%9Fandroid%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81/:0:5","tags":["android"],"title":"mac系统android编译源码","uri":"/posts/mac%E7%B3%BB%E7%BB%9Fandroid%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81/"},{"categories":["android"],"content":"step_5 安装repo, 因为android源码托管就是在git利用repo来辅助管理的 ``` # 这两个命令是创建一个bin目录,并把这个bin目录加到全局变量里面 $ mkdir ~/bin $ PATH=~/bin:$PATH # 这里下载repo 并改变其权限方便后面调用 $ curl https://storage.googleapis.com/git-repo-downloads/repo \u003e ~/bin/repo $ chmod a+x ~/bin/repo ``` ","date":"2016-07-12","objectID":"/posts/mac%E7%B3%BB%E7%BB%9Fandroid%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81/:0:6","tags":["android"],"title":"mac系统android编译源码","uri":"/posts/mac%E7%B3%BB%E7%BB%9Fandroid%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81/"},{"categories":["android"],"content":"step_6 把我们的下载的源码包放入到最开始创建的磁盘镜像中. 我的下载步骤是这样的.利用国内的镜像下载,下一个大的初识包25G左右,感觉比较省事,开始步骤说明 进入到~/bin文件夹中打开repo文件 修改开始的https://android.googlesource.com/ 使用 https://aosp.tuna.tsinghua.edu.cn/ 代替. cd到创建的磁盘镜像中 ``` wget https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar # 下载初始化包 # 说明: 如果掉网了没关系 加上-c支持断点续传 如下 wget -c https://mirrors.tuna.tsinghua.edu.cn/aosp-monthly/aosp-latest.tar # 下载初始化包 # 下载完毕之后开始解压.命令如下 $ tar xf aosp-latest.tar $ cd AOSP # 解压得到的 AOSP 工程目录 # 这时 ls 的话什么也看不到，因为只有一个隐藏的 .repo 目录. 命令如下 $repo sync # 正常同步一遍即可得到完整目录 ``` ","date":"2016-07-12","objectID":"/posts/mac%E7%B3%BB%E7%BB%9Fandroid%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81/:0:7","tags":["android"],"title":"mac系统android编译源码","uri":"/posts/mac%E7%B3%BB%E7%BB%9Fandroid%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81/"},{"categories":["android"],"content":"step_7 这时候源码都有了, 准备编译 这里需要注意如果你是zsh那么你需要切换之前的bash终端 ``` $ chsh -s /bin/bash #切换终端模式 ``` 然后可以重新打开终端进入原来的路径继续下面的步骤 ``` $ source build/envsetup.sh $ lunch aosp_arm-eng #aosp_xxx xxx为各个版本的各种适用场景,官网有说明 $ make -j4 #j后面的数据是线程的处理数, 看你的电脑是几核的,对应1到2倍 ``` 这个过程有2个小时吧. 有过一次错误. ninja: build stopped: subcommand failed.make: *** [ninja_wrapper] Error 1 解决方案 AOSP/prebuilts/sdk/tools中的jack-admin文件的start-server)函数下面(443行) ``` isServerRunning RUNNING=$? if [ \"$RUNNING\" = 0 ]; then echo \"Server is already running\" else #JACK_SERVER_COMMAND=\"java -XX:MaxJavaStackTraceDepth=-1 -Djava.io.tmpdir=$TMPDIR $JACK_SERVER_VM_ARGUMENTS -cp $LAUNCHER_JAR $LAUNCHER_NAME\" #原有的隐藏 JACK_SERVER_COMMAND=\"java -Djava.io.tmpdir=$TMPDIR $JACK_SERVER_VM_ARGUMENTS-Xmx2048M -cp $LAUNCHER_JAR $LAUNCHER_NAME\" #新增的 echo \"Launching Jack server\" $JACK_SERVER_COMMAND ``` 参考地址: 点我 ","date":"2016-07-12","objectID":"/posts/mac%E7%B3%BB%E7%BB%9Fandroid%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81/:0:8","tags":["android"],"title":"mac系统android编译源码","uri":"/posts/mac%E7%B3%BB%E7%BB%9Fandroid%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81/"},{"categories":["android"],"content":"step_8 开始运行了 这里我只是运行了模拟器,起来了.真机因为没有nexus5或者6的机器我就没有去试. 运行模拟器 $ emulator 稍等一会吧,有个五到十分钟,不知道是不是我之前生成的镜像是arm模式的原因.. 如果是刷机的话 如果有真机并且连接到了电脑，准备刷机的话，输入以下命令： $ adb reboot bootloader 进入刷机模式后，输入下面的指令： $ fastboot -w flashall 我走了上面的第一步报了一个 ``` build/core/config.mk:608: *** Error: could not find jdk tools.jar at /System/Library/Frameworks/JavaVM.framework/Versions/Current/Commands/../lib/tools.jar, please check if your JDK was installed correctly. Stop. ``` 解决方案: $ export ANDROID_JAVA_HOME=$(/usr/libexec/java_home -v 1.7) 参考链接 ","date":"2016-07-12","objectID":"/posts/mac%E7%B3%BB%E7%BB%9Fandroid%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81/:0:9","tags":["android"],"title":"mac系统android编译源码","uri":"/posts/mac%E7%B3%BB%E7%BB%9Fandroid%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81/"},{"categories":["android"],"content":"step_9 最后就是导入源码了 ``` $ mmm development/tools/idegen/ $ development/tools/idegen/idegen.sh ``` 上面第一条命令是按模块编译我们只需要编译idegen模块即可,不需要整个android的. 如果这条提示common not found 那么重新执行一遍$ source build/envsetup.sh 再执行 mmm的命令 第二条就是生成我们as的需要的工程配置文件在AOSP的根目录下会生成android.ipr和android.iml. 我们在之后as中通过File到open打开android.ipr就行. 注意哦, index导入的时间很长,你可以干点别的去. 源码调试没有搞. 可以参考以下链接 自己动手调试源码 参考流程 ","date":"2016-07-12","objectID":"/posts/mac%E7%B3%BB%E7%BB%9Fandroid%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81/:0:10","tags":["android"],"title":"mac系统android编译源码","uri":"/posts/mac%E7%B3%BB%E7%BB%9Fandroid%E7%BC%96%E8%AF%91%E6%BA%90%E7%A0%81/"},{"categories":["android"],"content":" ","date":"2016-07-05","objectID":"/posts/android-%E7%BB%98%E5%9B%BE%E7%AF%87-1-canvas%E5%92%8Cpaint%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/","tags":["android"],"title":"Android绘图篇-01 Canvas和Paint的基础使用","uri":"/posts/android-%E7%BB%98%E5%9B%BE%E7%AF%87-1-canvas%E5%92%8Cpaint%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"},{"categories":["android"],"content":"了解Cavans和Paint的具体用处,才可以更好的发挥他们的用户,方便我们应对不同的样式… 首先感谢启航blog,讲解的非常详细本文为整理笔记,让自己的认识加深. 首先贴上这篇我要记录的知识点的效果图 看到效果还是很基础的东西.下面开始整理实现方法 源码下载: 查找SuGraphicsBaseCanvasPaintActivity类, 手机查看效果一级界面进入选择graphics模块 ","date":"2016-07-05","objectID":"/posts/android-%E7%BB%98%E5%9B%BE%E7%AF%87-1-canvas%E5%92%8Cpaint%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/:0:0","tags":["android"],"title":"Android绘图篇-01 Canvas和Paint的基础使用","uri":"/posts/android-%E7%BB%98%E5%9B%BE%E7%AF%87-1-canvas%E5%92%8Cpaint%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"},{"categories":["android"],"content":"一.Paint和Canvas 自定义过View的对这两个属性应该不陌生. Paint画笔, Canvas画布. 有了这两个条件我们就可以做很多的事情. 如果你想直接画某一个图形那么就是用Canvas,如果你想设置一些属性如文字粗细,大小,颜色那么就使用Paint. 当我们要自定义View的使用,要养成在构造函数中创建出了Paint画笔对象,而不是在onDraw(),因为onDraw可能会在后续中频繁的刷新,如果在这其中设置了一些初始化的操作,那么就毫无意义并且浪费资源. 我们看一个Paint的基本属性设置: 注意本文或者后续文章中mDensity变量为当前屏幕密度比值,代码中使用是为了适配所有尺寸的手机都可以同比例的显示出来.如(720*1080(比值为2), 1080*1920(比值为3), 1440*2560(比值为4)) ``` //开始设置画笔的基本信息 mPaint.setAntiAlias(true); //设置画笔的抗锯齿 mPaint.setColor(Color.WHITE); //设置画笔的颜色 mPaint.setStyle(Paint.Style.FILL); //设置画出的图形填充的类型,fill为内部填充,stroke为只有边框,内容不填充 mPaint.setStrokeWidth(mDensity * 2); //设置边框的宽度. 如矩形的边宽, 文字的宽度. 接收实参为像素单位 mPaint.setTextSize(mDensity * 20); //设置当绘制文字的时候的字体大小 ``` Paint设置填充样式 setStyle (Paint.Style style) Paint.Style.FILL 填充内部 Paint.Style.FILL_AND_STROKE 填充并描边 Paint.Style.STROKE 仅描边不填充 看一下效果: 因为fill和fill_and_stroke相似不贴出效果 文字添加阴影 setShadowLayer (float radius, float dx, float dy, int color) 参数说明: radius: 值越大越模糊. 本质每一个像素点模糊的半径. dx: 生层的阴影水平方向移动偏移量 dy: 生层的阴影垂直方向移动偏移量 color: 生成阴影的颜色 代码实例 mPaint.setShadowLayer(mDensity*5, mDensity*15, mDensity*10, Color.RED ); canvas.drawText(\"阴影文字演示\", 0, 25*mDensity, mPaint); 给Canvas设置背景色 如果要给当前画布设置背景颜色,其实就是给画布添加一个颜色图层,最后合并的效果.有两个方法: canvas.drawColor(Color.BLUE); canvas.drawRGB(255, 255, 0); //这两个功能一样，都是用来设置背景颜色的。 画直线 drawLine (float startX, float startY, float stopX, float stopY, Paint paint) 参数说明: startX:开始点X坐标 startY:开始点Y坐标 stopX:结束点X坐标 stopY:结束点Y坐标 代码示例: ``` //方法1 单条直线 canvas.drawLine(mDensity*5, 0, mDensity*60, mDensity*20, mPaint); //方法2 多条直线 //定义一个数量为4的倍数的float类型的数组 float[] pts = {mDensity * 95,mDensity*10, mDensity*140,mDensity*10, mDensity*145,mDensity*10, mDensity*190,mDensity*10}; canvas.drawLines(pts,mPaint); ``` 效果演示: 方法2: 是根据一个点集合数组来画出线,可以是多条线. 最好定义为4的倍数的为数组的大小. 因为数组的每两个值分别对应点的xy点. 而两个点才能确定一个直线. 所以一条直线的前提是4个值. 画点 单个点 drawPoint (float x, float y, Paint paint) 多个点 drawPoints (float[] pts, Paint paint) drawPoints (float[] pts, int offset, int count, Paint paint) 代码示例: ``` canvas.drawPoint(100, 100, paint); float []pts={10,10,100,100,200,200,400,400}; canvas.drawPoints(pts, 2, 4, paint); ``` 画矩形 这里要用到Rect或者RectF. 这两个都是矩形的辅助类,基本一样. 根据四个点左上, 右下来确定一个矩形. 最常用的创建方式例如Rect rect = new Rect(10, 10, 50, 30); drawRect (float left, float top, float right, float bottom, Paint paint) drawRect (RectF rect, Paint paint) drawRect (Rect rect, Paint paint) 参数没有什么好说的了,要不在画矩形的时候明确出左上,右下. 要不就传入一个矩形辅助类对象. 代码示例: ``` //画矩形 实心 canvas.drawRect(0,0,mDensity*80, mDensity*20,mPaint); //参数12为矩形左上角的点, 参数34为矩形右下角的点 //矩形 空心 mPaint.setStyle(Paint.Style.STROKE); canvas.drawRect(new RectF(mDensity*100,0, mDensity*180,mDensity*20),mPaint); ``` 代码效果: 圆角矩形 drawRoundRect (RectF rect, float rx, float ry, Paint paint) rx: 生成圆角椭圆的X轴的半径 ry: 生成圆角椭圆的Y轴的半径 和矩形相比只需要多指定四个角需要显示的圆角属性即可. 代码示例: ``` //圆角矩形 实心 canvas.drawRoundRect(new RectF(0,0,mDensity*80, mDensity*20), mDensity*5, mDensity*5 ,mPaint); //参数2,3 为圆角的xy的弧度半径 //圆角矩形 空心 mPaint.setStyle(Paint.Style.STROKE); canvas.drawRoundRect(new RectF(mDensity*100,0,mDensity*180, mDensity*20), mDensity*5, mDensity*5 ,mPaint); ``` 代码效果: 圆形 drawCircle (float cx, float cy, float radius, Paint paint) 参数说明: cx: 圆心x点坐标 cy: 圆心y点坐标 radius: 圆的半径 椭圆 drawOval (RectF oval, Paint paint) 椭圆是根据矩形生成的，以矩形的长为椭圆的X轴，矩形的宽为椭圆的Y轴，建立的椭圆图形 所以只需要传入个RectF即可, 这里不演示了. 弧 弧是椭圆的一部分，而椭圆是根据矩形来生成的，所以弧当然也是根据矩形来生成的. drawArc (RectF oval, float startAngle, float sweepAngle, boolean useCenter, Paint paint) 参数说明: startAngle: 起始点,默认为坐标系x轴的正方向为0, 正值为顺时针旋转,负值反之 sweepAngle: 从起始点开始需要显示的多少角度到结束点. 此角度正值为顺时针旋转. useCenter: 是一个boolean,如果为true那么开始到圆心,和结束点到圆心都有连线.反之没有. 在画弧中利用方法中的boolean,配合画笔的填充属性可以生成不同的图形. 例如: 代码示例: ``` //弧 有两边 fill实心 扇形实心 RectF rectF_ArcStart1 = new RectF(-mDensity * 20, 0, mDensity * 60, mDensity * 40); canvas.drawArc(rectF_ArcStart1,0,120,true, mPaint); //arg2:为开始角度,从x坐标系的正方向为0度起始点. arg3是选装多少角度,为顺时针旋转 //弧 无两边 实心 圆的一部分 RectF rectF_ArcStart2 = new RectF(mDensity*50,0,mDensity*130, mDensity*40); canvas.drawArc(rectF_ArcStart2,0,120,false, mPaint); //弧 无两边 空心 弧边 mPaint.setStyle(Paint.Style.STROKE); RectF rectF_ArcEnd1 = new RectF(mDen","date":"2016-07-05","objectID":"/posts/android-%E7%BB%98%E5%9B%BE%E7%AF%87-1-canvas%E5%92%8Cpaint%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/:1:0","tags":["android"],"title":"Android绘图篇-01 Canvas和Paint的基础使用","uri":"/posts/android-%E7%BB%98%E5%9B%BE%E7%AF%87-1-canvas%E5%92%8Cpaint%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"},{"categories":["android"],"content":"二.Path和DrawTetx练习 canvas对象不光可以直接画出指定的矩形,还可以通过自定义的Path路径绘制出图形. 比如手势绘画,不规则轨迹等等. canvas.drawPath(Path path, Paint paint) Path直线 绘制直线路径,只需要找到一个起始点,然后不停的话直线的就可以, 每次画直线的起始点都是上一次的结束点. 常用的函数: moveTo(float x, float y): 直接把下一次的起始点移动到某一个位置 lineTo(float x, float y): 从上一次的起始点到指定的点画出连接点, 可以一直调用 close: 如果最后Path的路径的最终点没有和起始点重合,那么调用close()就可以连接起点和终点,形成闭合 代码示例: ``` Path path = new Path(); path.moveTo(10*mDensity, 10*mDensity); //设定起始点 path.lineTo(10*mDensity, 100*mDensity); //第一条直线的终点，也是第二条直线的起点 path.lineTo(200*mDensity,100*mDensity); //画第二条直线 path.close();//闭环 canvas.drawPath(path, mPaint); ``` 代码图示: 可以看到我们可以规划任意一条路径,然后调用drawPath一次性画出. 上面我们只调用了两次lineTo()方法,意思为两条线,但是效果有三条线,这就是close()闭合的意思,收尾相连. Path矩形 当利用Path路径要画出一个图形的时候, 这里会有多出一个顺序的概念,如顺时针开始,或者逆时针开始. addRect (float left, float top, float right, float bottom, Path.Direction dir) addRect (RectF rect, Path.Direction dir) 这里给Path添加路径和直接利用canvas.drawRect()差不多,不过这里有一个Path.Direction参数,表示构建的矩形以什么顺序画出 Path.Direction.CCW：是counter-clockwise缩写，指创建逆时针方向的矩形路径 Path.Direction.CW：是clockwise的缩写，指创建顺时针方向的矩形路径 这样直接画出可能不好理解, 我们可以结合文字根据路径画出来查看效果 先看一下结果: 这样就很明显的看出区别了,下面贴出实现代码 ``` //逆向生成矩形 Path CCWRectpath = new Path(); RectF rect1 = new RectF(30*mDensity, 10*mDensity, 110*mDensity, 60*mDensity); CCWRectpath.addRect(rect1, Path.Direction.CCW); //顺向生成生成 Path CWRectpath = new Path(); RectF rect2 = new RectF(130*mDensity, 10*mDensity, 210*mDensity, 60*mDensity); CWRectpath.addRect(rect2, Path.Direction.CW); //先画出这两个路径 canvas.drawPath(CCWRectpath, mPaint); canvas.drawPath(CWRectpath, mPaint); mPaint.setStyle(Paint.Style.FILL); mPaint.setTextSize(10*mDensity); //根据路径顺序画出文字, 参数2为路径, 参数3:每一边的头文字从原点的偏移量,相对于文字的左边开始为整数. 参数4: 每一行文字与所在路径的y轴偏移量,可以理解为值越大越远. canvas.drawTextOnPath(\"啥时候能涨工资呢,好无聊啊好无聊\",CCWRectpath,0,10*mDensity,mPaint); canvas.drawTextOnPath(\"啥时候能涨工资呢,好无聊啊好无聊\",CWRectpath,0,0*mDensity,mPaint); ``` 可以看到前半部分根据路径绘制了矩形,但是这样我们不能看出任何效果, 所以使用了canvas.drawTextOnPath()函数,与之前用的drawText()其实差不多,参数2就是根据传入的path对象的path路径来以此绘制文字, 参数3,4,其实是偏移量. 参数3代表与路径的起始点多少距离开始,我们可以想想每个段落是不是都有空格.就是这个意思. 参数4是与路径的距离(上下偏移),比如高考作文都是画好了横线让我们在上面写字.当传入0的时候就压着线写,传入10,就是往上移动10,距离线10的位置. ","date":"2016-07-05","objectID":"/posts/android-%E7%BB%98%E5%9B%BE%E7%AF%87-1-canvas%E5%92%8Cpaint%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/:2:0","tags":["android"],"title":"Android绘图篇-01 Canvas和Paint的基础使用","uri":"/posts/android-%E7%BB%98%E5%9B%BE%E7%AF%87-1-canvas%E5%92%8Cpaint%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"},{"categories":["android"],"content":"Path圆角矩形 还记得canvas也可以直接drawRoundRect(), 其实canvas那几个在path都有,并且还增加了贝塞尔曲线等. Path圆角矩形可以更灵活, 利用canvas画出的四个圆角是相等的,当时我们利用path添加圆角矩形却可以分别制定圆角的范围. addRoundRect(RectF rect, float rx, float ry, Direction dir) addRoundRect(RectF rect, float[] radii, Direction dir) 直接看图: 看到后面那个图片,每个角都不一样. 代码实现: ``` Path pathRoundRect = new Path(); RectF rectRoundCCW = new RectF(20*mDensity, 25*mDensity, 120*mDensity, 80*mDensity); pathRoundRect.addRoundRect(rectRoundCCW, 5*mDensity, 15*mDensity , Path.Direction.CCW); //arg2,3: 为生成椭圆的横轴和竖轴半径 RectF rectRoundCW = new RectF(140*mDensity,25*mDensity, 240*mDensity, 80*mDensity); float radii[] ={2*mDensity,3*mDensity, 10*mDensity,10*mDensity, 2*mDensity,3*mDensity, 25*mDensity,25*mDensity}; //必须为8个值, 对应四个角, 俩俩一堆为xy. pathRoundRect.addRoundRect(rectRoundCW, radii, Path.Direction.CCW); canvas.drawPath(pathRoundRect, mPaint); ``` 我们可以直接调用制定四个形参的函数直接规定四个圆角都相等的方法. 也可以调用三个参数的函数,这个函数中第二个接收一个数组, 这个数组必须为8个,少于8个就会出现角标越界异常. 因为这个函数是需要制定四个圆角. 每个角包含两个点, 所以最起码需要8个才可能满足此函数. 其他Path图形 其实和canvas对应的drawXXX差不多, 就不一一说明 圆形: addCircle (float x, float y, float radius, Path.Direction dir) 椭圆: addOval (RectF oval, Path.Direction dir) 弧形: addArc (RectF oval, float startAngle, float sweepAngle) 赛贝尔: quadTo (float x1, float y1, float x2, float y2) 后面会详细讲解 Paint关于文字属性的设置 我们经常用的画笔属性写字可以认为基础属性,然后还有一些加粗下划线倾斜认为样式属性 普通属性 setStrokeWidth(10) //画笔宽度 setAntiAlias(true) //是否开启抗锯齿 setTextSize(20) //设置文字大小 setStyle(Paint.Style.FILL) //设置填充样式 setTextAlign(Align.CENTER) //设置文字对齐方式 默认为Left对齐起始 样式属性 setFakeBoldText(true) //设置为粗体 setUnderlineText(true) //设置下划线 setTextSkewX(0.5f) //设置倾斜率 负值为向右,正值向左 setStrikeThruText(true) //设置删除线 setTextScaleX(2) //水平拉伸 直接贴上效果 文字对应canvas绘制方式 1.普通绘制 drawText (String text, float x, float y, Paint paint) drawText (CharSequence text, int start, int end, float x, float y, Paint paint) drawText (String text, int start, int end, float x, float y, Paint paint) drawText (char[] text, int index, int count, float x, float y, Paint paint) 我们常用的就是第一个, 3 4个为截取某一部分显示,不常用. 而第二个接收CharSequence,这个对象比较强大因为它不仅可以写字符还能添加bitmap.但是在canvas中貌似不支持charSequence. 所以此函数也就失去了意义. 2.指定位置绘制 drawPosText (char[] text, int index, int count, float[] pos, Paint paint) drawPosText (String text, float[] pos, Paint paint) 我们直接以第二个构造函数说明. 这个函数是根据你指定的数组float的点,来以此绘制出文字. 所以到这我们使用时候要注意要绘制的字符串长度要和设定的数组长度为1:2的比例.否则可能会出错. 代码示例: ``` float []pos=new float[]{20*mDensity,25*mDensity, 20*mDensity,50*mDensity, 20*mDensity,75*mDensity, 20*mDensity,100*mDensity}; //注意这里的数组,俩俩一对, 对数要等于drawPostText的字符串长度,否则会出现越界异常 canvas.drawPosText(\"八荣八耻\", pos, mPaint);//两个构造函数 ``` 图片示例: 3.根据路径绘制文字 在上面绘制的时候已经说过了,这里再用圆来演示一遍 关键代码: ``` canvas.drawTextOnPath(\"只要想努力,永远都不会晚.\", circlePath, 45*mDensity, 0, mPaint); //第二个路径，改变hoffset、voffset参数值 ,参数3偏移路径起始点的距离, 参数4效果向外扩张的效果 canvas.drawTextOnPath(\"只要想努力,永远都不会晚.\", circlePath2, 20*mDensity, 8*mDensity, mPaint); ``` 代码图示: 字体的TypeFace Typeface是专门用来设置字体样式的，通过paint.setTypeface()来指定。可以指定系统中的字体样式，也可以指定自定义的样式文件中获取。要构建Typeface时，可以指定所用样式的正常体、斜体、粗体等，如果指定样式中，没有相关文字的样式就会用系统默认的样式来显示，一般默认是宋体。 typeface的构建方法 create(String familyName, int style) //直接通过指定字体名来加载系统中自带的文字样式 create(Typeface family, int style) //通过其它Typeface变量来构建文字样式 createFromAsset(AssetManager mgr, String path) //通过从Asset中获取外部字体来显示字体样式 createFromFile(String path)//直接从路径创建 createFromFile(File path)//从外部路径来创建字体样式 defaultFromStyle(int style)//创建默认字体 我们如果想快速创建一个TypeFace对象那么就使用默认方法defaultFromStyle()其中的style有四个属性: Typeface.NORMAL //正常体 Typeface.BOLD //粗体 Typeface.ITALIC //斜体 Typeface.BOLD_ITALIC //粗斜体 设置字体传入familyName字符串无论是宋体,还是楷体.都无效果…. = =||| 自定义字体 把ttf的后缀的字体包放入到项目的.../app/src/main/assets/Fonts下, 如果没有Fonts文件夹手动创建. 然后代码如下: ``` //设置自定义的字体 Typeface myTypeFace = Typeface.createFromAsset(getContext().getAssets(), \"Fonts/jian_luobo.ttf\"); mPaint.setTypeface(myTypeFace); canvas.drawText(\"你妹我看你好不好使!!!\",10,50*mDensity, mPaint); ``` 代码图例: 源码下载: 查找SuGraphicsBaseCanvasPaintActivity类, 手机查看效果一级界面进入选择graphics模块 ","date":"2016-07-05","objectID":"/posts/android-%E7%BB%98%E5%9B%BE%E7%AF%87-1-canvas%E5%92%8Cpaint%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/:2:1","tags":["android"],"title":"Android绘图篇-01 Canvas和Paint的基础使用","uri":"/posts/android-%E7%BB%98%E5%9B%BE%E7%AF%87-1-canvas%E5%92%8Cpaint%E7%9A%84%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"},{"categories":["android"],"content":" ","date":"2016-05-25","objectID":"/posts/1/","tags":["android"],"title":"善用继承实现,避免不必要的错误","uri":"/posts/1/"},{"categories":["android"],"content":"用输出来显示出类究竟是如何被加载的,以及到底以什么样的顺序来进行的初始化,可以让我们跳过一些不必要的麻烦… ","date":"2016-05-25","objectID":"/posts/1/:0:0","tags":["android"],"title":"善用继承实现,避免不必要的错误","uri":"/posts/1/"},{"categories":["android"],"content":"错误场景: 在一个activity中, 利用的pager类+viewpager实现显示界面. 四个界面pager类继承了一个basepager的抽象类. 抽象类的构造函数中调用了一个抽象方法init(); 当子类实现是,实现basepager的抽象方法并在实现具体的初始化动作. 出现莫名问题 有一个pager加载了地图. 所以在最外面activity中要关联生命周期方法. 但是明明pager类中的地图对象已经创建, 但是在activity用pager.mapclient却发生了空指针!! 调试半天已经开始怀疑人生. 接下来直接用简单的java代码来复现遇见的问题. ","date":"2016-05-25","objectID":"/posts/1/:0:1","tags":["android"],"title":"善用继承实现,避免不必要的错误","uri":"/posts/1/"},{"categories":["android"],"content":"模拟错误代码 首先看这三个简单的类 很简单, 定义一个抽象类BaseClass,并在构造函数中调用抽象方法init(). 然后子类ImpClass继承BassClass实现抽象方法在方法里面对声明的一个成员变量进行赋值999. 然后A类main函数创建这个子类ImpClass并取出这个函数的值打印. ","date":"2016-05-25","objectID":"/posts/1/:0:2","tags":["android"],"title":"善用继承实现,避免不必要的错误","uri":"/posts/1/"},{"categories":["android"],"content":"想想testInt结果应该是多少? 我们可以顺一下对象的创建流程. new 了一个ImpClass, 首先会进行类的加载.在堆中开辟空间然后声明类中的testInt变量等. 调用构造函数进行初始化操作, 因为继承了BaseClass所以在调用ImpClass构造的时候会先调用super()调用父构造函数. 执行父类构造函数调用了抽象init(),因为具体的实现方法在子类所以找到BaseClass子类的init()执行.这里对testInt变量进行了999赋值. 回到BaseClass类中的继续执行自己的构造方法进行初始化. 这里没有任何操作. 此时最后一次赋值应该是999. 但是结果真的是这样吗 testInt结果竟然是声明变量时的初始值,而不是最后的赋值操作. 看到这里想一想可以看出. ImpClass子类中声明的变量是最后一步执行的. 所以造成了init()的赋值被最后的类对自己属性进行默认初始化的时候覆盖了之前的值. 我们证实一下自己的想法. 看看声明变量时候的赋值动作究竟是什么时候触发的. 我们手动的在声明一个成员变量就new一个对象赋给这个变量. 看看输出语句究竟一个什么样的顺序. 看一下输出结果 ok! 之前的猜想没有错,代码就是最好的说明 ","date":"2016-05-25","objectID":"/posts/1/:0:3","tags":["android"],"title":"善用继承实现,避免不必要的错误","uri":"/posts/1/"},{"categories":["android"],"content":"那为什么会这样.看一下这个图的说明:类加载的过程 我们把一个类被加载到内存的时候的需要走的执行代码全部补全看一下输出. 对比一下上图 子类ImpClass 辅助检测类 查看一下结果 总结: 如果使用了继承 接口一些并有在接口进行一些初始化动作的抽象方法, 就要注意声明变量时的是否赋默认初始值的行为.例如 ``` public int testInt = -1; //定义一个变量并附上默认初始值 public OutPut out= new OutPut(); ``` 掌握好其中的步骤,才能让自己不会处于被动. 即使遇见也可以迎刃而解. ","date":"2016-05-25","objectID":"/posts/1/:0:4","tags":["android"],"title":"善用继承实现,避免不必要的错误","uri":"/posts/1/"},{"categories":["android"],"content":" ","date":"2016-05-20","objectID":"/posts/android-studio-%E5%BF%AB%E6%8D%B7%E9%94%AE-mac/","tags":["android"],"title":"Android Studio 快捷键 mac版","uri":"/posts/android-studio-%E5%BF%AB%E6%8D%B7%E9%94%AE-mac/"},{"categories":["android"],"content":"工欲善其事必先利其器 Preferences -\u003e Keymap 然后就可以选择你想要的快捷键，这里不止可以选择Eclipse，还可以选择 Emacs、Net Beans 等编辑器的快捷键。 ","date":"2016-05-20","objectID":"/posts/android-studio-%E5%BF%AB%E6%8D%B7%E9%94%AE-mac/:0:0","tags":["android"],"title":"Android Studio 快捷键 mac版","uri":"/posts/android-studio-%E5%BF%AB%E6%8D%B7%E9%94%AE-mac/"},{"categories":["android"],"content":"设置代码提示 mac中常见按键 ⌘:command, ⌃:ctrl, ⇧:shift, ⌥:alt/option, ⏎:enter/return Android studio快捷键一览表 ","date":"2016-05-20","objectID":"/posts/android-studio-%E5%BF%AB%E6%8D%B7%E9%94%AE-mac/:1:0","tags":["android"],"title":"Android Studio 快捷键 mac版","uri":"/posts/android-studio-%E5%BF%AB%E6%8D%B7%E9%94%AE-mac/"},{"categories":["android"],"content":"操作 Mac OSX Keymap 功能 快捷键 getter、setter、constructor ⌘N 格式化代码 ⌘⌥L 折叠展开代码块 ⌘+,⌘- 折叠展开全部代码块折叠展开全部代码块 ⌘⇧+,⌘⇧- 提示错误解决方案 ⌥⏎ 提示参数类型 ⌘P 快捷向下复制行 ⌘D 快捷定位到行首/尾 ⌘← ，⌘→ 上下移动光标所在行 ⌥⇧↑ ↓ 注释代码(//) ⌘/ 注释代码(/**/) ⌘⌥/ 选中一段代码，按快捷键添加try或if ⌘⌥T 大小写转换 ⌘⇧U 去除无效引用 ^⌥O 打开类 ⌘O 打开文件 ⌘⇧O 快捷覆写方法 ⌃O 当前project中搜索属性(成员和静态，不论是否私有) ⌘⌥O 查找与替换 ⌘F，⌘R 定位到属性、方法、类等它们的声明 F4 点击类名定位到父类 ⌘U 点击变量定位到定义 ⌘B 点击方法名查找调用 ⌃⌥H 文件方法结构 ⌘F12 重构 ⌃T 将内部变量抽取成方法的参数 ⌘⌥P 抽取成方法 ⌘⌥M 抽取为成员属性 ⌘⌥F (PS: 以上快捷键只在mac平台尝试确认) ","date":"2016-05-20","objectID":"/posts/android-studio-%E5%BF%AB%E6%8D%B7%E9%94%AE-mac/:2:0","tags":["android"],"title":"Android Studio 快捷键 mac版","uri":"/posts/android-studio-%E5%BF%AB%E6%8D%B7%E9%94%AE-mac/"},{"categories":["android"],"content":"常用 去除无效引用： ^⌥O getter、setter、constructor： ⌘N 格式化代码：⌘⌥L 折叠展开代码块:⌘+,⌘- 折叠展开全部代码块折叠展开全部代码块: ⌘⇧+,⌘⇧- ","date":"2016-05-20","objectID":"/posts/android-studio-%E5%BF%AB%E6%8D%B7%E9%94%AE-mac/:3:0","tags":["android"],"title":"Android Studio 快捷键 mac版","uri":"/posts/android-studio-%E5%BF%AB%E6%8D%B7%E9%94%AE-mac/"},{"categories":["android"],"content":"提示类 提示错误解决方案(在抽取局部变量时，调出对话框后选第二个)： ⌥⏎ 提示参数类型： ⌘P ","date":"2016-05-20","objectID":"/posts/android-studio-%E5%BF%AB%E6%8D%B7%E9%94%AE-mac/:4:0","tags":["android"],"title":"Android Studio 快捷键 mac版","uri":"/posts/android-studio-%E5%BF%AB%E6%8D%B7%E9%94%AE-mac/"},{"categories":["android"],"content":"代码操作类 快捷向下复制行： ⌘D 快捷定位到行首/尾： ⌘← ，⌘→ 上下移动光标所在行：⌥⇧↑|↓ 注释代码(//)： ⌘/ 注释代码(/**/)： ⌘⌥/ 选中一段代码，按快捷键添加try或if: ⌘⌥T 大小写转换 ⌘⇧U ","date":"2016-05-20","objectID":"/posts/android-studio-%E5%BF%AB%E6%8D%B7%E9%94%AE-mac/:5:0","tags":["android"],"title":"Android Studio 快捷键 mac版","uri":"/posts/android-studio-%E5%BF%AB%E6%8D%B7%E9%94%AE-mac/"},{"categories":["android"],"content":"查找 打开类： ⌘O 打开文件： ⌘⇧O 当前project中搜索属性(成员和静态，不论是否私有)： ⌘⌥o 查找与替换：⌘F，⌘R ","date":"2016-05-20","objectID":"/posts/android-studio-%E5%BF%AB%E6%8D%B7%E9%94%AE-mac/:6:0","tags":["android"],"title":"Android Studio 快捷键 mac版","uri":"/posts/android-studio-%E5%BF%AB%E6%8D%B7%E9%94%AE-mac/"},{"categories":["android"],"content":"方法属性定位 定位到属性、方法、类等它们的声明：F4 点击类名定位到父类： ⌘U 点击变量定位到定义： ⌘B 点击方法名查找调用： ⌃⌥H 快捷覆写方法： ⌃O 文件方法结构： ⌘F12 ","date":"2016-05-20","objectID":"/posts/android-studio-%E5%BF%AB%E6%8D%B7%E9%94%AE-mac/:7:0","tags":["android"],"title":"Android Studio 快捷键 mac版","uri":"/posts/android-studio-%E5%BF%AB%E6%8D%B7%E9%94%AE-mac/"},{"categories":["android"],"content":"方法抽取 重构：⌃T 将内部变量抽取成方法的参数：⌘⌥P 抽取成方法：⌘⌥M s抽取为成员属性：⌘⌥F ","date":"2016-05-20","objectID":"/posts/android-studio-%E5%BF%AB%E6%8D%B7%E9%94%AE-mac/:8:0","tags":["android"],"title":"Android Studio 快捷键 mac版","uri":"/posts/android-studio-%E5%BF%AB%E6%8D%B7%E9%94%AE-mac/"},{"categories":["android"],"content":" ","date":"2016-05-20","objectID":"/posts/android-%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8annotion%E6%9B%BF%E4%BB%A3enum/","tags":["android"],"title":"Android 中如何使用annotion替代Enum","uri":"/posts/android-%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8annotion%E6%9B%BF%E4%BB%A3enum/"},{"categories":["android"],"content":"抛弃枚举, 在android中一个更好的方法替代他. ","date":"2016-05-20","objectID":"/posts/android-%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8annotion%E6%9B%BF%E4%BB%A3enum/:0:0","tags":["android"],"title":"Android 中如何使用annotion替代Enum","uri":"/posts/android-%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8annotion%E6%9B%BF%E4%BB%A3enum/"},{"categories":["android"],"content":"起因 阅读原文 当我们想从一些预定义的常量中使用一个变量我们能怎么做. 我可以声明常量并给他们赋值. 我们假设某一个值是表示今天,他可以从周日到周六有不一样的值来指定,我们在java中可以这样使用整数型常量. ``` public class Main { public static final int SUNDAY = 0; public static final int MONDAY = 1; public static final int TUESDAY = 2; public static final int WEDNESDAY = 3; public static final int THURSDAY = 4; public static final int FRIDAY = 5; public static final int SATURDAY = 6; private int currentDay = SUNDAY; public static void main(String[] args) { // TODO Auto-generated method stub Main obj = new Main(); obj.setCurrentDay(WEDNESDAY); int today = obj.getCurrentDay(); switch (today) { case SUNDAY: System.out.println(\"Today is SUNDAY\"); break; case MONDAY: System.out.println(\"Today is MONDAY\"); break; case TUESDAY: System.out.println(\"Today is TUESDAY\"); break; case WEDNESDAY: System.out.println(\"Today is WEDNESDAY\"); break; case THURSDAY: System.out.println(\"Today is THURSDAY\"); break; case FRIDAY: System.out.println(\"Today is FRIDAY\"); break; case SATURDAY: System.out.println(\"Today is SATURDAY\"); break; default: break; } } public void setCurrentDay(int currentDay) { this.currentDay = currentDay; } public int getCurrentDay() { return currentDay; } } ``` ","date":"2016-05-20","objectID":"/posts/android-%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8annotion%E6%9B%BF%E4%BB%A3enum/:1:0","tags":["android"],"title":"Android 中如何使用annotion替代Enum","uri":"/posts/android-%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8annotion%E6%9B%BF%E4%BB%A3enum/"},{"categories":["android"],"content":"问题 这段代码看似已经实现功能, 但是有问题存在的因为我可以设置任何的整数型的值给当前的currentDay. obj.setCurrentDay(100); ","date":"2016-05-20","objectID":"/posts/android-%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8annotion%E6%9B%BF%E4%BB%A3enum/:2:0","tags":["android"],"title":"Android 中如何使用annotion替代Enum","uri":"/posts/android-%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8annotion%E6%9B%BF%E4%BB%A3enum/"},{"categories":["android"],"content":"方案1 使用Enum 这样即使我们设置了超出了currentDay没有实际意义值得时候, 编译器却没有给我们任何的提示. 然后在 switch语句中将错过这些值. 所以java给了我们一个解决方案就是使用枚举(Enum)和Enumerarion. 我们可以使用Enum重写之前的代码. ``` public class Main { public enum WeekDays { SUNDAY, MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY } private WeekDays currentDay = WeekDays.SUNDAY; public static void main(String[] args) { // TODO Auto-generated method stub Main obj = new Main(); obj.setCurrentDay(WeekDays.WEDNESDAY); WeekDays today = obj.getCurrentDay(); switch (today) { case SUNDAY: System.out.println(\"Today is SUNDAY\"); break; case MONDAY: System.out.println(\"Today is MONDAY\"); break; case TUESDAY: System.out.println(\"Today is TUESDAY\"); break; case WEDNESDAY: System.out.println(\"Today is WEDNESDAY\"); break; case THURSDAY: System.out.println(\"Today is THURSDAY\"); break; case FRIDAY: System.out.println(\"Today is FRIDAY\"); break; case SATURDAY: System.out.println(\"Today is SATURDAY\"); break; default: break; } } public void setCurrentDay(WeekDays currentDay) { this.currentDay = currentDay; } public WeekDays getCurrentDay() { return currentDay; } } ``` 这样我们的currentDay,set只接收Enum类型, 而Enum里面有什么使我们预先定义好的.这样就解决了之前出现的问题.这是一个好的解决方案.所以我们应该在以后根据场景使用它, 但是在Android中还是会有些问题的 ","date":"2016-05-20","objectID":"/posts/android-%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8annotion%E6%9B%BF%E4%BB%A3enum/:3:0","tags":["android"],"title":"Android 中如何使用annotion替代Enum","uri":"/posts/android-%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8annotion%E6%9B%BF%E4%BB%A3enum/"},{"categories":["android"],"content":"方案2 使用android特有的魔术变量注解替代Enum Enum in Android 枚举Enum在java中是一个完整的类. 而枚举中的每一个值在枚举类中都是一个对象. 所以在我们使用时枚举的值将比整数常量消耗更多的内存. 当我们使用枚举在安卓应用中, 如果我们的程序本身内存消耗就比较大,或者是一个游戏的应用程序. 那么我们最好使用常量来替代枚举. 但之前的问题仍然存在. 那么有什么好的办法么? 当然, Android 支持注解库中有一些好用的annotation helper 我们可以使用它们来解决我们之前的问题(在编译代码时期). IntDef和StringDef 是两个魔术变量注解. 使用这个两个来替代之前使用的Enum. 它将帮助我们在编译代码时期像Enum那样选择变量的功能. 接下来我们来使用IntDef来替换Enum看一下. ``` public class MainActivity extends Activity { public static final int SUNDAY = 0; public static final int MONDAY = 1; public static final int TUESDAY = 2; public static final int WEDNESDAY = 3; public static final int THURSDAY = 4; public static final int FRIDAY = 5; public static final int SATURDAY = 6; @IntDef({SUNDAY, MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY}) @Retention(RetentionPolicy.SOURCE) public @interface WeekDays {} @WeekDays int currentDay = SUNDAY; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); setCurrentDay(WEDNESDAY); @WeekDays int today = getCurrentDay(); switch (today){ case SUNDAY: break; case MONDAY: break; case TUESDAY: break; case WEDNESDAY: break; case THURSDAY: break; case FRIDAY: break; case SATURDAY: break; default: break; } } public void setCurrentDay(@WeekDays int currentDay) { this.currentDay = currentDay; } @WeekDays public int getCurrentDay() { return currentDay; } } ``` 现在我们不能直接用一个int值赋值给currentDay变量, 或者在set赋值的时候只能传入currentDay变量被注解所规定的魔术注解IntDef中的常量引用(而不是引用对应的引用值). 当我们使用赋一些没有意义的值时, 编译器将给我们一些警告让我们修改. 如果我们使用过的是Android Studio开发的话, IDE将给我们关于如果使用的建议. ","date":"2016-05-20","objectID":"/posts/android-%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8annotion%E6%9B%BF%E4%BB%A3enum/:4:0","tags":["android"],"title":"Android 中如何使用annotion替代Enum","uri":"/posts/android-%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8annotion%E6%9B%BF%E4%BB%A3enum/"},{"categories":["android"],"content":"创建步骤 我们可以拆解一下步骤. 首先如果想要这个特证,你应该添加 support-annotations library 到你的项目中去, 如果你使用AS,可以使用gradle的依赖. ``` dependencies { compile fileTree(include: ['*.jar'], dir: 'libs') ... compile 'com.android.support:support-annotations:22.0.0' } ``` 如果你的项目已经依赖这个:com.android.support:appcompat-v7, 那或许不需要单独添加上述库的依赖 1.首先声明常量 ``` public static final int SUNDAY = 0; public static final int MONDAY = 1; public static final int TUESDAY = 2; public static final int WEDNESDAY = 3; public static final int THURSDAY = 4; public static final int FRIDAY = 5; public static final int SATURDAY = 6; ``` 2.创建一个注解,声明魔术变量@IntDef(或者@StringDef其实后面传入的为String类型常量)并给其添加想预定义的int常量 ``` @IntDef({SUNDAY, MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FRIDAY,SATURDAY}) @Retention(RetentionPolicy.SOURCE) public @interface WeekDays {} ``` 3.给变量currentDay使用注解 ``` @WeekDays int currentDay ; //这时currentDay 不会接收weekDays以外的所有值, 即使是IntDef中常量名对应的值也不可以, 只能使用weekDays常量引用 ``` 4.如果我们要声明currentDay的setter和getter,可以这样使用来限制问题 ``` public void setCurrentDay(@WeekDays int currentDay) { this.currentDay = currentDay; } @WeekDays public int getCurrentDay() { return currentDay; } ``` 如果你想了解更多关于注解支持库的介绍,come here (自备梯子). ","date":"2016-05-20","objectID":"/posts/android-%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8annotion%E6%9B%BF%E4%BB%A3enum/:5:0","tags":["android"],"title":"Android 中如何使用annotion替代Enum","uri":"/posts/android-%E4%B8%AD%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8annotion%E6%9B%BF%E4%BB%A3enum/"},{"categories":["android"],"content":" ","date":"2016-05-19","objectID":"/posts/5.0%E7%89%B9%E6%80%A7verctor2svg/","tags":["android"],"title":"5.0特性Verctor2SVG","uri":"/posts/5.0%E7%89%B9%E6%80%A7verctor2svg/"},{"categories":["android"],"content":"你不知道svg? 那你知道矢量图? 也不知道!? 位图呢? … 快来看一看吧 ","date":"2016-05-19","objectID":"/posts/5.0%E7%89%B9%E6%80%A7verctor2svg/:0:0","tags":["android"],"title":"5.0特性Verctor2SVG","uri":"/posts/5.0%E7%89%B9%E6%80%A7verctor2svg/"},{"categories":["android"],"content":"svg使用背景 不会再因为分辨率的原因导致图片放大失真. 同一个图片的不同状态不需要多张图片. 可以实现多平台复制,不需要每个平台都有多套的切图. 使用svg或者IconFont实现占用的空间更小,因为其本身就是字符串. ","date":"2016-05-19","objectID":"/posts/5.0%E7%89%B9%E6%80%A7verctor2svg/:0:1","tags":["android"],"title":"5.0特性Verctor2SVG","uri":"/posts/5.0%E7%89%B9%E6%80%A7verctor2svg/"},{"categories":["android"],"content":"了解一下PNG IconFont SVG的区别 PNG为位图,是由不同的排列和染色的像素点组成的图像,放大位图的时候能看见无数个小方块,所以位图的扩大实质是增加单个像素点的大小,故而导致在不同分辨率会必然需要多套匹配的图片. SVG为可缩放矢量图,它不会像位图一样因为缩放而让图片质量下降,他在不同分辨率呈现的都是一个效果. IconFont是WebFont形式的图标,你可以把他认为就是WebFont,该类的制作来自SVG矢量图,所以效果和上面一样. 图标类型 构成 优势 劣势 PNG 独立像素点 可以实现各种色彩及真实画面的复现 体积比较大,缩放和旋转容易失真 SVG 向量 体积较小,缩放和旋转不失真 制作色彩变化太多图像难度不较大 IconFont WebFont 体积较小,缩放和旋转不失真 基本不支持多彩色图像,一般都是单色 ","date":"2016-05-19","objectID":"/posts/5.0%E7%89%B9%E6%80%A7verctor2svg/:0:2","tags":["android"],"title":"5.0特性Verctor2SVG","uri":"/posts/5.0%E7%89%B9%E6%80%A7verctor2svg/"},{"categories":["android"],"content":"SVG的创建使用 在项目中找到drawable –\u003e New –\u003e Vector Assert. 选择choose按钮可以挑选google内置的一些svg图片,确定即可. ","date":"2016-05-19","objectID":"/posts/5.0%E7%89%B9%E6%80%A7verctor2svg/:0:3","tags":["android"],"title":"5.0特性Verctor2SVG","uri":"/posts/5.0%E7%89%B9%E6%80%A7verctor2svg/"},{"categories":["android"],"content":"实现SVG的动画转换 使用SVG实现动画转变,会实现一些看着很炫酷的东西. 一般实现一个svg动画需要三个文件 \u003cvector\u003e SVG的静态资源文件 \u003canimated-vector\u003e 指定静态SVG里面某个对应的name标签要实现的某个动画属性属性 \u003cset\u003e -\u003e \u003cobjectAnimator\u003e 具体要执行的动画效果. 1 svg的静态文件代码 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cvector xmlns:android=\"http://schemas.android.com/apk/res/android\" android:viewportWidth=\"500\" android:viewportHeight=\"500\" android:width=\"100dp\" android:height=\"100dp\"\u003e \u003cpath android:name=\"play\" android:fillColor=\"#fff\" android:pathData=\"M100,100 L400,250 L100,400 L100,400 z\" /\u003e \u003c!-- path: 添加一个唯一属性名称,如果要实现SVG的动画效果这是必须的, 会在animated-vector里面进行静态文件和动画的关联 --\u003e \u003c/vector\u003e 2 关联文件 animated-vector \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003canimated-vector xmlns:android=\"http://schemas.android.com/apk/res/android\" android:drawable=\"@drawable/play_icon\"\u003e \u003ctarget android:animation=\"@animator/to_stop\" android:name=\"play\" /\u003e \u003c!-- target标签 可以为多个,为每一个声明name属性的设置不同的效果. 在\u003canimated-vector\u003e中 drawable 是关联vector的静态文件路径 \u003ctarget\u003e name: 为关联的vector里面的某个path 或者group animation: 要执行的动画,对应一个xml资源文件根标签可以使set 也可以是objectAnimator --\u003e \u003c/animated-vector\u003e 3 动画文件 \u003c?xml version=\"1.0\" encoding=\"utf-8\"?\u003e \u003cobjectAnimator xmlns:android=\"http://schemas.android.com/apk/res/android\" android:duration=\"2000\" android:interpolator=\"@android:interpolator/decelerate_cubic\" android:propertyName=\"pathData\" android:valueType=\"pathType\" android:valueFrom=\"M100,100 L400,250 L100,400 L100,400 L100,400 z M100,400 L100,400 L100,400 L100,400 z M100,400 L100,400 L100,400 L100,400 z\" android:valueTo=\"M100,100 L400,100 L400,120 L100,120 L100,100 z M100,200 L400,200 L400,220 L100,220 z M100,300 L400,300 L400,320 L100,320 z\" /\u003e 注意valueFrom和valueTo 点数必须一致,不然会报错. ok资源文件都创建ok.那么我们在layout布局中添加一个imageView标签设置一下src前景图片,直接引入上面第二部的资源文件,animated-vector. 然后在activity找到imageview控件,继续如下. Drawable drawable = imageview.getDrawable(); if ( drawable instanceof Animatable){ ((Animatable) drawable).start(); } 开始之后如下效果 ","date":"2016-05-19","objectID":"/posts/5.0%E7%89%B9%E6%80%A7verctor2svg/:0:4","tags":["android"],"title":"5.0特性Verctor2SVG","uri":"/posts/5.0%E7%89%B9%E6%80%A7verctor2svg/"},{"categories":["android"],"content":"SVG Path Data 主要有以下一些命令 M： move to 移动绘制点 L：line to 直线 Z：close 闭合 C：cubic bezier 三次贝塞尔曲线 Q：quatratic bezier 二次贝塞尔曲线 A：ellipse 圆弧 每个命令都有大小写形式，大写代表后面的参数是绝对坐标，小写表示相对坐标。参数之间用空格或逗号隔开 命令详解： M (x y) 移动到x,y L (x y) 直线连到x,y，还有简化命令H(x) 水平连接、V(y)垂直连接 Z，没有参数，连接起点和终点 C(x1 y1 x2 y2 x y)，控制点x1,y1 x2,y2，终点x,y Q(x1 y1 x y)，控制点x1,y1，终点x,y A(rx ry x-axis-rotation large-arc-flag sweep-flag x y) rx ry 椭圆半径 x-axis-rotation x轴旋转角度 large-arc-flag 为0时表示取小弧度，1时取大弧度 sweep-flag 0取逆时针方向，1取顺时针方向 有个图解： ","date":"2016-05-19","objectID":"/posts/5.0%E7%89%B9%E6%80%A7verctor2svg/:0:5","tags":["android"],"title":"5.0特性Verctor2SVG","uri":"/posts/5.0%E7%89%B9%E6%80%A7verctor2svg/"},{"categories":["android"],"content":" ","date":"2016-05-19","objectID":"/posts/%E8%A7%86%E9%A2%91%E8%BD%AC%E6%8D%A2%E4%B8%BAgif/","tags":["android"],"title":"安卓录制视频并转换为gif","uri":"/posts/%E8%A7%86%E9%A2%91%E8%BD%AC%E6%8D%A2%E4%B8%BAgif/"},{"categories":["android"],"content":"本方法适用于mac, 利用ffmpeg实现转换 ","date":"2016-05-19","objectID":"/posts/%E8%A7%86%E9%A2%91%E8%BD%AC%E6%8D%A2%E4%B8%BAgif/:0:0","tags":["android"],"title":"安卓录制视频并转换为gif","uri":"/posts/%E8%A7%86%E9%A2%91%E8%BD%AC%E6%8D%A2%E4%B8%BAgif/"},{"categories":["android"],"content":"视频转换为gif格式 ffmpeg如果没有安装: 在终端输入 brew install ffmpeg cd到要转换的文件路径: ffmpeg -ss 2 -t 3 -i demo.mp4 -s 240x400 -f gif -r 10 4.gif -ss 2 : 从视频的第二秒开始 -t 3 : 截取3秒的视频内容 -i 后面跟的的是源文件路径 -s 240x400 指定输入源的大小分辨率 -f gif 为格式声明 -r 1 调整每秒的帧率, 就是一秒为一帧的图片 最后为输出的文件名 以上方式虽然人为的缩短了每秒的帧数,但是一个gif的时间却没有虽短,如果想达到一个缩短帧数的同时,减少整个gif的执行时间,可以利用把视频每秒抽取一帧的图片,保存为一系列的JPEG文件,然后在合并成gif. ffmpeg -ss 2 -t 10 -i xxx.mp4 -r 1 -s 240x400 -f image2 foo-%03d.jpeg ffmpeg -f image2 -framerate 5 -i foo-%03d.jpeg xxx.gif ","date":"2016-05-19","objectID":"/posts/%E8%A7%86%E9%A2%91%E8%BD%AC%E6%8D%A2%E4%B8%BAgif/:0:1","tags":["android"],"title":"安卓录制视频并转换为gif","uri":"/posts/%E8%A7%86%E9%A2%91%E8%BD%AC%E6%8D%A2%E4%B8%BAgif/"},{"categories":["mySql"],"content":" ","date":"2016-05-18","objectID":"/posts/mysql-%E5%9B%9B-%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80%E6%8E%A7%E5%88%B6%E5%99%A8%E7%AD%89/","tags":["mySql"],"title":"MySql(四)--数据控制语言控制器等","uri":"/posts/mysql-%E5%9B%9B-%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80%E6%8E%A7%E5%88%B6%E5%99%A8%E7%AD%89/"},{"categories":["mySql"],"content":"自学小笔记 ","date":"2016-05-18","objectID":"/posts/mysql-%E5%9B%9B-%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80%E6%8E%A7%E5%88%B6%E5%99%A8%E7%AD%89/:0:0","tags":["mySql"],"title":"MySql(四)--数据控制语言控制器等","uri":"/posts/mysql-%E5%9B%9B-%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80%E6%8E%A7%E5%88%B6%E5%99%A8%E7%AD%89/"},{"categories":["mySql"],"content":"数据控制语言 DCL (Data Control Language) 数据控制语言,是用于对mysql的用户及其权限进行管理的语句. 用户管理 mysql中的所有用户,都存在系统数据库(mysql)中的 user 表中–不敢那个数据库的用户,都存储在这里.(服务器: localhost--\u003e数据库: mysql--\u003e 表 user) 创建用户 形式: create user '用户名'@'允许登录的地址/服务器' identified by '密码' 如果想创建一个指定的 ip 用户想访问我们本地的数据库这样 create user 'extra'@'192.168.x.x' identified by '123'; //这样就创建了一个 extra 的用户 对方访问可以这样\u003cbr/\u003e mysql -h我的主机名 -uextra -p; 删除用户 drop user '用户名'@'允许登录的地址或服务器' 修改用户密码 set password = password('密码'); setpassword for '用户名'@'允许登录的地址' = password('密码'); ","date":"2016-05-18","objectID":"/posts/mysql-%E5%9B%9B-%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80%E6%8E%A7%E5%88%B6%E5%99%A8%E7%AD%89/:0:1","tags":["mySql"],"title":"MySql(四)--数据控制语言控制器等","uri":"/posts/mysql-%E5%9B%9B-%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80%E6%8E%A7%E5%88%B6%E5%99%A8%E7%AD%89/"},{"categories":["mySql"],"content":"权限管理 mysql 数据库,将其中所能做的所有事情否分门别类分配到大约30多个权限中去了,其中每个权限,都是一个单词而已. select: 代表可以查询数据; update: 代表可以修改数据; delete: 代表可以删除数据; …… 其中有一个特别的权限 : all 设置出 GRANT OPTION 之外的所有简单权限. 授予权限 形式: grant 权限列表 on 某库.某对象 to '用户名'@'允许登录的位置' [identified by '密码']; 说明: 权限列表,就是多个权限的名字,相互之间用逗号分开,比如: select,insert,update, 也可以写 all 某库.某对象,表示给指定的某个数据库中的某个下级单位附权,下级单位有: 表名,视图名,存储过程名,存储函数名.其中可以使用统配语法–\u003e \\*.\\*: 代表所有的数据库的所有下级单位. 某库.*: 代表指定的该库中的所有下级单位 剥夺权限 形式: revoke 权限列表 on 某库.某个对象 from '用户名'@'允许登录的位置' 其含义,跟 grant 完全一样; ","date":"2016-05-18","objectID":"/posts/mysql-%E5%9B%9B-%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80%E6%8E%A7%E5%88%B6%E5%99%A8%E7%AD%89/:0:2","tags":["mySql"],"title":"MySql(四)--数据控制语言控制器等","uri":"/posts/mysql-%E5%9B%9B-%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80%E6%8E%A7%E5%88%B6%E5%99%A8%E7%AD%89/"},{"categories":["mySql"],"content":"数据事务语言 DDL (Data Transaction Language) 就是用来保证多条增删改语句的执行的一致性,要么都执行,要么都没有执行. 事务的特点 原子性: 一个事务总的所有语句,应该做到要么全做,要么一个都不做. 一致性: 让数据保持逻辑上的合理性,例如一个商品出库时,既要让商品库数量减1,又让让对应用户购物车商品加1. 隔离性: 如果多个事务同时并发执行,但每个事务就像各自独立执行一样. 持久性: 一个事务执行成功,则对数据来说应该死一个明确的硬盘数据更改,而不仅仅是内存中的变化. 事务模式 在我们 cmd 命令模式中,是否开启了 一条语句就是一个事务 的这个开关. 默认情况下(安装后) ,这个模式是开启的,称为自动提交模式;我们可以手动把他关闭,那就是’非自动提交模式' set autocommit = 0/false //关闭该模式 事务执行的基本流程 开启一个事务: start transaction; //也可以写成: begin 执行多条增删改语句; //也就是相当于希望这多条语句作为一个不可分割的整体去执行. 判断这些语句执行的结果: if(没有出错){ commit; //提交事务;此时就是一次性完成; } else{ roolback; //回滚事务;此时什么都没有做; } ","date":"2016-05-18","objectID":"/posts/mysql-%E5%9B%9B-%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80%E6%8E%A7%E5%88%B6%E5%99%A8%E7%AD%89/:0:3","tags":["mySql"],"title":"MySql(四)--数据控制语言控制器等","uri":"/posts/mysql-%E5%9B%9B-%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80%E6%8E%A7%E5%88%B6%E5%99%A8%E7%AD%89/"},{"categories":["mySql"],"content":"mysql 编程 mysql 编程中语句块包含符 就是相当于 js 或 php 中的大括号语法: [标识符 :] begin //语句... end;[标识符]; 标识符就是定义任意的名字而已,比如: if(条件判断) begin //..... end; end if; if(条件判断) A:begin //... end A; end if; A 就是标识符,它的租用是标识该语句块,以期可以在该语句块中使用它--其实就是退出. 流程控制语句 1.if 语句 if 条件语句 then begin 语句块 end; elseif 条件语句 then begin 语句块 end; else begin else 语句块 end; end if; 2.case 语句 相当于 java 的 switch CASE case_value WHEN when_value THEN statement_list WHEN when_value1 THEN statement_list //可以有很多 when 和 then 组合 ELSE statement_list END CASE 语法 case @v1 ... end case; //@v1表示一个变量;后面都这样 3.loop 循环语句 标识符: loop begin //这里就是循环的语句块 //注意这里必须要有一个退出循环的逻辑机制,否则该循环就是死循环,其基本形式类似这样 if(条件) then leave 标识符; //退出 end if; end; end loop 标识符; 4.while循环语句 set @v1\u003c10 do begin insert into tab1 (id,num) values(null, @v1); set @v1 = @v1 + 1; end; end while; 5.repeat语句 类似于dowhile语句,但是这里条件为真就不执行,为假就继续执行. set @v1 = 1; //赋值语句 repeat begin insert into tab1 (id,num) values(null,@v1); set @v1 = @v1+1; end; until @v1 \u003e= 9; end repeat; leave语句 语法: leave 标识符; 作用: 用来退出begin...end结构或其他具有标识符的结构. mysql中的变量 mysql中,有两种变量形式: 普通变量: 不带 @ 符号 形式: declare 变量名 类型名 [default 默认值]; //普通变量必须先这样定义 使用场景:只能在编程环境使用,有3个:1函数内部,存储过程内部,触发器的内部. 会话变量: 带 @ 符号 形式: set @变量名 = 值; //跟php类似,无需定义,直接赋值,第一次就算是定义 使用场景: 任何场景. 变量赋值 set 变量名 = 表达式; #此语法中的变量必须先使用declare声明. set @变量名 = 表达式; #此方式可以无需declare语法声明,而是直接赋值,类似php定义变量并赋值. select @变量名:=表达式; #此语句会给该变量赋值,同时还会作为一个select语句输出结果集. select 表达式 into @变量名;#此语句虽然看起来是select语句,但其实并不输出结果集,而只是给变量赋值. (存储)函数 函数,也说成存储函数,其实就是js和php中所说的函数. 注意: 在函数内部,可以有各种变量和流程控制的的使用. 在函数内部,也可以有各种增删改语句. 在函数内部,不可以用select或其他返回结果集的查询类语句. 唯一的区别: 这里的函数必须返回一个数据(值); //创建一个函数 create function getMaxValue(p1 float, p2 float, p3 float) returns float; #返回float类型 begin .... # 要执行的内容 end; 上处代码直接在命令行执行可能会有error,因为代码中包含; 会提前结束没有完成的语句.解决方案可以通过修改’语句结束符’. delimiter /// 删除函数 drop function ","date":"2016-05-18","objectID":"/posts/mysql-%E5%9B%9B-%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80%E6%8E%A7%E5%88%B6%E5%99%A8%E7%AD%89/:0:4","tags":["mySql"],"title":"MySql(四)--数据控制语言控制器等","uri":"/posts/mysql-%E5%9B%9B-%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80%E6%8E%A7%E5%88%B6%E5%99%A8%E7%AD%89/"},{"categories":["mySql"],"content":"存储过程 存储过程,其实还是函数 – 但其规定: 不能有返回值. 创建一个存储过程 效果目标: 将3个数据写入到表tab_int 并返回该表的第一个字段的前3大值得行. create procedure insert_get_date(p1 int, p2 tinyint, p3 bigint) begin insert into tab_int(f1,f2,f3) values(p1,p2,p3); select * from tab_int order by table_int.f1 desc limit 0,3; end; 调用存储过程: call 存储过程名(实参1, 实参2, …) 它应该是在非编程环境中调用,既执行增删改查的场景. 删除存储过程 drop procedure 存储过程名; ","date":"2016-05-18","objectID":"/posts/mysql-%E5%9B%9B-%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80%E6%8E%A7%E5%88%B6%E5%99%A8%E7%AD%89/:0:5","tags":["mySql"],"title":"MySql(四)--数据控制语言控制器等","uri":"/posts/mysql-%E5%9B%9B-%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80%E6%8E%A7%E5%88%B6%E5%99%A8%E7%AD%89/"},{"categories":["mySql"],"content":"触发器 trigger 触发器,也是一段预先定义好的编程代码(跟存储过程和存储函数一样),并有个名字. 它不能调用,而是,在某个表发生某个事件(增,删,改)的时候,会自动触发而调用起来. 定义形式: create trigger 触发器名 触发时机 触发事件 on 表名 for each row begin //…. end; 说明: 触发时机,只有两个: before(在…之前), after(在…之后); 触发事件,只有三个: insert, update, delete 既触发器的含义是: 在某个表上进行insert(或update或delete)之前,或之后. 通常,触发器用于在对某个表进行增删改的操作的时候,需要同时去做另外一件事的时候; 在触发器的内部,有两个关键字代表某种特定的含义,可以用来获取数据new:它代表当前正要执行的insert或update的时候’新行’数据;通过他,可以获取这一新行数据的任意一个字段形式为: set @v1 = new.id; //获得该新插入或update行的id的值(前提是有该id). old:它代表当前正要执行的delete的时候’旧行’数据;通过他,可以获取这一旧行数据的任意一个字段形式为: set @v1 = new.id; //获得该新插入或update行的id的值(前提是有该id). ","date":"2016-05-18","objectID":"/posts/mysql-%E5%9B%9B-%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80%E6%8E%A7%E5%88%B6%E5%99%A8%E7%AD%89/:0:6","tags":["mySql"],"title":"MySql(四)--数据控制语言控制器等","uri":"/posts/mysql-%E5%9B%9B-%E6%95%B0%E6%8D%AE%E6%8E%A7%E5%88%B6%E8%AF%AD%E8%A8%80%E6%8E%A7%E5%88%B6%E5%99%A8%E7%AD%89/"},{"categories":["mySql"],"content":" ","date":"2016-05-17","objectID":"/posts/mysql-%E4%B8%89-%E5%AD%90%E6%9F%A5%E8%AF%A2/","tags":["mySql"],"title":"MySQL(三)--子查询","uri":"/posts/mysql-%E4%B8%89-%E5%AD%90%E6%9F%A5%E8%AF%A2/"},{"categories":["mySql"],"content":"自学小笔记 ","date":"2016-05-17","objectID":"/posts/mysql-%E4%B8%89-%E5%AD%90%E6%9F%A5%E8%AF%A2/:0:0","tags":["mySql"],"title":"MySQL(三)--子查询","uri":"/posts/mysql-%E4%B8%89-%E5%AD%90%E6%9F%A5%E8%AF%A2/"},{"categories":["mySql"],"content":"连接查询 概念: 就是将两个或两个以上的表，连接起来，当做一个数据源，并从中去取得所需要的数据。 就是将每一个表的每一行数据两两之间相互对接起来，每次对接的结果都是连接结果的 一行 数据。 没有条件的连接写法: select * from 表1, 表2; select * from 表1 join 表2; select * from 表1 cross join 表2; 连接基本形式 在代码级别，连接的基本形式为: 表1 [连接形式] join 表2 [on 连接条件]; 如果是3个表，则进一步扩展为: 表1 [连接形式] join 表2 [on 连接条件] [连接形式] join 表3 [on 连接条件] 连接的分类 交叉连接 其实就是上面的连接形式，–因为没有条件，只是按连接的基本概念，将所有数据行都连接起来的结果。它又叫做‘笛卡尔积’。 对于表1 和表2 的连接，交叉结果是: 行数=两个表字段之和； 列数=两个表的乘积数 内连接 形式: select * from 表1 [inner] join 表2 on 连接条件。 例如有 student表和 type表 学生表中包含科目pro_id, 而Type表有每个pro_id字段并对应说明。这时候如果需要类连接查询如下： select * from student inner join type on student.pro_id = type.pro_id; 优化: SELECT o.* ,t.sex FROM db1.join1 as o inner join db1.join2 as t on o.type = t.type; 注意: 这种的表和表之间的内连接传，虽然可以提现为表跟表之间的关系– 一般情况下这就是外键的关系，单并不是有外键关系才可以使用。 左(外)连接 left(outer) join 形式: 表1(左表) left [outer] join 表2(右表) on 连接条件 含义: 就是将两个表的内连接的结果，再加上左边表不符合内连接所设定的条件的那些数据结果。 SELECT o.* ,t.sex FROM db1.join1 as o left join db1.join2 as t on o.type = t.type; 右(外)连接 right(outer) join 同左连接–只不过关键字为right(outer) 全连接 full(outer) join 在mysql中不支持全连接的语法; 含义: 将两个表内连接的结果，加上左边不符合的结果，和右边不符合的结果。 ","date":"2016-05-17","objectID":"/posts/mysql-%E4%B8%89-%E5%AD%90%E6%9F%A5%E8%AF%A2/:0:1","tags":["mySql"],"title":"MySQL(三)--子查询","uri":"/posts/mysql-%E4%B8%89-%E5%AD%90%E6%9F%A5%E8%AF%A2/"},{"categories":["mySql"],"content":"子查询 含义: 一个select语句，就是一个查询语句 select 字段或表达式 from 数据源 where xx条件判断； 上述select部分，from部分，where部分，往往都是一些数据 或者数据的集合。 from部分, 当然就是 表 ，或 表的连接结果，他们也是数据，只是通常为表数据。 例子 select pro_id, price from product where price \u003e (select avg(price) from product) 例子的where后面括号中的select语句就是子查询。 所以可以认为就是在一个查询语句的内部，某些位置，又出现了查询语句。 由此引出了主查询和子查询的概念。 通常，子查询是为主查询服务的，所以子查询获得一定的结果数据之后，才去执行主查询。 形式: select 字段或表达式或子查询 [as 别名] from 表名或链接结果或子查询 where 字段或表达式或子查询的条件判断。 按子查询结果，可分为如下几个 表 子查询 一个子查询返回的结果理论上是多行多列的时候，此时可以当做一个表来使用，通常是放在from后面。 行 子查询 一个子查询返回的结果理论是一行多列的时候。此时可以当做一个行来使用，通常放在行比较语法上。行比较语法类似这样: where row(字段1,字段2) = (select 行子查询); 列 子查询 一个子查询返回的结果理论上是多行一列的时候，此时可以当做多个值来使用。类似(5,8,10,11). 标量 子查询 一个子查询返回的结果理论上是一行一列的时候，此时可以当做一个单个值使用，类似这种: select 5 as c1; 或select ... where id = 17, 或select ... where b\u003e8; 子查询，按位置(场合)分 作为主查询的结果数据 作为主查询的条件数据 作为主查询的来源数据 常见子查询 比较运算符总的子查询 形式: 操作数 比较运算符 (标量子查询) 说明: 操作数，其实就是比较运算符的2个数据之一而已，通常就是一个字段名。 举例: 找出最高价的商品: select * from product where price = (select max(price) from product); 使用in的子查询 以前的in的用法: xx in (值1, 值2, 值3, ...); in的子查询为: xx in (列子查询) 举例: 找出所有列别名称中带电这个字的所有商品。 可以分两步思考: select protype_id from product_type where protype_name like %电%; 为子查询条件 — 以下为主程序 嵌入where其中。 select * product where protype_id in('此处为上一步'); 使用any的子查询 形式: 操作数 比较运算符 any (列子查询); 含义: 当某个操作数(字段) 对于该列子查询的任意一个值，只要有一个满足该比较运算符，则就算是满足了条件。 使用all的子查询 形式: 操作数 比较运算符 all (列子查询); 含义: 当某个操作数(字段) 对于该列子查询的任意一个值，必须全部满足该比较运算符，则就算是满足了条件。 列子查询 子查询只能是一个字段。 举例: 查询出所有非最高价的商品 查询所有的价格 select price form product; 在所有的价格中只有最高价会不满足 \u003cany(全部价格)，所以可以这样 select * from product where price \u003c any(select price from product); 同理: 求出最高价的商品价格，特征： 大于所有的价格 select * from product where price \u003e= all(select price from produc); 使用some的子查询 一句话: some是any的同义词。 使用exists的查询 形式: where exists (子查询) 含义: 该子查询如果有数据，则exists的结果是true，否则就是false。 在实际应用中，该子查询往往都不是独立的子查询，而是会需要跟主查询的数据源(表),建立牟宗关系—通常就是连接关系。建立的方式是\"隐式的\"，既没有在代码上体现关系，单却在内部有其连接的 实质 。 此隐式方式，通常就体现在查询中的where条件语句中，使用了主查询表中的数据(字段)， 问题: 查询商品表中其类别名称中带\"电\"这个字的所有商品。 select * from product where exists(select * from product_type where protype_name like '%电%' and protype_id = product.protype_id); 注意: 这种子查询语句，没法独立存在或者独立运行的，而是必须跟主查询一起使用。 其他子查询，是可以独立运行的，而且会得到一个运行结果。 盖子查询中的条件，应该设定为跟主查询的某个字段有一定的关联性判断。筒仓该判断就是这两个表的 本来该有的脸连接条件。 ","date":"2016-05-17","objectID":"/posts/mysql-%E4%B8%89-%E5%AD%90%E6%9F%A5%E8%AF%A2/:0:2","tags":["mySql"],"title":"MySQL(三)--子查询","uri":"/posts/mysql-%E4%B8%89-%E5%AD%90%E6%9F%A5%E8%AF%A2/"},{"categories":["mySql"],"content":"联合查询union 提示: 在mysql的手册中，将连接查询(join) 翻译为联合查询。而联合查询(union),没有明确翻译。 在通常的书籍或文章，join被翻译为连接查询；而union才被翻译为联合查询。 基本概念 将两个具有相同字段数量的查询语句的结果，以 上下堆叠 的方式，合并为一个查询结果 形式: select 语句1 union [all | distinct] select 语句2; 此联合查询语句，默认会\"自动消除重复行\" ，既默认是distinct。 如果想要将所有数据都显示(允许重复行),就是用all。 ","date":"2016-05-17","objectID":"/posts/mysql-%E4%B8%89-%E5%AD%90%E6%9F%A5%E8%AF%A2/:0:3","tags":["mySql"],"title":"MySQL(三)--子查询","uri":"/posts/mysql-%E4%B8%89-%E5%AD%90%E6%9F%A5%E8%AF%A2/"},{"categories":["mySql"],"content":" ","date":"2016-05-16","objectID":"/posts/mysql-%E4%BA%8C-%E5%9F%BA%E6%9C%AC%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/","tags":["mySql"],"title":"MySQL(二)--基本查询语句","uri":"/posts/mysql-%E4%BA%8C-%E5%9F%BA%E6%9C%AC%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/"},{"categories":["mySql"],"content":"自学小笔记 ","date":"2016-05-16","objectID":"/posts/mysql-%E4%BA%8C-%E5%9F%BA%E6%9C%AC%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/:0:0","tags":["mySql"],"title":"MySQL(二)--基本查询语句","uri":"/posts/mysql-%E4%BA%8C-%E5%9F%BA%E6%9C%AC%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/"},{"categories":["mySql"],"content":"数据库表设计3范式 第一范式(1NF) 要求数据达到原子性，是数据不可再分 第二范式(2NF) 使每一行数据具有唯一性，并消除数据之间的部分依赖 每一行数据具有唯一性: 只要给表设计主键，就可以保证唯一性 消除数据之间的\"部分依赖\" 依赖的概念 就是在一个表中，其中某个字段的值B可以由另一个字段的值A来决定，则此时我们就称为：字段B依赖于字段A,或者字段A决定字段B。 就是根据字段A的某个值，一定可以找出一个确定的字段B的值，就是A决定B. 部分依赖？ 如果某个字段，值依赖于部分主键字段，此时就称为部分依赖。–发生此情况的前提一定是: 主键字段有多个。 完全依赖？ 某个字段，是依赖于主键的所有字段。– 如果一个表的主键只有一个字段，则此时必然是完全依赖。 第三范式(3NF) 独立性，消除传递依赖。 使每个字段都独立地依赖于主键字段(独立性),而要消除其中部分非主键字段的内部依赖–这种内部依赖会构成传递依赖 ","date":"2016-05-16","objectID":"/posts/mysql-%E4%BA%8C-%E5%9F%BA%E6%9C%AC%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/:0:1","tags":["mySql"],"title":"MySQL(二)--基本查询语句","uri":"/posts/mysql-%E4%BA%8C-%E5%9F%BA%E6%9C%AC%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/"},{"categories":["mySql"],"content":"数据操作语言 DML 插入数据(增) 形式1: insert [into] 表名 [(字段名1，字段名2...)] values(值表达式1，值表达式2,...),(),()...; 这是最常用的插入语句，可以一次性插入多行数据，用逗号隔开； 插入语句，要理解为每次插入数据都是以行为单位进行插入； 字段名通常不推荐省略，其后续的值列表应该字段列表一一对应 其中的值表达式，可以是一个直接或函数调用结果，或变量值; 其中，如果对应字段是字符或时间类型，则直接值应该使用单引号 形式2: replace [into] 表名 [(字段名1，字段名2...)] values(值表达式1，值表达式2,...),(),()...; 其跟insert into 几乎一样: 唯一区别 如果插入的数据的主键或唯一键有重复，则此时就会变成修改改行数据 形式3: insert [into] 表名 [(字段名1，字段名2，...)] select 字段名1，字段名2,... from 其他表名; 形式4: insert [into] 表名 set 字段名1=值表达式1，字段名2=值表达式2,...; load data (载入数据) 语法 使用于载入 结构整齐的纯文本数据。 前提也要有一个对应结构的已存在的表。 简单格式: LOAD DATA INFILE '文件名' INTO TABLE 表名; 删除数据 形式: delete from 表名 [where 条件] [order by 排序] [limit 限定]; 说明: 删除数据仍然是以行为单位进行 通常删除数据都需要带where条件，否则就会删除所有数据。 where条件的语法跟select中的语法一样 order by 排序设定，用于指定这些数据的删除顺序，他通常跟limit配合使用才有意义 limit限定用于设定删除多少行(按orderby 设定顺序) ","date":"2016-05-16","objectID":"/posts/mysql-%E4%BA%8C-%E5%9F%BA%E6%9C%AC%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/:0:2","tags":["mySql"],"title":"MySQL(二)--基本查询语句","uri":"/posts/mysql-%E4%BA%8C-%E5%9F%BA%E6%9C%AC%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/"},{"categories":["mySql"],"content":"修改数据 形式: update 表名 set 字段1=值1, 字段2=值2,...[where 条件] [order by 排序字段][limit 限制行数]; 说明: 通常，update语句，也都需要where条件，否则: 就会修改所有(这很少见); where条件的语法跟select中语法一样; order by 用于设定修改的顺序，limit用于设定修改的行数，他们通常也是结合使用(虽然很少用) 实际应用中，通常很少用到order by和limit，修改的常规操作就成为: update 表名 set 字段1=值1，字段2=值2,... where条件 ","date":"2016-05-16","objectID":"/posts/mysql-%E4%BA%8C-%E5%9F%BA%E6%9C%AC%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/:0:3","tags":["mySql"],"title":"MySQL(二)--基本查询语句","uri":"/posts/mysql-%E4%BA%8C-%E5%9F%BA%E6%9C%AC%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/"},{"categories":["mySql"],"content":"数据查询语言 DQL 基本语法形式 select [all | distinct] 字段或表达式列表 [from 子句] [where 子句] [group by 子句] [having 子句] [order by 子句] [limit 子句]; 字段或表达式列表 字段，肯定来源于表，所以必然依赖于from语句 表达式是类似这样一个内容: 8 ， 8+3， now(); //concat()函数是mysql中的系统函数，用于连接多个字符串。 每个输出项(字段或表达式结果)，都可以给其设定一个别名，形式为: 字段或表达式 as 别名。 all 和 distinct 设定select出来的数据，是否消除重复行，可以不写，那就是默认值all。 all表示不消除，既所有都出来，默认值；distinct表示会消除。 form，表示select部分从中取得数据的数据源—就是表。 where，对数据源中的数据进行帅选的条件设定，所以where依赖于form子句。 is 运算符: 空值和布尔值的判断 有四种情况: xx is null: 判断某个字段是null值，就是没有值 xx is not null: 判断某个字段不是null值 xx is true: 判断某个字段为真 xx is false: 判断某个字段为假，false，0，0.0，’’, null 其他扩展 位类型bit: 使用形式: bit[(M)] ，其中M是1~64的数字，表示使用多少位二进制数字来存储数据。插入形式为: b’value’ 比如: b'101' 序列类型serial: 只是BIGINT UNSIGNED NOT NULL AUTO_INCREMENT UNIQUE的一个别名(同义词) 布尔类型bool: 其实只是tinyint(1)的同义词，其值为0就表示false，否则为true between运算符: 范围判断 用于判断某个字段的数据值是否在某个给定的范围之间–适用于数字类型 形式: xx between 值1 and 值2; 含义: xx字段的值在给定值1和值2之间，其实相当于: xx\u003e=值1 and xx\u003c=值2 in运算符 给出确定数据的范围判断 语法: xx in (值1, 值2, 值3, ...); 含义: 表示字段xx的值为所给出的这些值中的一个，就算是满足了条件；这些值，通常是零散无规律的。 like运算符 对字符串进行模糊查找 语法: xx like '要查找的内容' 含义: 实现对字符串的某种特征信息的模糊查找，它依赖于一下两个特殊的符号。 % :它代表任何个数的任何字符 _ :它代表一个任何字符 group by 分组 形式: group by 字段1 [desc|asc] ,字段2 [desc | asc], .... 说明: 分组是对前述已经找出的数据(既where已经筛选结束的)进行某种指定标准依据的分组。 同时，该分组结果，可以同时指定其 排序方式 ：desc倒序 ，asc顺序 通常，分组就是一个字段，2个以上很少 什么叫做分组？ 分组: 就是讲多行数据，以某种标准(就是指定的字段)来进行分类存放。 特别注意: 分组之后的结果，一定要理解为：只有一个个的组。 在部分语言此语法可能会出现不同的问题。 应用中，分组之后，通常只有如下几种可用的组信息。 分组依据本身的信息，其实就是该分组依据的字段名 每一组的数量信息: 就是count(*)获得 原来数据中的 数值类型字段的聚合信息 包括如下几个: 最大值: `max(字段名)`; 最小值: `min(字段名)`; 平均值 `avg(字段名)`; 总和值: `sum(字段名)`; 上述其实是4个系统内部函数。 having 子句 having的作用和where完全一样，但其只是对 分组的结果数据 进行筛选。 既where对原始数据进行筛选； having对分组之后的数据进行筛选。 这里既是在select 后面没有写查询count(*) 时，在having设定筛选条件的时候，也可以使用，因为count(\\*)是独立计算的结果，既对每一组进行原始数据行的统计，并用该条件进行筛选。 恢复(导入)数据 mysql登录后: source \"备份数据文件的完整路径\" order by 子句 用于 将前面取得的数据以设定的标准(字段)来进行排序以输出结果。 形式: order by 字段1 [asc | desc], 字段2 [asc | desc], ... limit子句 用于将 前述取得的数据 ，按指定的行取出来: 从第几行开始取出多少行。 形式: limit 起始行号 , 要取出的行号 说明: 行号默认从0开始， 行号和id没有关系。 ","date":"2016-05-16","objectID":"/posts/mysql-%E4%BA%8C-%E5%9F%BA%E6%9C%AC%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/:0:4","tags":["mySql"],"title":"MySQL(二)--基本查询语句","uri":"/posts/mysql-%E4%BA%8C-%E5%9F%BA%E6%9C%AC%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/"},{"categories":["mySql"],"content":"对select语句进行简要总结 虽然在形式上，select的很多子句都是可以省略的，但是他们的顺序(如果出现)，就不能打乱:必须仍然按照给出的顺序写出 where子句依赖于from子句: 既没有from，就不能有where having子句依赖于group by子句: 既没有group by就不能有having select 中的字段也是依赖于from子句 上述子句的执行过程，基本上也是按照该顺序进行: – 从from的数据源中获取所有的数据，然后使用where对这些数据进行筛选，之后再使用group by子句对筛选出来的数据进行分组，接下来才可以使用having对这些分组的数据进行筛选，然后才可以order by 和limit。 ","date":"2016-05-16","objectID":"/posts/mysql-%E4%BA%8C-%E5%9F%BA%E6%9C%AC%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/:0:5","tags":["mySql"],"title":"MySQL(二)--基本查询语句","uri":"/posts/mysql-%E4%BA%8C-%E5%9F%BA%E6%9C%AC%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/"},{"categories":["mySql"],"content":" ","date":"2016-05-15","objectID":"/posts/mysql-%E4%B8%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/","tags":["mySql"],"title":"MySQL(一)--数据库入门","uri":"/posts/mysql-%E4%B8%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"},{"categories":["mySql"],"content":"自学小笔记 ","date":"2016-05-15","objectID":"/posts/mysql-%E4%B8%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/:0:0","tags":["mySql"],"title":"MySQL(一)--数据库入门","uri":"/posts/mysql-%E4%B8%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"},{"categories":["mySql"],"content":"介绍 SQL: 这是关系数据库的语言标准，STRUCT QUERY LANGUAGE (结构化查询语言); 几个基本的概念 数据库database: 用于存储一个项目/产品/软件所使用的各种数据的一个逻辑单位 数据库管理系统dbms: 其实就是指一个具体的数据库软件产品:database management system 表 table: 用于存储一种数据的结构形式 字段 filed，列 column: 一个数据表中的一个纵列，其实有一个名字又叫字段 记录 record，行 row: mac mysql的默认数据库数据的路径 /usr/local/var/mysql 登录/退出mysql系统 登录: mysql -h 服务器地址 -u 登录名 [-P 端口号] -p 完整登录: mysql --host=服务器地址 --user=用户名 --port=端口 --password 退出: quit; exit; \\q; 注意: 登录数据库系统后，需要使用 set names 编码名; 来设定当前连接数据库的\"环境编码名\"，及当前跟数据库打交道的客户端本身的编码，通常来说，cmd客户端中是固定的gbk编码，而php网页中，是该网页文件的编码。 数据库的备份和恢复 备份: 就是讲一个数据库，完整的转换为一个可以随时携带和传送的文件。 语法: mysqldump -h 服务器地址 -u 登录名 -p 数据库名 \u003e 文件名 恢复: 就是将一个备份的数据库文件，完整的还原为一个可以使用的数据库。 语法: mysql -h 服务器地址 -u 登录名 -p 数据库名 \u003c 文件名 注意: 这两个命令，都是在没有登录 进入的时候使用。其中musqldump命令还要求为管理员身份。 ","date":"2016-05-15","objectID":"/posts/mysql-%E4%B8%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/:0:1","tags":["mySql"],"title":"MySQL(一)--数据库入门","uri":"/posts/mysql-%E4%B8%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"},{"categories":["mySql"],"content":"技术语法规定 注释 单行注释: #注释内容 单行注释: -- 注释内容(–后面有空格存在) 多行注释: /*注释内容*/ 语句行 默认情况下，以英文分号作为一条语句的结束，而且常规操作中都是一次执行一条语句。 mysql中可以认为设定语句的结束符。 delimiter 新的结束符。 大小写问题 mysql语言内部本身不区分大小写。但是mysql某些命令执行会生成文件夹，此时他们会区分，例如在区分大小写的系统中，unix，linux系统。 ","date":"2016-05-15","objectID":"/posts/mysql-%E4%B8%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/:0:2","tags":["mySql"],"title":"MySQL(一)--数据库入门","uri":"/posts/mysql-%E4%B8%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"},{"categories":["mySql"],"content":"数据库定义语句 创建数据库 形式: create database 数据库名 [charset 字符编码名称] [collate 排序规则]; 说明: 字符编码名称是用于设定当前数据库中存储的字符内容以什么编码来存储。 collate排序规则用于设定其中的字符内容的大小关系(先后顺序，对于英文基本没有任何问题,基本不用)。 查看mysql可用的字符集: show charset 查看mysql可用的排序规则: show collation 删除数据库 形式: drop database [if exists] 数据库名; 说明: if exists 适用于一种安全运行的考虑，如果数据库不存在，也不会报错。 修改数据库(字符编码) 基本上，就是修改数据库的属性：只有两个 修改编码和修改排序规则 alert database 数据库名 charset 新的编码名 collate 新的排序规则名 显示所有数据库 show databases; 显示一个数据库的创建语句 形式: show create database 数据库名; ","date":"2016-05-15","objectID":"/posts/mysql-%E4%B8%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/:0:3","tags":["mySql"],"title":"MySQL(一)--数据库入门","uri":"/posts/mysql-%E4%B8%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"},{"categories":["mySql"],"content":"字段类型(数据类型) mysql中，数据类型主要分3大类，数字型，字符型，时间型 整数字节 主要有: int, tinyint, smallint, mediumint, bigint 整数类型所占的空间字节: int: 占4个字节，既32位 tinyint: 占1个字节，既8位，最多能存储256个数字，默认范围是-128~127 bigint: 占8个字节，既64位 整数类型字段的设定形式： 类型名 [(m)] [unsigned] [zerofill] 说明: m表示设定该整数的显示长度，既select输出的时候，123可能显示为00123. unsigned用于设定该整数位无符号数，其实就是没有负数 zerofill用于设定是否填充 0 到一个数字的左边，此时需与设定的长度m配合。 小数类型 有三种: float, double , decimal float: 单精度浮点型，使用4个字节存储数据，其精度大约只有6~7位有效数字 double: 双精度浮点型，使用8个字节存储数据类型，其精度大约有20个有效数字 decimal: 定点小数类型，整数部分最长可以有65位，小数部分最长可以有30位，一般设置格式为: decimal(总位数，小数部分位数) ","date":"2016-05-15","objectID":"/posts/mysql-%E4%B8%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/:0:4","tags":["mySql"],"title":"MySQL(一)--数据库入门","uri":"/posts/mysql-%E4%B8%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"},{"categories":["mySql"],"content":"php操作mysql数据库的必要代码 通常在php网页中完成有关数据库的操作，首先需要如下代码。 $link = mysql_connect(\"数据库服务器地址\",\"用户名\",\"密码\"); //连接数据库系统 mysql_query(\"set names 网页文件编码名\"); //设定连接编码 //或者 mysql_set_charset(\"网页文件编码名\"); mysql_query(\"use 数据库名\"); //选定要使用的数据库 //或者: musql_select_db(\"数据库名\"); 当执行了连接的前置动作 之后就可以使用mysql_query(\"\"); 来执行任何的sql语句。 场景一:执行没有数据返回的语句，比如：insert,update,delete,create,create table,drop...（通过true和false判断） 场景二:执行有数据返回的语句: select, show tables,show databases, desc 表名(显示数据结构)失败返回false，成功返回一个数据集。 补充: mysql_error(): 获取mysql执行失败时的错误信息，通常在mysql_query()之后使用。 结果集的处理 while($rec = mysql_fetch_array($result)){ // mysql_fetch_array()会取出该结果集中的\"一行数据\",并取得该行数据后赋值值给$rec; //$rec就是一个数组，其下标就是字段名 //在此while循环中，mysql_fetch_array()会一次次(一行行)取出结果集中的所有数据。 } fetch函数的3中形式 mysql_fetch_assoc(); 返回的是字段名 和对应的字段值 mysql_fetch_row(); 返回的没有字段名以下标0为起始点作为键 mysql_fetch_array(); 返回的是键 为有规律的数字，也有字段名的两种组合，就是上面的两种组合。 ","date":"2016-05-15","objectID":"/posts/mysql-%E4%B8%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/:0:5","tags":["mySql"],"title":"MySQL(一)--数据库入门","uri":"/posts/mysql-%E4%B8%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"},{"categories":["mySql"],"content":"扩展php中操作mysql数据的几个函数: $n1 = mysql_num_rows(结果集); //获得该结果集的数据行数 $n2 = mysql_num_fields(结果集); //获得该结果集的数据列数 $n3 = mysql_field_name(结果集,$i); //获得该结果集的第i个字段的名字，从0开始。 ","date":"2016-05-15","objectID":"/posts/mysql-%E4%B8%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/:0:6","tags":["mySql"],"title":"MySQL(一)--数据库入门","uri":"/posts/mysql-%E4%B8%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"},{"categories":["mySql"],"content":"字段类型 字符类型 varchar类型: 可变长度字符串，使用时我们必须设定其长度，其最大长度理论值为65535个，实际其实最大只能是65533个，单考虑到存储的字符编码不同，也会有进一步减少。例如如果哦存储中文gbk，则最多是65533/2个，如果存储中文utf8,则最多是65533/3个。此类型的实际长度是存储内容决定，而设定值只是表示最多可存储的字符个数， char类型: 定长字符串；使用时通常需要设定其长度，如果不设定默认是1，最大理论长度是255个。定长字符串使用与存储的数据都是可预见的明确的固定长度的字符，比如手机号，中国邮政编码。实际存储的时候，如果少于设定长度，也能存，但都会补空格填满。 enum类型: 单选项字符串数据类型。它分成适用于存储表单界面中的单项值。它设定的时候，是需要给定固定的几个选项，然后存储的时候，就只存储其中一个值。使用形式: enum(“选项1”,“选项2”,“选项3”,“选项4”….);实际内部: 这些字符串选项值对应的是如下数字值:1234….65535个轩轩个 set类型: 单选项字符串数据类型。它分成适用于存储表单界面中的多项值。它设定的时候，是需要给定固定的几个选项，然后存储的时候，就只存储其中若干值。使用形式: set(“选项1”,“选项2”,“选项3”,“选项4”….);实际内部: 这些字符串选项值对应的是如下数字值:1248….64个选项 text类型: 长文本字符类型，通常，其中存储的数据不占据表格中的数据容量限制。其本身最长可存储65535个字符。其他同类字符类型: smalltext,tinytext, longtext. 其他类型(了解): binary类型: 定长二进制字符串类型，里面存储的是二进制； varbinary类型: 边仓二进制字符串类型，里面存储的是二进制值； blob类型: 二进制数据类型，存的仍然是二进制值，但其适用于存储图片，其他文件等。单极少用。 时间类型 datetime类型: 时间日期类型 date类型: 日期类型 time类型: 时间类型 year类型: 年份类型 在应用中，时间日期类型，在我们自己给定的数据情况下，需要使用单引号引起来，跟字符串一样。 timestamp: 时间戳类型，就是指一个时间的数据值，本质就是一个数字，类似js中的GetTime()或php中的Time()。 它的一个重要的作用是: 是会自动获得时间戳的数据值–相当于\"now()\" ","date":"2016-05-15","objectID":"/posts/mysql-%E4%B8%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/:0:7","tags":["mySql"],"title":"MySQL(一)--数据库入门","uri":"/posts/mysql-%E4%B8%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"},{"categories":["mySql"],"content":"表定义语句 创建表 create table [if not exists] 表名(字段列表[,索引或约束列表]) [表选项列表]; 字段设定形式 字段名 类型 [字段属性1 字段属性2 ...] 字段名可以自己取 类型就是前面所学的数据类型: int, tinyint, float, double , char(5), varchar(25),text,datetime... 子弹属性可以有多个，相互之间直接空格隔开; 主要有auto_increment: 只用于整数类型，让该字段的值自动获得一个增长值。通常用于做一个表的第一个字段的设定，并且通常还当做主键(primary key)primary key : 用于设定该字段为主键，此时该字段的值就可以唯一的确定一行数据。unique key: 设定该字段是惟一的，也就是不重复的not null: 用于设定该字段不能为空。default xx值: 用于水规定该字段的默认值，如果此时insert没有给值得时候就使用该默认值comment : 字段说明文字。 ","date":"2016-05-15","objectID":"/posts/mysql-%E4%B8%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/:0:8","tags":["mySql"],"title":"MySQL(一)--数据库入门","uri":"/posts/mysql-%E4%B8%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"},{"categories":["mySql"],"content":"索引 系统内部自动维护的隐藏的数据表，它的作用是可以极大的加快数据的查询速度。 这个隐藏的数据表，其中的数据是自动排好序的，其查找速度就是建立在这个基础上的。 索引的类型 普通索引: 形式 key(字段名)含义 仅仅是一个索引，没有其他作用只能加快查找速度。 唯一索引: 形式 unique key(字段名)含义 是一个索引，而且具有区分改变中的任何一行数据的作用(其实也是唯一性),与唯一索引区别，唯一性可以为null，而主键不能为空。 主键索引: 形式 primary key(字段名) 全文索引: 形式 fulltext (字段名) 外建索引: 形式 foreign key(字段名) references 其他表(对应其他表中的字段名) 外键: 就是设定某个表中的某一个字段，它的数据的值，必须在另一个表中某个字段中存在。 ","date":"2016-05-15","objectID":"/posts/mysql-%E4%B8%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/:0:9","tags":["mySql"],"title":"MySQL(一)--数据库入门","uri":"/posts/mysql-%E4%B8%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"},{"categories":["mySql"],"content":"约束 含义: 就是要求数据满足什么条件的一种规定。 主键约束 作用：使该设定字段的值可以用于唯一确定一行数据，其实就是主键的意思 唯一约束 作用：是该设定字段字段具有唯一性，自然也是可区分的 外键约束 作用：使该设定字段的值，必须在其设定的对应表的对应字段中已经有该值了。 非空约束 not null: 设定一个字段时写的那个not null属性。 默认约束 default xx值. :设定一个字段的默认值属性。 检查约束 check(某种判断语句)。 索引和约束其实是相同一件事情的不同角度的两种说法，例如方法和函数。 ","date":"2016-05-15","objectID":"/posts/mysql-%E4%B8%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/:0:10","tags":["mySql"],"title":"MySQL(一)--数据库入门","uri":"/posts/mysql-%E4%B8%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"},{"categories":["mySql"],"content":"表选项列表 创建一个表的时候，对该表的整体设定，主要有如下几个 charset=要使用的字符编码 engine=要使用的存储引擎(也叫表选项) auto_increment=设定当前表的自增长字段的初始值，默认是1 comment='该表的一些说明文字' 说明: 设定的字符编码是为了跟数据库设定的不一样，如果一样就不需要设定了，因为其会自动使用数据库级别的设定。 engine 存储引擎，在代码层面，就是一个名词:InnoDB,MyIsam,BDB,archive,Memory. 存储引擎: 存储引擎是讲数据存储到硬盘的机制。不同的存储引擎，其实主要从两大层面设计存储机制-速度或者功能。 ","date":"2016-05-15","objectID":"/posts/mysql-%E4%B8%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/:0:11","tags":["mySql"],"title":"MySQL(一)--数据库入门","uri":"/posts/mysql-%E4%B8%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"},{"categories":["mySql"],"content":"修改表 说明: 修改表，是指修改表的结构–正如创建表也是设定表的结构。 创建表能做的事，修改表几乎都能做–但不推荐去修改表，而是应该在创建表的时候就基本确定表的结构。 对字段进行增删改；对索引进行增删 标的选项通常都是修改，即使不写任何表选项，他们都有其默认值。 常见的操作: 新建字段: alert table 表名 add [column] 新字段名 字段类型 [字段属性列表]; 修改字段: alert table 表名 change [column] 旧字段名 新字段名 新字段类型 [新字段属性列表]; 删除字段: alert table 表名 drop [column] 字段名; 添加普通索引: alter table 表名 add key [索引名] (字段名1[,字段名2,...]); 添加唯一索引(约束): alert table 表名 add unique key(字段名1[,字段名2,...]); 添加主键索引(约束): alter table 表名 add primary key(字段名1[,字段名2,...]); 修改表名: alter table 旧表名 rename [to] 新表名; ","date":"2016-05-15","objectID":"/posts/mysql-%E4%B8%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/:0:12","tags":["mySql"],"title":"MySQL(一)--数据库入门","uri":"/posts/mysql-%E4%B8%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"},{"categories":["mySql"],"content":"删除表 drop table [if exists] 表名; ","date":"2016-05-15","objectID":"/posts/mysql-%E4%B8%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/:0:13","tags":["mySql"],"title":"MySQL(一)--数据库入门","uri":"/posts/mysql-%E4%B8%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"},{"categories":["mySql"],"content":"其他表的相关语句 显示当前数据库中的所有表: show tables; 显示某表的结构: desc 表名; 或者 describe 表名; 显示某表的创建语句: show create table 表名; 重命名表: rename table 旧表名 to 新表名; 从已有表复制表结构: create table [if not exists] 新表名 like 元表名; ","date":"2016-05-15","objectID":"/posts/mysql-%E4%B8%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/:0:14","tags":["mySql"],"title":"MySQL(一)--数据库入门","uri":"/posts/mysql-%E4%B8%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"},{"categories":["mySql"],"content":"视图的定义 含义 类似于函数的功能。 就是一个select语句(通常比较复杂),我们给其一个名字(视图名),以后要使用该select语句，直接用该视图名就可以。 创建语法 语法形式: create view 视图名 as select语句; 举例: create view v1 as select id, fi, name, age from table where id\u003e7 and id\u003c100 or fi\u003c1000 and age\u003e10; 使用视图 当做一个表用即可： select * from 视图名 [查询条件]; 删除视图 drop view [if exists] 视图名; ","date":"2016-05-15","objectID":"/posts/mysql-%E4%B8%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/:0:15","tags":["mySql"],"title":"MySQL(一)--数据库入门","uri":"/posts/mysql-%E4%B8%80-%E6%95%B0%E6%8D%AE%E5%BA%93%E5%85%A5%E9%97%A8/"},{"categories":["PHP","入门"],"content":" ","date":"2016-04-18","objectID":"/posts/php-%E5%9B%9B-%E5%87%BD%E6%95%B0-%E6%95%B0%E7%BB%84%E4%BB%8B%E7%BB%8D/","tags":["PHP","入门"],"title":"PHP(四)-函数 数组介绍","uri":"/posts/php-%E5%9B%9B-%E5%87%BD%E6%95%B0-%E6%95%B0%E7%BB%84%E4%BB%8B%E7%BB%8D/"},{"categories":["PHP","入门"],"content":"自学小笔记 ","date":"2016-04-18","objectID":"/posts/php-%E5%9B%9B-%E5%87%BD%E6%95%B0-%E6%95%B0%E7%BB%84%E4%BB%8B%E7%BB%8D/:0:0","tags":["PHP","入门"],"title":"PHP(四)-函数 数组介绍","uri":"/posts/php-%E5%9B%9B-%E5%87%BD%E6%95%B0-%E6%95%B0%E7%BB%84%E4%BB%8B%E7%BB%8D/"},{"categories":["PHP","入门"],"content":"函数 函数的基础 函数的定义： function 函数名 ([$ 形参1][,$ 形参2]){ //函数体 } 因为js php 都是动态赋值，创建也不需要声明类型。而是根据内容而定，所以在定义函数的时候，形参不需要加参数类型。 php中可以在定义形参的时候设置默认值，如果设置了默认值，在使用的时候可以不添加实参。 函数的参数 php中声明函数的时候可以设置，形参的传递类型，在形参的前面加上\u0026符号，即可实现引用传递(默认是值传递)，声明了引用传递必须要传递变量。使用了引用传递会改变传递进来的参数的最终结果，而值传递只相当于复制了一份值丢进函数，引用是把自己丢进去。 //演示函数引用参数传递 function f2($i , \u0026 $j){ $i = $i * $i; $j = $j * $j; return $i + $j; } $va_1 = 3; $va_2 = 4; $result_f2 = f2($va_1, $va_2); //最终 $va_1 = 3, $va_2 = 16 php中可以定义函数特殊形式，不指定接收的形参，单却可以接收所有的实参。系统中也有类似的函数。比如,获取变量的类型和值的var_dump()。 var_dump($1); var_dump($2,$3,$4); //定义一个没有形参的函数，但是却能截取到传递进来的所有实参 function f3(){ //使用系统函数可以获取到函数调用时传递过来的所有参数 $arr = func_get_args(); echo \"函数被调用的参数:\"; foreach ($arr as $value) { echo $value.\", \"; } echo \"\u003chr\u003e\"; } f3(1,2,3,true,1.2,\"abc\"); f3(222,\"-\"); 这样的函数依赖于以下三种系统函数。 * func_get_args(); //获取实参数据列表，成为一个数组 * func_get_arg($i); //获取第$i个实参数据，$i从0开始算起,有风险出现角标越界。可配合以下使用 * func_num_args(); //获取实参的数量。 函数的返回值 同js一样，需要返回值就在return后面追加要返回的即可，retrun 本身作用立即结束掉此函数的执行。 函数的其他形式 可变函数: 一个函数的名字是一个变量。(可变变量，例:$$v1. 一个变量的名字是一个变量) 匿名函数: 没有函数名的函数。 有两种形式： 将匿名函数赋值给一个变量， 调用时使用 变量();即可调用。 直接将一个匿名函数，当做实参来使用，在另执行另一个函数时，使用一个匿名函数来当做实参。类似与java的new runnble ，接口回调等。 变量的作用域问题 php中可以分为三种变量作用域： 1.局部作用域: 就是指一个函数的内部范围。 对应这样的变量，理解为局部变量 2.超全作用域 就是所有代码范围，这样的变量称为超全局变量。 主要是系统预定义的几个: $_GET, $_POST, $_SERVER, $_REQUEST, $GLOBALS, $_SESSION, $_COOKIE, $_FILES. 3.全局作用域 就是不在函数内部的范围，函数外部。对应这样的变量，就称为全局变量。 通常情况 全局范围不能访问局部变量 局部范围不能访问全局变量 php中也存在静态变量 ，在变量名$ 前面使用static声明。 静态变量一旦声明赋值后，以后再执行就不会再重新声明并赋值了。常用于统计函数调用次数。 如果想在局部范围访问全局变量。 1 使用global，创建一个同名的局部变量。 $temp_1 = 10; echo \"定义的全局变量=\".$temp_1.\"\u003cbr/\u003e\"; function visitVar(){ // 使用global声明一个全局变量，并在局部范围创建一个同名的局部变量， 这两个变量同时指向同一块数据存储块的数据。 global $temp_1; echo \"在局部访问的全局变量\u003cbr/\u003e\"; // 对局部变量指向的值进行更改，同时可以修改全局变量的值，因为他们是指向相同的内存地址。 $temp_1 = \"修改成功\"; } visitVar(); echo \"在全局范围在此访问，全局变量：\".$temp_1; 2.使用$GLOBALS['变量名'] 在内部使用$GLOBALS[]可以访问函数外定义的全局变量。 此时在函数内部如果使用unset(),那么函数外的常量值也会被修改，这点和使用global声明并在创建一个同名局部变量的方法不同。 有关函数的系统函数 * function_exists() //判断函数是否存在 * func_get_arg() //获得实参中的某一个 * func_get_args() //过得所有实参 并添加一个数组返回 * func_num_args() //过得所有实参的个数 字符串函数 * 输出与格式化: echo, print, printtf, print_r, var_dump * 字符串去除与填充: trim, ltrim, rtrim, str_pad * 字符串连接与分割: implode， join, explode, str_split * 字符串截取: substr, strchr, strrchr * 字符串替换: str_replace, substr_replace * 字符串长度与位置: strlen, strpos, strrpos * 字符串转换: strtolower, strtoupper, lcfirst, ucfirst, ucwords * 特殊字符串处理: nl2br,addslashes, htmlspecialchars,htmlspecialchars_decode 时间函数 time,microtime,mktime,date,idate,strtotime,date_add,date_diff,date_default_timezone_set,date_default_timezome_get 数学函数 * max, min, round, ceil, floor, abs, sqrt, pow, rand ","date":"2016-04-18","objectID":"/posts/php-%E5%9B%9B-%E5%87%BD%E6%95%B0-%E6%95%B0%E7%BB%84%E4%BB%8B%E7%BB%8D/:0:1","tags":["PHP","入门"],"title":"PHP(四)-函数 数组介绍","uri":"/posts/php-%E5%9B%9B-%E5%87%BD%E6%95%B0-%E6%95%B0%E7%BB%84%E4%BB%8B%E7%BB%8D/"},{"categories":["PHP","入门"],"content":"函数的编程思想 递归思想–递归函数 特征: 在一个函数内部调用它自己的函数。并且在某一个时刻会停止下来。 需求: 1, 1, 2, 3, 5, 8, 13…. 每一项都是前两项的和。那么第二十项是多少？ function add($count){ if($count ==1 || $count==2){ return 1; } return add($count-1) + add($count-2); } 特点，由外进内，由内的外。 耗性能 php中也有和meta一样的函数，告诉浏览器，用什么编码显示本网页 header(\"Content-Type: text/html; charset=UTF-8\"); ","date":"2016-04-18","objectID":"/posts/php-%E5%9B%9B-%E5%87%BD%E6%95%B0-%E6%95%B0%E7%BB%84%E4%BB%8B%E7%BB%8D/:0:2","tags":["PHP","入门"],"title":"PHP(四)-函数 数组介绍","uri":"/posts/php-%E5%9B%9B-%E5%87%BD%E6%95%B0-%E6%95%B0%E7%BB%84%E4%BB%8B%E7%BB%8D/"},{"categories":["PHP","入门"],"content":"数组 含义: 数组就是一系列数据的集合体，他们按设定的顺序排列为一个\"链的形状\". 注意 php的数组单元的顺序，跟下标无关。 数组的定义： * $arr1 = array(3,5,6,8); //默认下标，从0开始。和java中的list相似。 * $arr2 = array(\"a\"=\u003e3,\"b\"=\u003e11,\"cc\"=\u003e18); //关联数组，下标为字符串 和java map类似。 * $arr3 = array(1=\u003e2,2=\u003e3) 下标也可以混合使用。 下标如果重复那么就会覆盖。 php中，数组单元的顺序，是由其放入的顺序决定，而不是下标。 按键值得关系来分 索引数组: 通常认为，如果一个数组的下标是严格按照从0开始的连续的整数作为下标，则称其为索引数组，就是类似于js数组的下标。 关联数组: 通常认为，如果一个数组的小标都是一个字符串并在一定程度上表名了该单元的含义则称为关联数组。 混合数组: 既有数字下标, 也有字符下标的情况。 数组的遍历 foreach基本语法 foreach($arr as $key =\u003e $value){ //使用$key $value 得到想要的值 } 数组指针的常规使用 * $v1 = current($数组); //获得数组的当前指针所在的\"值\" * $v2 = key($数组); //获得数组的当前指针所在的\"键\"（下标） * $v3 = next($数组); //获得数组的指针先下移动一个单元，然后取得新的单元值 * $v4 = prev($数组); //获得数组的当前指先向上移动一个单元，然后去的新的单元值 * $v5 = end($数组); //获得数组的当前指针移动到最后一个单元，然后取得新单元的值 * $v6 = reset($数组); //获得数组的当前指针移动到第一个单元，单后取得新的单元值 数组的遍历方式 php中因为键的灵活性，往往不能单纯的for循环遍历。除非下标为连续的纯数字数组。 foreach for + next for + list each()函数的使用 each()函数的作用: 先取一个数组的 当前单元 的下标和值(并放入一个数组),然后将指针移到下一个单元。 each取到的值为一个数组：例如 //一个数组的第一个元素为角标1，元素值3 array里面有四个值 key value 0 1 key和0 的值相同 value和1 的值相同 数组变量的一些细节 foreach也是征程的循环语法结构，可以与break和continue等操作。 遍历过程中值变量默认的传值方式是值传递。 遍历过程中值变量可以人为的设定为引用传递。 foreach默认是原数组上进行遍历，如果在遍历过程中对数组进行了某种修改或某种指针性操作，则会复制数组后再复制的数组上继续遍历循环。 foreach中如果值变量是引用传递，则无论如何都是在原数组上进行的。 ","date":"2016-04-18","objectID":"/posts/php-%E5%9B%9B-%E5%87%BD%E6%95%B0-%E6%95%B0%E7%BB%84%E4%BB%8B%E7%BB%8D/:0:3","tags":["PHP","入门"],"title":"PHP(四)-函数 数组介绍","uri":"/posts/php-%E5%9B%9B-%E5%87%BD%E6%95%B0-%E6%95%B0%E7%BB%84%E4%BB%8B%E7%BB%8D/"},{"categories":["PHP","入门"],"content":"数组的查找算法 所谓查找算法, 大体主要是解决这样一个问题: 找出某个数组中，是否存在某个值(数据)。 顺序查找 遍历整个数组，一个一个判断，如果相等，就表示有，然后退出即可。 二分查找算法 针对的是索引数组。 针对的是已经排好序的数组 关于效率问题： 21E个数据，约为32次找出 100W个数据，约20次 ","date":"2016-04-18","objectID":"/posts/php-%E5%9B%9B-%E5%87%BD%E6%95%B0-%E6%95%B0%E7%BB%84%E4%BB%8B%E7%BB%8D/:0:4","tags":["PHP","入门"],"title":"PHP(四)-函数 数组介绍","uri":"/posts/php-%E5%9B%9B-%E5%87%BD%E6%95%B0-%E6%95%B0%E7%BB%84%E4%BB%8B%E7%BB%8D/"},{"categories":["PHP","入门"],"content":" ","date":"2016-04-17","objectID":"/posts/php%E4%B8%89-%E8%BD%BD%E5%85%A5%E6%96%87%E4%BB%B6%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/","tags":["PHP","入门"],"title":"PHP(三)-载入文件和错误处理","uri":"/posts/php%E4%B8%89-%E8%BD%BD%E5%85%A5%E6%96%87%E4%BB%B6%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"},{"categories":["PHP","入门"],"content":"自学小笔记 ","date":"2016-04-17","objectID":"/posts/php%E4%B8%89-%E8%BD%BD%E5%85%A5%E6%96%87%E4%BB%B6%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/:0:0","tags":["PHP","入门"],"title":"PHP(三)-载入文件和错误处理","uri":"/posts/php%E4%B8%89-%E8%BD%BD%E5%85%A5%E6%96%87%E4%BB%B6%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"},{"categories":["PHP","入门"],"content":"文件加载 基本使用 有四个文件加载语句: include, require, include_once, require_once 以上四种使用形式完全一样: 比如: include “要加载的文件路径\"或 include(“路径”); 区别在于加载失败或是否重复加载这种情况，有所不同。 文件加载 举例说明 以include为例其他三种也适用。 相对路径: 相对于当前网页文件所在的位置为起点。主要适用符号./当前路径,../上一级路径。 绝对路径: 本地路径或者网络绝对路径。 无路径 不推荐适用。只给出文件名没有路径。 文件载入和执行过程详解 第一步: 从include语句处退出php脚本模式(进入html代码模式) 第二步: 载入include语句所设定的文件中的代码，并执行之(如同在当前文件中一样) 第三步: 退出html模式重新进入php脚本模式，继续执行之后的代码。 4个载入语句的区别 include和require的区别: include载入文件失败时(既没有找到该文件)，报一个提示错误，然后继续执行后续代码。 require载入失败时，报错并立即终止执行 所以通常require用于在程序中，后续代码依赖于载入的文件的时候。 include和include_once的区别: include载入的文件不判断是否重复，只要有include语句，就会载入一次。(可能会重复载入) include_once载入的文件会有内部判断机制是否\"前面代码\"已经再如果，如果再如果，就不能在载入。 在被载入文件中return语句的作用 一个载入语句，如果载入成功，会返回int 1，如果载入失败那么返回false。 return语句作用是终止被载入过程–就是return之后的代码不再被执行。 return 也可以作为被载入文件载入时返回的一个数据。 ","date":"2016-04-17","objectID":"/posts/php%E4%B8%89-%E8%BD%BD%E5%85%A5%E6%96%87%E4%BB%B6%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/:0:1","tags":["PHP","入门"],"title":"PHP(三)-载入文件和错误处理","uri":"/posts/php%E4%B8%89-%E8%BD%BD%E5%85%A5%E6%96%87%E4%BB%B6%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"},{"categories":["PHP","入门"],"content":"错误处理 错误的分类，通常有三种 语法错误: 程序运行之前，都要先检查语法。如果语法有错误，会立即报错，并且不会去执行程序。 运行时报错: 程序syntax 检测通过。开始运行程序并在此过程中遇到错误。常见有三种:提示性错误，警告性错误，致命错误。 逻辑错误: 程序本身可以正常执行，但没有报错–但计算结果却不对。 错误的分级 php语言中，将各种错误进行了不同级别的分类归纳，并形成大约10几个级别的错误，这就是技术层面的错误分级。 系统常见错误: E_ERROR: 致命错误 例如调用不存在的函数们无法执行之后代码。 E_ERANING: 警告性错误 例如引入文件无效，视情况而定代码是否执行 E_NOTICE: 提示性错误 例如调用未定义变量，常量 会提示错误并继续执行代码。 用户可自定义的错误: E_USER_ERROR: 自定义致命错误 E_USER_WRANING: 自定义警告性错误 E_USER_NOTICE: 自定义提示性错误 其他: E_STRICT: 严谨性语法检查错误 E_ALL: 代表所有错误 介绍个函数可以填充到想要的位数 str_pad($str1,长度n,$str2,位置w); //将字符串$str1，用字符串$str2填充到指定的长度n，并且可以指定填充的位置，左填充、右填充。 $result = str_pad($s,16,\"0\",STR_PAD_LEFT); 自定义触发 语法格式: trigger_error(\"错误提示内容\",E_USER_ERROR); //E_USER_ERROR可以使三种用户代码其中的任意一个。 显示错误报告 设置php.ini文件中的display_errors: on/off 全局 代码中调用 ini_set(\"display_errors\",0); //0为关，1为开 显示哪些级别的错误报告(error_reporting) php.ini文件中 error_repoting 代码中调用 ini_set(\"error\",E_NOTICE|E_WARNING|E_ERROR); 自定义所务处理器 什么叫错误处理器：就是一旦发生错误，用来处理该错误的一种机器–就是一个函数。 自定义错误处理，就是让系统不要去处理错误，而完全由我们队错误进行处理:显示和记录。 第一步设定要处理错误的函数名 set_error_handler(\"f1\"); 第二步 定义函数 function f1(){...} ","date":"2016-04-17","objectID":"/posts/php%E4%B8%89-%E8%BD%BD%E5%85%A5%E6%96%87%E4%BB%B6%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/:0:2","tags":["PHP","入门"],"title":"PHP(三)-载入文件和错误处理","uri":"/posts/php%E4%B8%89-%E8%BD%BD%E5%85%A5%E6%96%87%E4%BB%B6%E5%92%8C%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/"},{"categories":["JavaScript","入门"],"content":" ","date":"2016-04-16","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E5%85%AD-html5%E4%BB%8B%E7%BB%8D/","tags":["JavaScript","入门"],"title":"基础篇(六)-HTML5介绍","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E5%85%AD-html5%E4%BB%8B%E7%BB%8D/"},{"categories":["JavaScript","入门"],"content":"自学小笔记 ","date":"2016-04-16","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E5%85%AD-html5%E4%BB%8B%E7%BB%8D/:0:0","tags":["JavaScript","入门"],"title":"基础篇(六)-HTML5介绍","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E5%85%AD-html5%E4%BB%8B%E7%BB%8D/"},{"categories":["JavaScript","入门"],"content":"HTML5简介 HTML5是新一代HTML。 HTML5目前主要应用在手机端，在PC端最新浏览器已经开始支持了，但还不全面。 HTML5是由W3C和WHATWG合作的结果。 W3C是万维网联盟，主要制作各种互联网标准的国际组织。如：XHTML、CSS、JavaScript、XML、AJAX等。 WHATWG应用程序工作组，是有Firefox，Chrome，苹果、safari、IE等浏览器公司成立了一个机构。主要面向应用程序的完善和开发。如： 在HTML5中使用\u003cvideo\u003e标记，直接可以播放视频。 \u003cinput type=\"email\" name=\"email\"/\u003e邮箱验证 \u003cinput type=\"color\" name=\"color\" /\u003e \u003cinput type=\"date\" name=\"date\"/\u003e 日历 ","date":"2016-04-16","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E5%85%AD-html5%E4%BB%8B%E7%BB%8D/:0:1","tags":["JavaScript","入门"],"title":"基础篇(六)-HTML5介绍","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E5%85%AD-html5%E4%BB%8B%E7%BB%8D/"},{"categories":["JavaScript","入门"],"content":"文档类型定义 XHTML1.0中的文档类型定义有三种：过渡型，严格型，框架型。 HTML5中的文档类型定义\u003c!DOCTYPE html\u003e. ","date":"2016-04-16","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E5%85%AD-html5%E4%BB%8B%E7%BB%8D/:0:2","tags":["JavaScript","入门"],"title":"基础篇(六)-HTML5介绍","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E5%85%AD-html5%E4%BB%8B%E7%BB%8D/"},{"categories":["JavaScript","入门"],"content":"网页字符集设置 \u003cmeta charset=\"utf-8\"\u003e ","date":"2016-04-16","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E5%85%AD-html5%E4%BB%8B%E7%BB%8D/:0:3","tags":["JavaScript","入门"],"title":"基础篇(六)-HTML5介绍","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E5%85%AD-html5%E4%BB%8B%E7%BB%8D/"},{"categories":["JavaScript","入门"],"content":"页面结构标记 \u003chearder\u003e\u003c/header\u003e网页头部 \u003cnav\u003e\u003c/nav\u003e导航栏、菜单栏 \u003cfooter\u003e\u003cfooter\u003e页脚 ","date":"2016-04-16","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E5%85%AD-html5%E4%BB%8B%E7%BB%8D/:0:4","tags":["JavaScript","入门"],"title":"基础篇(六)-HTML5介绍","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E5%85%AD-html5%E4%BB%8B%E7%BB%8D/"},{"categories":["JavaScript","入门"],"content":"文章相关标记 \u003carticle\u003e: 代表一篇文章。 \u003caside\u003e: 侧边栏。 \u003csection\u003e:区块。主要用于排版网页，功能与\u003cdiv\u003e一样 \u003cdetails\u003e:一个标题的简介。 \u003csummary\u003e:标题的内容，与上面的配合使用。 ","date":"2016-04-16","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E5%85%AD-html5%E4%BB%8B%E7%BB%8D/:0:5","tags":["JavaScript","入门"],"title":"基础篇(六)-HTML5介绍","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E5%85%AD-html5%E4%BB%8B%E7%BB%8D/"},{"categories":["JavaScript","入门"],"content":"其他标记 \u003cmark\u003e: 重点标注。 \u003cprogress\u003e:进度条。max：最大值。value：当前值。 ","date":"2016-04-16","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E5%85%AD-html5%E4%BB%8B%E7%BB%8D/:0:6","tags":["JavaScript","入门"],"title":"基础篇(六)-HTML5介绍","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E5%85%AD-html5%E4%BB%8B%E7%BB%8D/"},{"categories":["JavaScript","入门"],"content":"音频标记 语法格式 \u003caudio\u003e\u003c/aduio\u003e对不起，浏览器不支持audio元素 常用属性 属性 说明 Controls 是否显示控制面板 Autoplay 是否自动开始 src 播放文件路径，支持格式mp3， loop 是否循环 ","date":"2016-04-16","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E5%85%AD-html5%E4%BB%8B%E7%BB%8D/:0:7","tags":["JavaScript","入门"],"title":"基础篇(六)-HTML5介绍","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E5%85%AD-html5%E4%BB%8B%E7%BB%8D/"},{"categories":["JavaScript","入门"],"content":"视频标签 语法格式 \u003cvideo\u003e\u003c/video\u003e对不起，浏览器不支持video元素 常用属性 属性 说明 Controls 是否显示控制面板 Autoplay 是否自动开始 src 视频路径。支持的文件格式：ogg、mp4 loop 是否循环 width 宽度 height 高度 poster 第一帧的画面。默认是视频的第一帧 ","date":"2016-04-16","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E5%85%AD-html5%E4%BB%8B%E7%BB%8D/:0:8","tags":["JavaScript","入门"],"title":"基础篇(六)-HTML5介绍","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E5%85%AD-html5%E4%BB%8B%E7%BB%8D/"},{"categories":["JavaScript","入门"],"content":"表单中新增的属性 autocomplete:自动完成，提示。 autofocus:自动获得焦点。（off/on） ","date":"2016-04-16","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E5%85%AD-html5%E4%BB%8B%E7%BB%8D/:0:9","tags":["JavaScript","入门"],"title":"基础篇(六)-HTML5介绍","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E5%85%AD-html5%E4%BB%8B%E7%BB%8D/"},{"categories":["JavaScript","入门"],"content":"表单input元素type属性的值 tel：电话验证 email：邮箱验证 url：网址验证 color：颜色拾色器 date：日历 month：选择月份 time：时间 datetime：日期时间 ","date":"2016-04-16","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E5%85%AD-html5%E4%BB%8B%E7%BB%8D/:0:10","tags":["JavaScript","入门"],"title":"基础篇(六)-HTML5介绍","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E5%85%AD-html5%E4%BB%8B%E7%BB%8D/"},{"categories":["PHP","入门"],"content":" ","date":"2016-04-16","objectID":"/posts/php%E4%BA%8C-php%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/","tags":["PHP","入门"],"title":"PHP(二)-php基础语法","uri":"/posts/php%E4%BA%8C-php%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["PHP","入门"],"content":"自学小笔记 ","date":"2016-04-16","objectID":"/posts/php%E4%BA%8C-php%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:0:0","tags":["PHP","入门"],"title":"PHP(二)-php基础语法","uri":"/posts/php%E4%BA%8C-php%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["PHP","入门"],"content":"php基本语法形式 区分大小写。 一条语句使用一个分号结束。 php注释形式。 php的标记符 \u003cmeta http-equiv=\"Content-Type\" content=\"text/html;charset=UTF-8\"/\u003e 1. \u003c?php 这里要写符合php语法的语句 ?\u003e 2. \u003cscript language=\"php\"\u003e这里要写符合php语法的语句\u003c/script\u003e 3. \u003c? 这里要写符合php语法的语句 ?\u003e(不推荐，此方法依赖于php.ini中的设置项`short_open_tag = Off`(需要改为On))。 php的结束标记？\u003e 如果php的语句之后，不存在任何的html的代码，那么可以忽略。 php的区分大小写特性 常量区分大小写。 常量通常默认也区分，但可以人为设定为不区分（不推荐）。 其他场合的关键字都不区分，比如函数名，系统关键字(for,if,return…). php的注释 单行注释: 形式1: //注释内容 #注释内容 多行注释: /* 注释内容,可以多行 */ ","date":"2016-04-16","objectID":"/posts/php%E4%BA%8C-php%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:0:1","tags":["PHP","入门"],"title":"PHP(二)-php基础语法","uri":"/posts/php%E4%BA%8C-php%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["PHP","入门"],"content":"变量 含义：名称和值得关系可以称为“引用”(指向).使用一个变量其实就是指使用该变量所引用的值。 使用形式:必须以$开头，后面紧跟变量名。 定义形式:直接个一个变量赋值，如果是第一次，就断是定义了。没有单纯定义变量而不赋值的语句。–所以php不支持“单纯定义” 变量的基本操作 赋值 取值 判断isset():就是判断一个变量是否“有效”，不存在或者值为null都是无效，其他有效。 删除unset():就是判断断开变量名跟数据之间的引用关系。 常用的命名法 驼峰命名：手单词小写，其后每个单词首字母大写。 帕斯卡命名：每个单子首字母大写。 下划线命名：每个单词都小写，并且用下划线区分开。 传递类型 只有两种，引用传递和值传递。 在php中，只有一种语法形式可以实现变量的引用传递方式:\u0026符号。 $v1 = 1; $v2 = \u0026$m1; //引用传值方式 可变变量 $s1 = \"abc\"; //一个变量，里面存储的是字符串\"abc\" $abc = 10; // echo $$s1; // =10 说明： 在php中，一个“$”后面，总是跟着一个变量名。 所以以第一个$ 说明后面是一个变量名，名字为：$1 既“abc”。 所以等价于$abc, 所以等于10. 总结：所谓动态变量，其实就是变量的名字是可以动态变化的以获取不同的数据值。 预定义变量 所谓与定义变量，其实指，php这个语言工具中，预先就定义好的变量；我们只是“拿来使用”。 综述： 主要有：$_GET,$_POST,$REQUEST,$SERVER,$GLOBALS, 均是数组 系统定义与维护 –\u003e 我们不需要给其赋值或者销毁值，只需要用其值即可。 具有超全局作用域 –\u003e 哪里都可以用 不同情形下可能具有不同的值 $_POST变量 含义:它代表用户用过表单以post方式(method=“post”)提交的时候所提交的所有数据–这个称为post数据。 $name = $_POST[name] ; //获取到上一个html中的form表单post提交，name=name的input标签的值。 $age = $_POST[age];//获取到上一个html中的form表单post提交，name=age的input标签的值。 isset(变量): 判断变量是否存在，或者变量是否为null；如果存在返回true，否则就是false。 empty(变量):判断变量内容是否为空，也有一些硬性规定：0，“”，“0”，false，null，array()都是空。 空的话就返回true，否则false。 $_GET变量 含义:代表用户通过get方式(有四种get方式)提交的时候所提交的所有数据–这个称为get数据。 1.form表单 method指定get方式。 2.a标签 在文件名后面追加携带参数 \u003ca href=\"目标文件.php?data1=1\u0026data2=student\u0026age=10\"\u003e链接说明\u003c/a\u003e 3.通过js技术实现的页面跳转，跟a标签的连接功能一样 \u003cscript\u003e location.href = \"目标文件.php?data1=1\u0026data2=student\u0026age=10\"; \u003c/script\u003e //或者使用页面跳转的另一个语法 \u003cscript\u003e location.assign = \"目标文件.php?data1=1\u0026data2=student\u0026age=10\"; \u003c/script\u003e 4.php跳转形式 \u003c?php //语法形式: header(\"location:目标网页地址\"); header(\"location:目标文件.php?key1=value1\u0026key2=value2\"); ?\u003e 输出 print_r($_GET); 或者 var_dump($_GET); $_REQUEST变量 含义:是$_GET变量和$_POST变量的数据的合集，就是它里面同时存储了两种数据。 只要在form表单method为post提交，并且action目标文件后追加参数，会同时出发两种请求。 默认情况下post追加到get之后，但在php.ini中的request_order.可以设置。 $_SERVER变量 含义:它代表在一次浏览网页的过程中的浏览器端的一些信息或服务的一些信息。大约有30左右各信息。常用只是几个。 $_SERVER['REMOTE_ADDR']: 获取访问者的ip地址。 $_SERVER['SERVER_ADDR']: 获取服务器所在的ip地址。 $_SERVER['SERVER_NAME']: 获取服务器的名字，其实就是站点设置中的servername； $_SERVER['DOCUMENT_ROOT']: 获取站点的真实物理位置，其实就是站点设置中的ducumentroot。 $_SERVER['PHP_SELF']: 获取当前网页地址，(不含域名部分) $_SERVER['QUERY_STRING']: 获取当前网页地址中的所有get数据(?之后),就是一个字符串。 GLOBALS变量 含义:他是一个\"重复性数据\",它里面存储了我们自己定义的所有\"全局变量\"。 $v1 = 1; //定义了一个全局变量。 // 这个时候，就有了这样一个数据:$GLOBALS[V1],其值就是1. 场景: 主要是用于在局部范围不可以使用全局变量，但是有需要该全局变量的值，此时就可以用来取全局变量的值。 ","date":"2016-04-16","objectID":"/posts/php%E4%BA%8C-php%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:0:2","tags":["PHP","入门"],"title":"PHP(二)-php基础语法","uri":"/posts/php%E4%BA%8C-php%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["PHP","入门"],"content":"常量 常量是相对于变量说的:是一个其中存储的数据不会改变的\"标识符\"。 常量的 使用就2个方面:定义，取值。 常量的定义: 方式1:defind(“常量名”,常量值); 方式2:const 常量名 = 常量; 常量的使用形式: 直接使用常量的名字 使用函数constant(name)获得一个常量的值。 name是一个常量名字并且是一个字符串。 //取常量值的灵活用法，contant()里面也可以不传字符串。 defind(\"student1\",123); //定义一个常量 $1 = 1 ; $2 = \"student\".$1; echo \"\u003cbr/\u003e 常量student1的值为:\".constant($2); // 这里$2 作为一个字符串的值，等价于常量的名字。 引号中的常量是不能被识别的;而变量却可以。 常量变量的区别 定义形式不同: 使用形式不同: 常量无需使用$ 可变程度不同: 常量的值不可以改变,常量也不可以销毁 作用范围不同: 常量具有超全局作用域(函数内外都可以直接使用) 可用类型不同: 常量只能存储标量类型(整数，浮点数，字符串，布尔) 判断常量是否存在: defind(name)，返回true就存在。 注意: 在php中，当使用一个未定义的常量的时候 ，系统会直接将该常量当做有值的常量去使用，并且其值就是该常量名字–虽然也会报错。 ","date":"2016-04-16","objectID":"/posts/php%E4%BA%8C-php%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:0:3","tags":["PHP","入门"],"title":"PHP(二)-php基础语法","uri":"/posts/php%E4%BA%8C-php%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["PHP","入门"],"content":"预定义常量 就是系统中预先定义好的一些常量，大约有几百个，初学知道几个就行: M_PI: 就是圆周率的常量值。 PHP_OS: php运行所在的操作系统 PHP_VERSION: php的版本号 PHP_INT_MAX: php中的最大的整数值 更多参考手册 ","date":"2016-04-16","objectID":"/posts/php%E4%BA%8C-php%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:0:4","tags":["PHP","入门"],"title":"PHP(二)-php基础语法","uri":"/posts/php%E4%BA%8C-php%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["PHP","入门"],"content":"魔术常量 其实只是常量的形式，但没有常量的\"恒常\"的含义:值会变化，只是很少的几个 __FILE__ 代表当前网页文件的完整物理路径 __DIR__ 代表当前网页文件所在的文件夹 __LINE__ 代表当前这个常量名所在的行号 ","date":"2016-04-16","objectID":"/posts/php%E4%BA%8C-php%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:0:5","tags":["PHP","入门"],"title":"PHP(二)-php基础语法","uri":"/posts/php%E4%BA%8C-php%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["PHP","入门"],"content":"PHP的数据类型 基本类型(标量类型) 整数类型: int, integer 浮点数类型: float，double 字符串类型: string 布尔类型: bool，boolean 复合类型 数组: array 对象: object 特殊类型 空类型: null 这种类型中，只有一个数据，那就是null 资源类型: resource 整数类型 证书类型的四种写法: $n1 = 123; //10进制写法 $n2 = 0123; //8进制写法 $n3 = 0x123; //16进制写法 $n4 = 0b1010; //2进制写法(在php5.4以前不支持) 以上定义变量，是因为赋值的值书写成整数形式，如果用字符串也可以 就不需要前面的标示区分例如:0,0x,0b。 进制的转换问题 bin: 2进制 oct: 8进制 dec: 10进制 hex: 16进制 使用方式: 两个进制转换的缩写名组合(要被转换数字)。六种 // 十进制转其他进制 decbin(123); //将十进制转成二进制 返回为一个字符串。 decoct(123); //将十进制转成八进制 返回为一个字符串。 dechex(123); //将十进制转成十六进制 返回为一个字符串。 // 其他进制转十进制 同上3种 注意 除了10进制为数字，其他进制类型可以认为是字符串。 ","date":"2016-04-16","objectID":"/posts/php%E4%BA%8C-php%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:0:6","tags":["PHP","入门"],"title":"PHP(二)-php基础语法","uri":"/posts/php%E4%BA%8C-php%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["PHP","入门"],"content":"进制转换的人工计算 10进制转换为2进制 做法: 除2取余倒着写出所有余数。 详细解释: 讲一个10进制数字处理2，得到商和余数，如果商还大于等于2，则继续除以2，继续得到商和余数，以此类推，知道商为0为止，然后将前面的所有余数按倒序写出来就是对应的2进制数字。 10进制转换为8进制 做法: 除8取余倒着写出所有余数。 详细解释: 讲一个10进制数字处理8，得到商和余数，如果商还大于等于8，则继续除以8，继续得到商和余数，以此类推，知道商为0为止，然后将前面的所有余数按倒序写出来就是对应的8进制数字。 10进制转换为16进制 做法: 除16取余倒着写出所有余数。 详细解释: 讲一个10进制数字处理16，得到商和余数，如果商还大于等于16，则继续除以16，继续得到商和余数，以此类推，知道商为0为止，然后将前面的所有余数按倒序写出来就是对应的16进制数字。 其他进制换为10进制的做法: 一种数字的大小和\"数字权值\"有关。例如: 例如: 对一个10进制数字: 1234，可以这样去理解它的大小: 1234 = 1*103 + 2*102 + 3*101 + 1*100 = 1000+200+30+4 ; 对于103，102，101等，称为\"权值\"，每个位的权值是不同的。 对于10进制，每个位上权值都是10的几次方。 对于16进制，每个位上权值都是16的几次方。 对于8进制，每个位上权值都是8的几次方。 ","date":"2016-04-16","objectID":"/posts/php%E4%BA%8C-php%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:0:7","tags":["PHP","入门"],"title":"PHP(二)-php基础语法","uri":"/posts/php%E4%BA%8C-php%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["PHP","入门"],"content":"浮点类型 浮点数的两种表示形式 1.常规写法： $v1 = 123.456; 2.科学计数法:带一个特殊符号\"E\" $v1 = 123.456E3; //123.456乘以10的3次方。 即使为123456，但是仍然是浮点类型。 浮点数使用的细节 1.浮点数不应该进行大小比较 所有数字，最终的表示形式，都是2进制!!! 大多数浮点数的2进制形式，不能完全表达准确。最终只能以很高的精度接近理论值。 因此，浮点数比较是不可靠的。 以上说明：php中输出其实是做了一定的处理之后的显示结果，而js得输出是计算机算出的结果。 java中float上限为小数点后六位，double为小数点后15位。 小数转二进制的做法:乘以2并顺序取整数部分 //将小数0.6125转换为2进制小数形式： //小数转二进制的做法: 乘以2并顺序取整数部分。 0.6125 整数 *2 =0.225 1 *2 =0.45 0 *2 =0.9 0 *2 =0.8 1 *2 =0.6 1 --\u003e 已经开始循环 *2 =0.2 1 *2 =0.4 0 *2 =0.8 0 *2 =0.6 1 --\u003e 循环起始点 *2 =0.2 1 ...... 其最后结果: 0.1001 1100 1100 1100 ....(float 最多就是32个) 如果小数位0.625 那么就不需要循环可以除开。 为:0.101 当整数运算的结果超出整数的范围后，会自动转换为浮点数(了解) 获取一个数据(变量)的类型的函数： getType($变量); 返回的是该类型的名字(字符串); var_dump($变量); 会输出该变量的类型，数据内容，(以及长度)。 int类型最大数字为10位数字，max=2147483647≈21E ","date":"2016-04-16","objectID":"/posts/php%E4%BA%8C-php%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:0:8","tags":["PHP","入门"],"title":"PHP(二)-php基础语法","uri":"/posts/php%E4%BA%8C-php%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["PHP","入门"],"content":"字符串 php中字符串的定义有四种形式: 形式 1:双引号字符串 * $str1 = \"字符串内容\"; 内容中可能使用到的转义符: \\\\,\\' 形式 2: 单引号字符串: $str2 = \"字符串内容\"; 内容中可能使用到的转义符: \\\\,\\',\\n（换行符）,\\r（回车符）,\\t(tab符),\\$ 取消了在双引号字符串中的php的变量名起始声明含义 形式 3: 双引号定界符字符串 $str3 = \u003c\u003c\u003c \"标识符A\"\u003cbr/\u003e字符串内容\u003cbr/\u003e标识符 ; 形式 4: 单引号定界符号字符串 $str4 = \u003c\u003c\u003c '标识符B' \u003cbr/\u003e字符串内容\u003cbr/\u003e标识符 上处3 4形式结束一行，只能出现该标识符本身以及一个分号，其他什么都不允许出现。 ","date":"2016-04-16","objectID":"/posts/php%E4%BA%8C-php%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:0:9","tags":["PHP","入门"],"title":"PHP(二)-php基础语法","uri":"/posts/php%E4%BA%8C-php%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["PHP","入门"],"content":"布尔类型 单词bool，boolean。 只有true和false。 需要知道以下数据是被当做false的存在。 0，0.0， “\"， “0”， null， array()， false，还有一个为定义变量。 参考: 手册 –\u003e 附录 –\u003e php类型比较表 ","date":"2016-04-16","objectID":"/posts/php%E4%BA%8C-php%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:0:10","tags":["PHP","入门"],"title":"PHP(二)-php基础语法","uri":"/posts/php%E4%BA%8C-php%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["PHP","入门"],"content":"类型转换 自动转换 在任何运算中，如果需要某种类型的数据，而给出的数据不是该类型，通常会发生自动转换。将该类型转换为目标需要的类型。 例如: octdec($x),bindec($x),hexdec($x); 这里的$x必须是字符串如果不是就会自动转换。 $n1 = 1+\"2\"; //3 $n2 = \"1\"+\"2\"; //3 //php中，算术运算符，就只能对数值进行计算，即使是字符串会强转为数字，如果不是数字那么强转结束，只保留从开始成功的一部分。 $n3 = 1 +\"2abc\" //3 $n4 = 1 +\"abc2\" //1 $n5 = 1 +true; //2 $n6 = 1 +false; //1 强制转换 自动类型转换是由\"运算符\"或类似运算符的语句来决定。 强制类型同java一样，在前面做类型声明强转。 通常的转换类型有，int，float，string，bool，array，object。 这种强转类型，并不能改变该变量的本身数据或类型。对应，有一个语法是直接改变本身的数据以及类型： settype(变量名,要重设的值); ","date":"2016-04-16","objectID":"/posts/php%E4%BA%8C-php%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:0:11","tags":["PHP","入门"],"title":"PHP(二)-php基础语法","uri":"/posts/php%E4%BA%8C-php%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["PHP","入门"],"content":"类型相关的函数 var_dump() 用于输出变量的“完整信息”，几乎只用于调试代码。 getType($变量名) 获取给变量能够的类型名字，返回的是一个表示该类型的字符串。如“string”，“bool” setType($变量名，“目标类型”) 将该变量强制改变为目标类型 isset(),empty(),unset() 之前有介绍。 is_XX类型() 系列函数 判断$x是否是一个整数类型 is_int($s); //判断是否是一个整数类型 is_float($s); … is_numeric($s);//判断是否是一个数字 is_scalar($s); //判断是否是一个标量类型 ","date":"2016-04-16","objectID":"/posts/php%E4%BA%8C-php%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:0:12","tags":["PHP","入门"],"title":"PHP(二)-php基础语法","uri":"/posts/php%E4%BA%8C-php%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["PHP","入门"],"content":"运算符 算术运算符 符号 + - * / % 在php中只是针对数字进行运算 如果运算符两边有不是数字的数据，就会自动转换为数字 其中取余运算%，它只会针对整数进行运算如果不是，会自动截取为整数。 自增自减运算符 常规: 对数字进行自加1或自减1. 字符串: 只能自增，且自增的效果就是 下一个字符 ，只能针对字母或数字进行自加。 布尔值递增递减无效 null递减无效，递增结果为1 逻辑运算符 php中的\u0026\u0026 || 支持短路现象，相当于java中的 单\u0026 和双\u0026 的区别，如果判断条件1可以得出结论，后面的判断条件不再执行。 字符串运算符 符号为.，也演出了另一个.= 如果两边不是字符串，就会自动转换为字符串在连接。 ","date":"2016-04-16","objectID":"/posts/php%E4%BA%8C-php%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:0:13","tags":["PHP","入门"],"title":"PHP(二)-php基础语法","uri":"/posts/php%E4%BA%8C-php%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["PHP","入门"],"content":"位运算符 基础规定 1 位是什么？ 就是二进制数字的每一个 位，一个整数数字，有32个位构成。 2 位运算符仅仅针对整数进行的运算符。 3.位运算符有如下几个 \u0026：按位与 |：按位或 ~：按位非 按位取反 ^：按位异或 4.位运算符的基本语法规则。 按位与基本规则： * 1 \u0026 1 --\u003e 1 * 1 \u0026 0 --\u003e 0 * 0 \u0026 1 --\u003e 0 * 0 \u0026 0 --\u003e 0 按位或基本规则： * 1 | 1 --\u003e 1 * 1 | 0 --\u003e 1 * 0 | 1 --\u003e 1 * 0 | 0 --\u003e 0 按位非基本规则： * ~ 1 --\u003e 1 * ~ 0 --\u003e 1 按位异或基本规则： * 1 ^ 1 --\u003e 0 * 1 ^ 0 --\u003e 1 * 0 ^ 1 --\u003e 1 * 0 ^ 0 --\u003e 0 原码，反码，补码 原码：是一个二进制数字，从数学观念上来表达的形式，其中，我们规定: 一个数字的最左边是符号位，0表示整数，1表示负数。 反码：整数的反码不变，负数的反码：符号位不变，其他位取反。 补码：整数的补码就是本身，负数补码：符号位不变，其他位取反后+1—-既反码+1 灯泡判断法 status 所有灯泡状态 d1，d2……dx 每个灯泡 1. 查看某个灯泡是否打开: (status \u0026 d1）是否大于0 2. 打开某个灯泡: status | d1 3. 关闭某个灯泡: status \u0026 (~d1) 数组运算符 +：数组联合，也可以理解为数组串联。将游标的数组项合并到左边数组的后面，得到一个新数组，如果有重复键，则结果以左边的为准。 ==：如果两个数组具有相同的键名和键值(可以顺序不同类型不同)，则返回true。 ===：如果两个数组具有相同的键名和键值并且顺序类型都一样，则返回true。 ","date":"2016-04-16","objectID":"/posts/php%E4%BA%8C-php%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:0:14","tags":["PHP","入门"],"title":"PHP(二)-php基础语法","uri":"/posts/php%E4%BA%8C-php%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["PHP","入门"],"content":"错误控制运算符@ 通常就用在一个地方 $link = @mysql_connect(\"数据库服务器地址\",\"用户名\",\"密码\"); 作用是:如果该链接数据的语句失败，则屏蔽该失败的错误提示。 ","date":"2016-04-16","objectID":"/posts/php%E4%BA%8C-php%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:0:15","tags":["PHP","入门"],"title":"PHP(二)-php基础语法","uri":"/posts/php%E4%BA%8C-php%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["PHP","入门"],"content":"循环语句特殊使用 php中，break和continue有扩展的使用功能，可以中断更多层的循环。break 正整数n; 循环的层，值得是从当前中断语句(break，continue)算起，往代码的外部属循环个数，就是层数。 for(){ //循环1 for(){ //循环2 for(){ //循环3 break 2; //会中断2：就是指中断2层 //循环3为第一层，循环2为第二层，循环3为第三层。 } } } ","date":"2016-04-16","objectID":"/posts/php%E4%BA%8C-php%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:0:16","tags":["PHP","入门"],"title":"PHP(二)-php基础语法","uri":"/posts/php%E4%BA%8C-php%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["PHP","入门"],"content":"控制脚本执行顺序 die(字符串)/exit(字符串) 输出该字符串后，立即停止php的执行!既后续程序不再执行，包括后续的其他所有php和html代码部分。 exit是die的同义词。也可以不加字符串，而是直接停止。 sleep($n) 让程序停止运行指定的秒数。然后等待过了那个时间后，就继续运行。 ","date":"2016-04-16","objectID":"/posts/php%E4%BA%8C-php%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/:0:17","tags":["PHP","入门"],"title":"PHP(二)-php基础语法","uri":"/posts/php%E4%BA%8C-php%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"},{"categories":["PHP","入门"],"content":" ","date":"2016-04-15","objectID":"/posts/php%E4%B8%80-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","tags":["PHP","入门"],"title":"PHP(一)-环境搭建","uri":"/posts/php%E4%B8%80-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["PHP","入门"],"content":"自学小笔记 ok 由于是练习笔记,其下过程显得安装磕磕绊绊. 我直接放入一个看到一个还不错的简易安装mac下Web服务教程查看详细教程 解决mysql在mac下安装问题跳转 ","date":"2016-04-15","objectID":"/posts/php%E4%B8%80-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:0:0","tags":["PHP","入门"],"title":"PHP(一)-环境搭建","uri":"/posts/php%E4%B8%80-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["PHP","入门"],"content":"PHP 缩写：personal Home Page ==\u003e HypeText Preprocessor. 历史 1995 PHP/FI Rasmus Lorderf,Presonal Home Page. 1997PHP/FI2.0, 1998PHP3, 2000PHP4, 2005PHP5 php的应用领域 web服务器脚本：主要作用 运行php文件: php -f \"php文件路径\"。 运行php代码: php -r \"php脚本代码\"。 php作为一门语言，本身可以是一个纯绿色的“文件夹”–称之为“php语言包” php网页运行原理 mac下自带apache2，打开终端:open /etc 可以看到有apache2文件夹。 默认部署路径 使用Finder选择前往，输入/资源库/WebServer/Documents/. apache2下的httpd.conf文件是进行配置的。 DocumentRoot 是部署路径(如果403，对Directory进行Options None AllowOverride None Order deny,allow allow from all 修改) listen 是端口号 关联php和apache 找到apache的配置文件httpd.conf.#LoadModule php5_module...去掉前面的#注释。进行装载php模块。 重启apache即可 sudo apachectl restart ","date":"2016-04-15","objectID":"/posts/php%E4%B8%80-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:0:1","tags":["PHP","入门"],"title":"PHP(一)-环境搭建","uri":"/posts/php%E4%B8%80-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["PHP","入门"],"content":"获取时间 获取时间 .date(\"Y-m-d H-i-s\"); 如果不配置字符集会出现乱码，配置和HTML一样。 直接获取的不是北京时间，需要修改php.ini，timezone字段打开，去掉;,追加PRC-中国。并且需要让apache知道php.ini的位置。PHPIniDir \"/usr/local/etc/php/5.6/php.ini\" ","date":"2016-04-15","objectID":"/posts/php%E4%B8%80-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:0:2","tags":["PHP","入门"],"title":"PHP(一)-环境搭建","uri":"/posts/php%E4%B8%80-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["PHP","入门"],"content":"PHP连接数据库配置 mysql作为一个php的模块 应该首先配置。 1.在php.ini文件中，设定模块所在的路径(查找关键字extension_dir);默认注释，去掉注释。 2.继续这个文件 解放并初始化mysql模块(查找关键字php_mysql.dll,去掉;) 3.mac下，必须指定php.ini中default_socket 指定的路径。指定为/tmp/mysql.sock,要修改的有3个。 ","date":"2016-04-15","objectID":"/posts/php%E4%B8%80-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:0:3","tags":["PHP","入门"],"title":"PHP(一)-环境搭建","uri":"/posts/php%E4%B8%80-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["PHP","入门"],"content":"主机(站点)配置 单站点配置项 默认情况下，apache安装成，就默认配置好了一个站点，该站点的实际位置在apache安装位置/htdocs. 一个站点的两个核心信息为:1.主机名(服务器名/站点名)serverName 2.站点位置(站点目录路径). 端口监听: 在apache的httpd.conf文件中的 Listen字段。(支持多个listen监听)。 如果只写端口，表示本机的多个ip都使用该端口。否则表示只负责该ip端口。 设置主机的物理路径 DocumentRoot – 实际物理路径。(站点就是文件夹，我可以随便指定站点)。 在httpd.cong中站点是可以更改的。 \u003cDirectory \"/xxx/xxxx\"\u003e Options Indexes Order Deny,Allow Allow from all \u003c/Directory\u003e 目录访问权限 一个站点，就是一个目录，每个目录都给其设置“访问权限”,语法如下。 options indexes:设置当一个请求中没有给定请求的文件名又没有默认网页(首页)的时候,显示文件列表。 Order Deny，Allow: 设置权限控制的先后顺序,只有两种:Deny,allow(先拒绝,后允许),Allow,deny(先允许后拒绝) Dyny from 拒绝名单 用来设定要拒绝访问的来源地址或服务器，几乎没有意义。 DirectoryIndex 设置该文件夹下的默认网页，可以设置多个，用于请求中不带文件名的时候自动使用。 目录访问权限中的“分布式权限” 对于某个目录的访问权限，我们在apache中使用Directory来设定，单可能不够方便。 apache配置修改，必须重启。 某个站点中的夏季目录的访问权限，不方便单独设置。 这种，可以成为\"集中式权限\"; 分布式权限，就是针对某个网站的任何一个下级目录，都可以单独去设置其访问权限，并且可以不重启apache就生效。 方法–\u003e 在该站点对应目录权限的DIrectory配置中添加一条：AllowOverride all，表示当前目录允许’分布式‘权限配置。 在该目录下的任何子目录中，创建一个特殊的文件(.htaccess ),在该文件中写所需要的\"权限内容\"(内容几乎和Directory写法一致)，内容为: Deny from all Allow form 192.168.3.4 多站点的配置 在apache的主配置文件httpd.conf中，“放行”多站点虚拟主机配置文件项(关键字:vhosts),如果放行了，httpd-vhosts.conf设置里面的DocumentRoot路径的访问优先级最高，当配置一个时候所有的默认的访问资源路径就是VirtualHost *:80标签的配置。 在httpd-vhosts.conf文件中，设定希望提供多站点服务的ip地址和端口号，通常默认就是:*:80,其中*代表所有的ip，默认其实apache安装好之后就设置好了，无需手动设置(NameVirtualHost *:80 // apache2.4不需要加). 然后一个站点一个站点加上。形式如下 \u003cvirtualhost *:80\u003e #这里设置站点1的各项信息 ServerName www.test.com #设定该站点的别名，即通过一下域名也可以访问， ServerAlias map.php.com tv.php.com DocumentRoot \"dirSrc\" \u003cDirectory \"dirSrc\"\u003e ... \u003c/Directory\u003e \u003c/virtualhost\u003e \u003cvirtualhost *:80\u003e #这里设置站点2的各项信息 \u003c/virtualhost\u003e ... 注意： 1.先把httpd-vhosts.conf文件中的2个初始安装生成的站点，删除。(可用命令$ httpd -t来检测语法)。 2.每个站点的设置项，主要就3个:ServerName,DocumentRoot,\u003cDirectory\u003e...\u003c/Directory\u003e。 3.在多站点配置中，第一个站点被称为\"默认站点\",如果某个请求的域名无法跟任何一个站点匹配，就会当做请求的默认站点去处理(应答)。 4.一旦实现了多站点配置，则最初安装成功时的\"默认站点\"就失效了。 *此处apache2.2 和2.4略有不同，在2.4 访问权限使用了新的字段替换之前的如下 \u003cDirectory \"/Library/WebServer/Documents\"\u003e #2.4之前 Order allow,deny Allow From all #2.4采用了require开确认 Require all granted #允许客户端所有请求 Require all denied #拒绝客户端所有请求 Require ip 192.168.1.0/24 #允许192.168.1.0/24网络主机访问。 \u003c/Directory\u003e 目录别名(虚拟目录)的设置 某个站点www.abc.com所对应文件夹下有一个目录为d1，则可以这样访问目录:www.abc.com/d1 d1就称为\"真实目录\" 虚拟目录:该站点下不存在某目录名,但却可以使用同样的语法形式，比如：www.abc.com/d2 //假设该站点目录下根本就没有d2这个目录，此时却可以访问。 实现这种技术，这就是所谓\"目录别名\"(虚拟目录)的设置，如下： 设置目录别名的名字和真实的物理路径 并为其设置目录的访问权限 #设置一个虚拟目录(目录别名) Alias /soft \"/Users/suzeyu/demo\" \u003cDirectory \"\"\u003e Options Indexes require all granted \u003c/Directory\u003e ","date":"2016-04-15","objectID":"/posts/php%E4%B8%80-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/:0:4","tags":["PHP","入门"],"title":"PHP(一)-环境搭建","uri":"/posts/php%E4%B8%80-%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"},{"categories":["JavaScript","入门"],"content":" ","date":"2016-04-14","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%94-js-dom/","tags":["JavaScript","入门"],"title":"基础篇(五)-JS-DOM","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%94-js-dom/"},{"categories":["JavaScript","入门"],"content":"自学小笔记 ","date":"2016-04-14","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%94-js-dom/:0:0","tags":["JavaScript","入门"],"title":"基础篇(五)-JS-DOM","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%94-js-dom/"},{"categories":["JavaScript","入门"],"content":"DOM Document Object Model 文档对象模型 DOM主要提供了访问和操作HTML标记的方式。 HTML标记:图片标记、表格标记、表单标记、body、等。 BOM和DOM不是js的内容。他们是W3C指点的规范。但是，BOM和DOM在浏览器中以对象的形式得以实现。 BOM和DOM都是由一组对象构成。 W3C是制作互联网标准的一个国际化的组织，如XHTML、CSS、JavaScript、AJAX等。 ","date":"2016-04-14","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%94-js-dom/:0:1","tags":["JavaScript","入门"],"title":"基础篇(五)-JS-DOM","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%94-js-dom/"},{"categories":["JavaScript","入门"],"content":"DOM的官方定义 DOM ,Document Object Model,文档对象模型。我们可以把网页中的所有元素看成是对象。 DOM是W3C指定的网页标准或准则，而这个标准，在浏览器中，以 对象 的形式得以实现。 DOM的官方定义: DOM可以使用脚本，动态的访问或操作，网页的内容、网页外观、网页结构。 ","date":"2016-04-14","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%94-js-dom/:0:2","tags":["JavaScript","入门"],"title":"基础篇(五)-JS-DOM","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%94-js-dom/"},{"categories":["JavaScript","入门"],"content":"DOM的分类 核心DOM：提供了同时操作HTML文档和XML文档的公共的属性和方法。 HTML DOM: 针对HTML文档提供的专用的属性方法。 XML DOM: 针对XML文档提供的专用的属性和方法。 CSS DOM: 提供了操作CSS的属性和方法。 EventDOM: 时间对象模型。如：onclick、onload等。 ","date":"2016-04-14","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%94-js-dom/:0:3","tags":["JavaScript","入门"],"title":"基础篇(五)-JS-DOM","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%94-js-dom/"},{"categories":["JavaScript","入门"],"content":"HTML节点树 节点关系 根节点，一个HTML文档只有一个根，他就是HTML节点。 子节点，某一个节点的下级节点。 父节点：某一个节点的上级节点。 兄弟节点: 同属于一个父节点。 DOM中节点类型 document文档节点，代表整个网页，不代表任何HTML标记。但他是html节点的父节点。 element父元素节点，指任何HTML标记，每一个HTMl标记就称为一个元素节点。它可以有文本节点和属性节点。 attribute属性节点。值HTML标记的属性。 text节点。是节点树的最底层节点。 核心DOM中的公共的属性和方法 提示: 核心DOM中查找节点（标记）， 都是从根节点开始的(html节点)。 1.节点访问 nodeName:节点名称。 nodeValue：节点的值。只有文本节点才有值，元素节点没有值。只能添加纯文本，不能设置css样式等。 firstChild:第一个子节点。 lastChild:最后一个子节点。 childNodes:子节点列表，是一个数组。 parentNode: 父节点。 查找\u003chtml\u003e标记的方法 document.firstChild document.documentElement.client 查找标记的方法 document.firstChild.lastChild document.body 为什么document.body.firstCHild找不到\u003ctable\u003e节点？ 核心DOM的属性和方法，主要是针对HTML4.0开发的。 在Firefox下，会把空格或换行，当成文本节点。 HTML4.0是没有DTD类型定义的。 2.节点的属性操作 setAttribute(name,value):给某个节点添加属性。 getAttribute(name):获取某个节点属性的值。 removeAttribute(name):删除某个节点的属性。 3.节点的创建 createElement(tagName):创建一个指定的HTML标记。tagname:不带尖括号的标记名。 appendChild(elementObj): 将创建的节点，追加到某个父节点下。 removeChild(elementObj):删除节点 ","date":"2016-04-14","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%94-js-dom/:0:4","tags":["JavaScript","入门"],"title":"基础篇(五)-JS-DOM","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%94-js-dom/"},{"categories":["JavaScript","入门"],"content":"HTML DOM简介和新特性 1.简介 如果在核心DOM中，网页节点层级很深时，访问这个节点时将会十分的麻烦。那么HTMLDOM重就提供了通过id直接找到节点的方法，而不用再HTML根节点开始。 HTMLDOM的新特性 每一个HTML标记，都队形一个元素对象。 每一个HTML标记的属性，与对应的元素对象的属性，–对应。 HTML DOM访问HTML元素的方法 1.getElementById() 查找网页中指定id的元素对象。 var obj = document.getElementById(id) id是指网页中标记的id属性的值。 返回一个元素对象。 2.getElementsByTagName(tagName) 查找指定的HTML标记，返回一个数组。 var arrObj = parentNode.getElementsByTagName(tagName) tagName是要查找的标记形成，不带尖括号。 返回一个数组。如果只要一个节点，也返回一个数组。 元素的属性 名称 说明 tagName 标签名称，与核心DOM中nodeName一样 className css类的名称 id 同HTML标记id属性一样 title 同HTML标记title属性一样 style 同HTML标记style属性一样 innerHTML 包含HTML标记中的所有的内容，包括HTML标记等。比nodeValue强大 offsetWidth 元素对象的可见宽度，不带px offsetHeight 元素对象的可见高度，不带px scrollHeight 元素对象的总高度，包括滚动条内容，不带px scrollWidth 元素对象的总宽度，不带px scrollTop 指内容向上滚动上去了多少距离(有滚动条才有效)，不带px scrollLeft 指内容向左滚动上去了多少距离(有滚动条才有效)，不带px onscroll:当拖动滚动条的时候触发。 ","date":"2016-04-14","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%94-js-dom/:0:5","tags":["JavaScript","入门"],"title":"基础篇(五)-JS-DOM","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%94-js-dom/"},{"categories":["JavaScript","入门"],"content":"CSS DOM动态样式 使用JS操作CSS中的个属性。JS只能操作或者修改行内样式。对于类样式，通过className来赋值。 style对象 每个HTML标记，都有一个style属性。但这个style属性又是一个style对象。 style对象的属性，与CSS中的属性，一一对应。所有style对象用来代替CSS。 如: imagObj.style.border = \"1px solid red\"; style对象属性与CSS属性的转换 1.如果是一个单词，style对象属性，与CSS属性一样。 2.如果是多个单词，第一个单词全小写，后面每个单词首字母大写，并去掉中划线。 divObj.style.backgroundColor = \"red\"; divObj.style.backgroundImage = \"url(images/bg.gif)\"; divObj.style.fontSize = \"18px\"; ","date":"2016-04-14","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%94-js-dom/:0:6","tags":["JavaScript","入门"],"title":"基础篇(五)-JS-DOM","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%94-js-dom/"},{"categories":["JavaScript","入门"],"content":"Event DOM : 事件DOM 事件简介 时间主要实现“用户与网页的交互”。 当事件发生时，去执行JS功能代码。 常用事件 onload：当网页加载完成时。 onclick：当点击时，所有标记都适用。 onscrool：当拖动滚动条时。 onmouseover：当鼠标放上时。 onmouseout：当鼠标移开时。 onsubmit：当提交表单时。 onreset：当重置表单时。 onfocus：当获得焦点时，把光标定位到文本框中。 onblur：当失去焦点时，把光标从文本框中移开。 onchange：当下拉列表内容改变时。用在下拉列表，上传文件。 onselect：当选中文本时 onresize：当改变窗口大小事，发生的事件。 …. 3.事件句柄属性 HTML标记，都有相应的事件属性。 每一个HTML标记，都对应一个元素对象。元素对象也具有相应的事件属性。但是匀速对象的事件属性应该全是小写。 事件属性后面调用的一般是JS函数，通过JS函数来完成相应的功能。 ","date":"2016-04-14","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%94-js-dom/:0:7","tags":["JavaScript","入门"],"title":"基础篇(五)-JS-DOM","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%94-js-dom/"},{"categories":["JavaScript","入门"],"content":"Event对象简介 当事件发生时，向调用函数，传递一个event参数，这个event参数是一个事件对象。 该event对象中记录了当前事件发生的环境信息。如：单击时的坐标，事件类型等。 注意这个event对象是短暂存在的，新的时间发生，新的event对象产生，原来的event对象消失。 ","date":"2016-04-14","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%94-js-dom/:0:8","tags":["JavaScript","入门"],"title":"基础篇(五)-JS-DOM","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%94-js-dom/"},{"categories":["JavaScript","入门"],"content":"DOM中的Event对象 DOM中引入Event对象(DOM浏览器就是标准浏览器) 1.通过HTML标记的时间属性来传递event对象。 在DOM中，event对象是作为时间调用函数时的参数，传递给给函数。 该event参数，是系统固定写法，全小写，不能加引号，他就是event对象参数。 2.DOM中Event对象属性 type:当前的时间类型。 clientX 和clientY:距离窗口左边和上边的距离。 pageX 和 pageY:距离网页左边和上边的距离。 screenX 和 screenY:距离屏幕左边和上边的距离。 IE中的event对象 IE中的event对象，是window对象的一个属性，可以通过window对象调用，而不需要传值。如：window.event. IE中Event对象属性。 type，clientX，clentY，x，y，screenX，screenY。同上。 简易购物车 随机生成小图片 ","date":"2016-04-14","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%94-js-dom/:0:9","tags":["JavaScript","入门"],"title":"基础篇(五)-JS-DOM","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%94-js-dom/"},{"categories":["JavaScript","入门"],"content":" ","date":"2016-04-13","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E5%9B%9B-js-bom/","tags":["JavaScript","入门"],"title":"基础篇(四)-JS-BOM","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E5%9B%9B-js-bom/"},{"categories":["JavaScript","入门"],"content":"自学小笔记 ","date":"2016-04-13","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E5%9B%9B-js-bom/:0:0","tags":["JavaScript","入门"],"title":"基础篇(四)-JS-BOM","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E5%9B%9B-js-bom/"},{"categories":["JavaScript","入门"],"content":"BOM Browser Object Model 浏览器对象模型 BOM主要提供了访问和操作浏览器各组件的方式。 浏览器组件：window(浏览器窗口)、location(地址栏)、history(浏览历史)、screen(显示器屏幕)、navigator(浏览器软件)、document(网页) window是最顶层的。其余的组件都是window的子组件。 那么各个之间的对象有层级关系，该如何访问呢？ window.document.write(\"OK\"); window.document.body.bgColor=\"#ff0000\"; window对象是所有其他对象的最顶层对象，因此可以省略。 document.write(\"ok\"); document.body.bgColor = \"#ff0000\"; alert(\"OK\"); 循环遍历window对象的所有属性 js可以使用for in循环。 for(name|index in obj|arr){ } //只能循环数组的下标，或对象的属性 //如果循环数组的话，每次循环将取下角标 ,如果数组中的值为undefined则不会循环。 //如果循环对象的话，每次循环取对象属性 windown常用属性 name:指浏览器窗口的名字或框架的名字。这个名字是给\u003ca\u003e标记的target属性用的 设置窗口的名字：window.name = \"newWIN\"; 获取窗口的名字：window.name; top:代表最顶层窗口。如window.top parent:代表父级窗口，主要用于框架。 self:代表当前窗口，主要用于框架中。 innerWidth():指浏览器窗口的内宽(不含菜单栏、工具栏、地址栏、状态栏),该属性Firefox支持。 在IE下，使用document.documentElement.clientWidth. innerHeight():至浏览器窗口的内高不含菜单栏、工具栏、地址栏、状态栏),该属性Firefox支持。 在IE下，使用document.documentElement.clientWidth. document.documentElement //指的是\u003chtml\u003e标记对象。 document.body //就是\u003cbody\u003e标记对象。 alert():弹出一个警告对话框。 prompt():弹出一个输入对话框。 confirm():弹出一个确认对话框。点击确认返回true。 close():关闭窗口。 print():打印窗口。 open():打开一个新的浏览器窗口。 语法：var winObj = window.open(url,name,options); url: 准备在新窗口中显示那个文件。url可以为空字符串，表示显示一个空的页面。 name: 新窗口的名字，该名字给\u003ca\u003e标记的target属性来用。 options: 窗口的规格。有width,height,left,top, menubar(显示菜单栏? 取值:yes/no),toolbar(显示工具栏? 取值:yes/no),location(显示地址栏? 取值:yes/no),status(显示状态栏? 取值:yes/no) var winObj = window.open(mUrl,mName,\"width=400,height=300\"); onload 事件: 当网页加载完成，指\u003cbody\u003e标记的所有内容全部加载完成，才触发该事件。通过onload事件属性，去调用JS的函数，onLoad属性只有body标记才有。 setTimeout() 功能: 设置一个延时器。只执行一次！！ 语法:var timer = window.setTimeout(code,millisec); 参数: code: 是任何合法的JS代码，一般情况下是JS函数，该函数要放在引号中。 window.setTimeout(\"close()\",2000); window.setTimeout(init,2000); //传函数地址，因此不需要加括号。如果加括号，是讲函数的执行结果传到方法中。 返回值: 返回一个延时器的id变量，这个id变量给clearTimeout()用来清除。 clearTimeout() 功能:清除延时器id变量 定时器方法 setInterval(); 功能: 设置一个定时器，定时器，重复不断的执行JS代码(周期性)。 语法: var timer = window.setInterval(code,milliesc); 参数: code: 是任何合法的JS代码，一般情况下是JS函数，该函数要放在引号中。 window.setInterval(\"init()\",2000); window.setInterval(init,2000); //传函数地址，因此不需要加括号。如果加括号，是将函数的执行结果传到方法中。 返回值: 一个定时器的id变量，这个id变量给clearInterval()用来清除。 clearInter val()清除定时器的id变量 定时器总是调用其他函数，延时器总是调用自己所在的函数 JS中函数传递时如果带()说明传递函数的结果，如果不带()那么就传递空间地址值 ","date":"2016-04-13","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E5%9B%9B-js-bom/:0:1","tags":["JavaScript","入门"],"title":"基础篇(四)-JS-BOM","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E5%9B%9B-js-bom/"},{"categories":["JavaScript","入门"],"content":"SCREEN 屏幕对象 width: 屏幕的宽度，只读属性 height: 屏幕的高度，只读属性 availWidth: 屏幕的有效宽度，不含任务栏 availHeight: 屏幕的有效高度，不含任务栏 ","date":"2016-04-13","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E5%9B%9B-js-bom/:0:2","tags":["JavaScript","入门"],"title":"基础篇(四)-JS-BOM","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E5%9B%9B-js-bom/"},{"categories":["JavaScript","入门"],"content":"navigator对象（不重要） appName：浏览器软件名称，Microsoft Internet Explorer；Netscape。 appVersion： systemLanguage： userLanguage： platform： ","date":"2016-04-13","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E5%9B%9B-js-bom/:0:3","tags":["JavaScript","入门"],"title":"基础篇(四)-JS-BOM","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E5%9B%9B-js-bom/"},{"categories":["JavaScript","入门"],"content":"Location地址栏对象 href: 获取地址栏中的完整地址。可以实现JS网页跳转。location.href=\"rul\"; host: 主机名 hostname: 主机名 pathname: 文件路径及文件名 search: 查询字符串 protocol:协议 http:// ftp:// hash:锚点名称 reload([true]): 刷新网页 true表示强制刷新。 ","date":"2016-04-13","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E5%9B%9B-js-bom/:0:4","tags":["JavaScript","入门"],"title":"基础篇(四)-JS-BOM","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E5%9B%9B-js-bom/"},{"categories":["JavaScript","入门"],"content":"history对象 length: 历史记录的个数 go(n):可以实现 前进 和后退。n为0刷新网页，-1后退，1前进一步，3前进3步 forward():相当于浏览器的“前进”按钮 back():相当于浏览器的后退按钮 ","date":"2016-04-13","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E5%9B%9B-js-bom/:0:5","tags":["JavaScript","入门"],"title":"基础篇(四)-JS-BOM","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E5%9B%9B-js-bom/"},{"categories":["JavaScript","入门"],"content":" ","date":"2016-04-12","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B8%89-js%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8/","tags":["JavaScript","入门"],"title":"基础篇(三)-JS对象使用","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B8%89-js%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8/"},{"categories":["JavaScript","入门"],"content":"自学小笔记 ","date":"2016-04-12","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B8%89-js%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8/:0:0","tags":["JavaScript","入门"],"title":"基础篇(三)-JS对象使用","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B8%89-js%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8/"},{"categories":["JavaScript","入门"],"content":"JS内置对象 String对象:字符串对象，提供了对字符串进行操作的属性和方法。 方法名 说明 length 获取字符换长度 toLowerCase() 将str转为小写 toUpperCase() 将str转为大写 charAt(index) 指定下标位置的字符，没有找到返回空字符串 indexOf(strsub) 某一个字字符串所在的下标值，没有则返回-1 lastIndexOf() 同上，但是从右往左查找。 substr(startIndex[,length]) 从startIndex下标起，返回length个字符 substring(startIndex[,endIndex]) 返回从startIndex下标起到endIndex结束之间的所有字符 split(str) 按照传入的字符切割原字符串，返回一个数组 Array对象:数组对象，提供了数组操作方面的属性和方法。 方法名 说明 lenght 返回数组的长度 join(连接号) 将一个数组，用指定的连接号连接成一个字符串 reverse() 将数组的元素反转 shift() 删除数组中第一个元素，返回删除的值,并将长度减1 pop() 删除数组的最后一个元素,返回删除的值,并将长度减1 unshift(boject[,object…]) 往数组前面添加一个或读个数组元素，长度要改变 push([,object…]) 往数组结尾添加一个或多个数组元素，长度改变 Date对象:日期时间对象，可以获取系统的日期时间信息。 Date对象的使用，必须使用new关键字来创建实例对象。 1.创建当前日期对象的实例，不带任何参数。 var today = new Date(); 2.指定毫秒值（参数为时间戳） 时间戳:是指某一个时间距离1970年1月1日0时0分0秒，过去了多少毫秒值。 var timer = new Date(99999); 3.指定一个字符串日期时间信息(参数是一个时间字符串) var timer = new Date(\"2016/4/6 12:00:00\"); 4.指定多个数值参数 var timer = new Date（2015,4,20,19,29,59）; //顺序为: 年、月、日、时、分、秒。 年月日时必须的。 方法名 说明 getFullYear() 获取四位年份 getMonth() 获取月份,取值0-11 getDate() 获取几号,取值1-31 getHours() 获取小时数 getMinutes() 分钟数 getSeconds() 获取秒 getMilliseconds() 获取毫秒 getDay 获取星期 getTime() 毫秒值 距离1970的毫秒值 Boolean对象:布尔对象，一个布尔变量就是一个布尔对象(没有可用的属性和方法) Number对象:数值对象。一个数值变量就是一个数值对象。 toFiexd(); 功能: 将一个数值转成字符串，并进行四舍五入，保留指定位数的小数。 语法: numObj.toFixed(n) 参数: n就是要保留的小数位数。 Math对象:数学对象，提供了数学方面运算的属性和方法 Math对象会一个静态对象，可以直接使用。 方法名 说明 PI 圆周率 abs() 绝对值。如:Math.abs(-9)=9 ceil() 向上取整(整数加1，小数去掉)。 floor() 向下取证(直接去掉小数) round() 四舍五入 pow(x,y) 求x的y次方。 sqrt() 求平方根 random() 返回一个0到1之间的随机小数 ","date":"2016-04-12","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B8%89-js%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8/:0:1","tags":["JavaScript","入门"],"title":"基础篇(三)-JS对象使用","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B8%89-js%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8/"},{"categories":["JavaScript","入门"],"content":"form对象 一个\u003cform\u003e标记，就是一个\u003cform\u003e对象。 1.form对象属性 name：表单名称，让js来控制表单。 action：表单的数据处理程序（PHP文件）。 method：表单的提交方式，取值：GET、POST。 enctype：表单数据的编码方式。 2.form对象的方法 submit(): 提交表单，与功能一样。 reset():重置表单，与重置按钮功能一样。 3.form对象的事件 onSubmit：当单机提交按钮时发生，并数据发往服务器之前。主要用来表单验证。 onreset：当单机重置按钮时发生。 获取表单元素的方法 通过网页元素的id来获取对象。document.getElementById(id). 通过HTML标签名来获取对象。parentNode.getElementsByTagName(tagName)。 通过name属性来获取表单元素对象。表单中所有元素的起点必须是document对象。如：document.form(表单name值).username(表单元素name值)。 事件返回值 事件的返回值，会影响对象的默认动作。 如果事件返回false，则阻止默认动作的执行；如果事件返回true或空，则默认动作继续执行。例如\u003ca href=\"www.baidu.com\" onclick=\"return false\"\u003e 连接默认跳转会失效。 提交和验证方法总结 1.使用submit按钮，结合onsubmit事件来实现(最常用). 2.submit按钮，结合onclick事件，实现表单的验证和提交。 3.button按钮，结合submit()方法，实现表单验证提交。 input对象 一个\u003cinput\u003e标记，就是一个input对象。 1.input对象的属性(以type=text为例) name：表单元素名称。 value：表单元素的值，用户输入的内容，可以通过该属性来获取。 size：表单的长度。 maxlength：表单元素的最大长度(最多可输的字符数)。 disable：禁用元素。 readonly：只读属性。 2.input对象方法 focus():获得焦点的方法（定位光标）。 blur():失去焦点的方法（移走光标）。 select():选中文本的方法。 3.input对象的事件 onfocus:当获取焦点时 onblur:当失去焦点时 select对象 select对象属性 options[]: 设置或返回下拉列表中\u003coption\u003e标记构成的数组。 selectedIndex:设置或选中指定\u003coption\u003e的索引号。 length:指定下拉列表中\u003coption\u003e标记的个数。 name:元素名称。 option对象属性 text：指\u003coption\u003e和\u003c/option\u003e之间的文本 value：指\u003coption\u003e标记的属性。 简单小实例 ","date":"2016-04-12","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B8%89-js%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8/:0:2","tags":["JavaScript","入门"],"title":"基础篇(三)-JS对象使用","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B8%89-js%E5%AF%B9%E8%B1%A1%E4%BD%BF%E7%94%A8/"},{"categories":["JavaScript","入门"],"content":"  ","date":"2016-04-11","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%8C-js%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/","tags":["JavaScript","入门"],"title":"基础篇(二)-JS基本语法","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%8C-js%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["JavaScript","入门"],"content":"自学小笔记 ","date":"2016-04-11","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%8C-js%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:0:0","tags":["JavaScript","入门"],"title":"基础篇(二)-JS基本语法","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%8C-js%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["JavaScript","入门"],"content":"JS程序的基本语法 JS是区分大小写的。如:Name和name是两个变量。 JS中每一条语句，以分号结束。这个分号不是必须的，为了向PHP兼容，最好加上分号。 ","date":"2016-04-11","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%8C-js%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:0:1","tags":["JavaScript","入门"],"title":"基础篇(二)-JS基本语法","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%8C-js%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["JavaScript","入门"],"content":"变量的类型–就是数据的类型 变量的数据类型：数值型、字符型、布尔型、未定义型、空型、数组、对象、函数。 变量的数据类型，分两大类 基本数据类型：数值型、字符型、布尔型、未定义型、空型。很显著的特点：一个变量只能存一个值。 复合数据类型：数组、对象、函数。显著的特点：一个变量名，可能存多个值。 数值型：变量能进行数学运算的 数值型包括：整形、浮点型、NaN（not a number）。 数值型中还有一个很特殊的值NaN。不是一个数字。当将其他数据类型转成数值型，转不过去，但程序又不能报错，这时将返回一个NaN的值。 字符型：用单引号或双引号引起来的字符串。 单引号和双引号之间可以相互嵌套。 单引号内只能嵌套双引号 双引号内只能嵌套单引号 如果想在双引号内，在嵌套双引号，里面的双引号需要进行转义。 js中的转义字符是反斜杠\\. 常用的转义字符有\\',\\\",\\\\,\\r,\\n等。 当浏览器遇到反斜杠的时，将会对其后的一个字符进行特殊对待，当成普通字符来对待，比如123abc等。 弹窗中的换行只能用\\n来实现；而不能使用\u003cbr\u003e，只有在\u003cbody\u003e中\u003cbr\u003e才会解析成换行符。 未定义型 当一个变量定义，但未赋值时，将返回未定义型，未定义型的值只有一个undefined。 当一个对象的属性不存在，也返回未定义型undefined。 空型 当一个对象不存在是，将返回空型，空型的值只有一个null。 也可以理解为：是一个对象的占位符。如果想清除一个变量的值，可以附一个null的值。 ","date":"2016-04-11","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%8C-js%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:0:2","tags":["JavaScript","入门"],"title":"基础篇(二)-JS基本语法","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%8C-js%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["JavaScript","入门"],"content":"变量类型的转换 js中其他类型自动转换成布尔值 要被转换的类型变量 转换后的结果 var a = “abc” true var a = “123” true var a = \"\" false var a = 100 true var a = 0 false var a = NaN true var a = undefined true var a = null true 布尔值的转换 使用Boolean()全局函数，强制转成布尔型。 var a = 100; var result = Boolean(a); 字符型的转换 使用String()全局函数，强制转成字符型。 var a = 100; var result = String(a); 其他类型转成数值型 使用Number() 全局函数，进行强制转换。 如果参数是Date对象，Number()返回1970年1月1日至今的毫秒值。 如果对象的值无法转换为数字。那么返回NaN。 注意:全局函数或系统函数，是JS内置的函数，名称或大小写必须一致。 要被转换的类型变量 转换后的结果 var a = true 1 var a = false 0 var a = “120px” NaN var a = “100” 100 var a = \"\" 0 var a = NaN true var a = undefined NaN var a = null 0 判断变量的数据类型:typeof() 使用一元运算符typeof(),可以测试一个变量的类型。 typeof()测试的结果是一个类型字符串。 typeof()的结果字符串有几种情况:“string”,“number”,“boolean”,“undefined”,“object”,“function”。 typeof()返回的object类型，有几种情况: null、对象、数组。 函数和方法的区别 Boolean(a) //函数是可以独立使用的。 document.write(a) //方法不能独立使用，方法是必须要属于哪一个对象。 ","date":"2016-04-11","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%8C-js%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:0:3","tags":["JavaScript","入门"],"title":"基础篇(二)-JS基本语法","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%8C-js%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["JavaScript","入门"],"content":"从字符串中提取证书和浮点数函数 parseInt() 功能: 在一个字符串中，从左往右提取整形。如果遇到非整形的内容，则停止提取，并返回结果。 注意: 如果第一个字符就是非整数，则立即停止，并返回NaN。 parseFloat()系统函数、全局函数 功能: 在一个字符串中，从左向右提取浮点型：遇到非浮点型内容，则停止提取，并返回结果。 功能: 如果第一个字符就是非浮点型，则立即停止，并返回NaN。 ","date":"2016-04-11","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%8C-js%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:0:4","tags":["JavaScript","入门"],"title":"基础篇(二)-JS基本语法","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%8C-js%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["JavaScript","入门"],"content":"JS运算符 **1.算数运算符: + ,- ,* , /, %, ++, --** **2.赋值运算符: =、+=、 -=、\\*=、/=** **3.字符串运算符:+、+=** **4.比较运算符:\u003e, \u003c, \u003e=, \u003e=, ==, != ,=== ,!==** =是赋值号。 ==等于。指比较两个变量的值，而不管类型。只要值一样，就返回true，否则返回false。 ===全等于。既比较变量，也判断类型。如果类型和值都一样，才会返回true。 **5.逻辑运算符: \u0026\u0026、||、!** **6.三目运算符** 语法:条件表达式?结果1：结果2 含义: 如果条件为true，则执行结果1；如果条件为false则执行结果2. 特殊运算符 new 运算符: 创建一个对象。如:var today = new Date(); delete 运算符:删除数组的元素，或者对象的属性。 typeof运算符:一元运算符，主要功能:判断变量的类型。 点运算符(.):主要应用在对象中，通过点运算符(.)去调用属性或方法。如:window.alert(\"ok\"); []中括号:主要用来访问数组元素的。如arr[0]=100; 运算符的优先级 特殊运算符 \u003e 算数运算符 \u003e 比较运算符 \u003e 逻辑运算符 \u003e 赋值运算符 运算符类别 优先级 . [ ] new ( ) 级别最高 ! ++ – 次之上级 * / % 次之上级 + - 次之上级 \u003c \u003e \u003e= \u003c= 次之上级 == != === !== 次之上级 \u0026\u0026 = += -= /= *= %= 次之上级 ","date":"2016-04-11","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%8C-js%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:0:5","tags":["JavaScript","入门"],"title":"基础篇(二)-JS基本语法","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%8C-js%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["JavaScript","入门"],"content":"window.prompt() 功能:弹出一个输入框，让用户来输入内容。 语法: var year = windown.prompt(text[,defaultText]) 参数: 参数名 说明 text 提示信息 defaultText 可选性,也就是可有可无.输入框的默认内容 返回值:如果单击确定按钮，返回一个字符串的数据。如果取消按钮，返回一个null。 break语句 描述: break语句，用于无条件结束各种循环(退出循环)和switch。 说明: 一般情况下,需要在break语句之前加一个条件判断。 continue 描述：结束本地循环，开始下一次循环。 说明: 一般情况下，需要在continue语句之前加一个条件判断。 ","date":"2016-04-11","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%8C-js%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:0:6","tags":["JavaScript","入门"],"title":"基础篇(二)-JS基本语法","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%8C-js%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["JavaScript","入门"],"content":"数组 一组数的集合，称为集合。 var arr = [10,20,30,40] 数组的创建方法 1 使用new关键字和Array()来创建数组。 var arr = new Array(); //创建一个空数组 var arr = new Array(\"小花\",34,\"男\"); //创建一个数组并赋值。 数组元素的值可以是任意类型。 给数组添加某一个角标时，下表可以不连续，但是值为undefined 删除元素：delete arr[index];//删除的只是元素的值，而下角标的空间占有还在。 ","date":"2016-04-11","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%8C-js%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:0:7","tags":["JavaScript","入门"],"title":"基础篇(二)-JS基本语法","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%8C-js%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["JavaScript","入门"],"content":"函数 函数定义格式的说明 function关键字是必须的，全小写。 函数名称命名规则和变量名一样。 (): 是定义函数时接收数据的参数。参数可有可无，多个参数之间用逗号隔开。 –形参(形式参数):定义函数时的参数就是形参。形参不能用var定义，不需要声明。 –实参(实际参数):调用函数时的参数称为实参。 如果function无返回值，调用函数后本身的值就是undefined 匿名函数:没有名字的函数 匿名函数，不能单独定义的，也不能单独调用。 匿名函数，一般是作为数据给其他变量赋值的。 var a = function(){ window.alert(\"OK\"); } //将函数赋给变量a，那么a就是函数型变量。 a(); //调用函数 二维数组 给一个数组元素，附一个数组的值，那么，这个数组就是二维数组。 二维数组可以关联到表格。 JS对象的分类 JS内置对象 BOM对象 DOM对象 自定义对象 数组对象、日期对象、字符串对象等 浏览器各组件对象,包括:window、document、location、history等 文档对象，包括所有HTML标记，每一个HTML标记对视一个对象 根据自己项目需要，自己定义自己的对象 自定义对象 1 new 关键字创建。 // 1. 使用new关键字结合构造函数Object()来穿件一个空的对象。 var obj = new Object(); // 2. 增加属性 obj.name = \"张三\" obj.age = 24; obj.sex = \"男\"; // 3.增加方法: 将一个函数定义赋给对象属性，那么该属性变成方法。 obj. showInfo = function(){ window.alert(); } // 4.调用对象方法 obj.showInfo(); 2 使用大括号{}来创建对象。 var obj = { name : \"张三\"; sex : \"男\"; age : 24; showInfo : function(){ window.alert(); } } 简单的小实例 ","date":"2016-04-11","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%8C-js%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/:0:8","tags":["JavaScript","入门"],"title":"基础篇(二)-JS基本语法","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%BA%8C-js%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"categories":["JavaScript","入门"],"content":" ","date":"2016-04-10","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B8%80-js%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/","tags":["JavaScript","入门"],"title":"基础篇(一)-JS简单介绍","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B8%80-js%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"},{"categories":["JavaScript","入门"],"content":"自学小笔记 ","date":"2016-04-10","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B8%80-js%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/:0:0","tags":["JavaScript","入门"],"title":"基础篇(一)-JS简单介绍","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B8%80-js%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"},{"categories":["JavaScript","入门"],"content":"JavaScript是什么？ JavaScript是一种小型的、轻量级的、面向对象的、跨平台的客户端脚本语言。 JavaScript是嵌入到浏览器软件当中的，只要电脑有浏览器就可以执行JS程序了。 JavaScript是一种面向对象的程序语言。 在程序中，对象是由属性和方法构成。 JS中的对象只要会用就可以，不需要我们自己去创建对象 跨平台性: JS程序可以在多种平台下运行, 如: windows、linux、mac、android、ios等。 客户端脚本程序: JS只能在客户端的浏览器来运行, 不能再服务器端来运行。 浏览器是一个翻译器，可以翻译三种代码: Html代码、CSS代码、JavaScript代码。 ","date":"2016-04-10","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B8%80-js%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/:0:1","tags":["JavaScript","入门"],"title":"基础篇(一)-JS简单介绍","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B8%80-js%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"},{"categories":["JavaScript","入门"],"content":"JavaScript能干什么？ 表单验证: 是JS最基本的功能。 动态HTML: 可以实现一些动态的、重复的效果。 交互式: 人机交互，可以通过键盘或鼠标，与网页中的元素进行交互。 ","date":"2016-04-10","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B8%80-js%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/:0:2","tags":["JavaScript","入门"],"title":"基础篇(一)-JS简单介绍","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B8%80-js%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"},{"categories":["JavaScript","入门"],"content":"JavaScript名称的由来？ JavaScript最初叫\"LiveScript\"，是网景公司(Netscape)公司开发，为自己的浏览器Navigator2.0开的客户端语言。 ###\\\u003cscript\u003e\\\u003c/script\u003e标记### JS代码也是嵌入到HTML文档中去的。 同一个网页中，可以有HTML代码，CSS代码、JavaScript代码。 通过\u003cscript\u003e\u003c/script\u003e来引入JS程序代码。 \u003cscript type=\"text/javascript\"\u003e //在\u003cbody\u003e中输出一句话 document.write(\"我是通过js写出来的\"); \u003c/script\u003e ","date":"2016-04-10","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B8%80-js%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/:0:3","tags":["JavaScript","入门"],"title":"基础篇(一)-JS简单介绍","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B8%80-js%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"},{"categories":["JavaScript","入门"],"content":"常用的两个客户端输出方法 document.write(str) 描述: 在网页的\u003cbody\u003e标记，输出str的内容。 document意思“文档”，就是整个网页。 document是一个文档对象，代表整个网页 wirte()是document对象的一个输出方法。 .小数点:通过小数点来调用对象的方法。 str: 表示要输出的内容。 //创建一个网页标题 document.write(\"\u003ch1\u003e我是最大的标题\u003c/h1\u003e\") //创建一个网页的段落 document.write('\u003cp style=\"color:blue;\"\u003e 这是第一个js文件哦\u003c/p\u003e'); windown.alert(str) 描述: 在当前窗口中弹出一个警告对话框，str为对话框中要显示的内容。 window代表当前浏览器窗口,window是一个窗口对象。 alert()方法: 弹出一个对话框。 str: 表示要输出的内容。 window.alert(\"我是一个alert窗口!\"); ","date":"2016-04-10","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B8%80-js%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/:0:4","tags":["JavaScript","入门"],"title":"基础篇(一)-JS简单介绍","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B8%80-js%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"},{"categories":["JavaScript","入门"],"content":"JS中的注释 HTML的注释: \u003c!-- 注释内容 --\u003e CSS注释: /* 注释 */ JavaScript注释: // 或 /* 多行注释 */ ","date":"2016-04-10","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B8%80-js%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/:0:5","tags":["JavaScript","入门"],"title":"基础篇(一)-JS简单介绍","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B8%80-js%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"},{"categories":["JavaScript","入门"],"content":"变量 变量的概念 变量是变化的一个量。 变量可以是一个未知数。 x=1。 变量可以是一个符号。 变量可以看成车牌号。 变量一般是程序的数据。 变量是在内存中存在和运行的。 变脸是临时存在的数据。 变量的声明 变量的声明，相当于预定宾馆的房间。 语法格式: var 变量名 = 变量值 声明变量是使用系统关键字var来进行的。 var name ; //声明一个变量 var name,sex,edu; //同时声明多个变量，多个变量间用英文下的逗号隔开 var name = \"小明\"; //声明一个变量并为其附上一个值 变量的命名规则 变量名可以包含字母、数字、下划线。 变量名不能以数字开头，可以以字母或下划线开头。 变量名不能是系统关键字。 如 var、switch、for、try、case、else、while等。 ","date":"2016-04-10","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B8%80-js%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/:0:6","tags":["JavaScript","入门"],"title":"基础篇(一)-JS简单介绍","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B8%80-js%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"},{"categories":["JavaScript","入门"],"content":"变量的数据类型 变量室友数据类型的，这个类型来源于“变量的值”。动态变量 JS中变量的类型有: 数值型、字符型、布尔型、undefined、null、array、object、function。 动态变量在进行运算的时候，只能进行同类运算。如果类型不同，将进行类型转换。 ","date":"2016-04-10","objectID":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B8%80-js%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/:0:7","tags":["JavaScript","入门"],"title":"基础篇(一)-JS简单介绍","uri":"/posts/%E5%9F%BA%E7%A1%80%E7%AF%87%E4%B8%80-js%E7%AE%80%E5%8D%95%E4%BB%8B%E7%BB%8D/"},{"categories":["css","入门"],"content":" ","date":"2016-04-03","objectID":"/posts/css%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F/","tags":["css","入门"],"title":"CSS语法格式","uri":"/posts/css%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F/"},{"categories":["css","入门"],"content":"自学小笔记 ","date":"2016-04-03","objectID":"/posts/css%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F/:0:0","tags":["css","入门"],"title":"CSS语法格式","uri":"/posts/css%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F/"},{"categories":["css","入门"],"content":"CSS语法格式 h1 {color:red; font-size:14px} 选择器 声明属性 值 一个css由选择器和格式声明语句构成。 选择器:就是选择HTML标记，换句话说:就是给哪个HTML标记加样式。 格式声明语句: 由{}构成。内部由 属性名:属性值 构成，并以分号结束。 属性名就是CSS中的各种属性，这些属性都是固定的。 属性值可以区分不同的值，不需要引号。 CSS中的数字单位都是px，px不能省略。 ","date":"2016-04-03","objectID":"/posts/css%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F/:0:1","tags":["css","入门"],"title":"CSS语法格式","uri":"/posts/css%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F/"},{"categories":["css","入门"],"content":"CSS选择器 1.基本选择器 *选择器 又叫通配符 描述:将匹配所有的HTML标签。所有的标记都会改变。 语法:*{color:red} 将所有的HTML标记的颜色都会变为红色。 标签选择器 描述:将匹配指定的HTML标签。 语法:h1{color:red} 将指定的标记改变其状态。 class选择器 描述:给一类HTML标签加样式，这里所指的每个HTML标记都应该有一个class属性。class属性是公共的属性。 语法:.className{color:red} 类选择器必须以.开头，后面跟HTML的class的属性。(类选择器如果有多个相同可以用class所在的标签名称加前缀来区分)。 id选择器 描述: 给指定id的元素添加样式。(注意:网页中HTML标记的id属性值，必须是唯一的)。每一个HTML标记都有一个公共属性id。 语法: #classId{color:red;}。 id属性一般是给js使用的，尽量不要加css的样式。而class属性只能给css用，不能给js用。id选择器必须#开头。 2.组合选择器 多元选择器 描述: 给多个元素加同一个样式，每个选择器之间用逗号‘,’分开。 举例: h1,p,div,body{color:red;} 后代选择器 描述: 给某一个标签的后代元素加样式。选择器之间用空格分开。 举例: div h1.title{background-color:yellow;} 子元素选择器 描述: 给某个元素的子元素加样式 举例: .box \u003e .title{color:red;} CSS优先级 1 单个选择器的优先级: 行内样式 \u003e id选择器 \u003e class选择器 \u003e 标签选择器 2 多个选择器的优先级 多个选择器的优先级，指向越明确，优先级越高。特殊情况下，我们需要假设一些值： 标签选择器 优先级为1 类选择器 优先级为10 id选择器 优先级为100 行内选择 优先级为1000 3.css注释 css注释内容:/* css 注释内容 */ html注释: \u003c!-- 注释内容 --\u003e 4.css尺寸属性 width:元素宽度，一定要加px单位。 height:元素高度 注意: span行内元素没有储存属性。div只有块元素才有尺寸属性。而input比较特殊是行内元素，但也可以指定宽高。 5.css字体属性 font-size: 文字大小，如: font-size:14px font-family: 字体。如: font-family:温软雅黑 font-style:斜体，取值italic。 如: font-style:italic font-weight: 粗体，取值bold。 如: font-weight:bold; 6.css文本颜色 color: 文本颜色。 text-decoration: 文本修饰线，取值:none(无)，underline(下划线)，overline(上划线)，line-through(删除线). line-height: 行高，可以用固定值，也可以用百分比。如:line-height:20px ; line-height:150%; * text-indent: 首行缩进，如 text-indent:28px; letter-spacing: 字间距。 display 属性 功能：规则网页元素如何显示的问题。 取值： none(隐藏)、 block(已块元素显示)、 inline(以行内元素显示) block: 可以实现将行内元素转成块元素。 inline: 可以实现将块元素转成行内元素。 overflow 功能： 当内容溢出的时候，该如何显示。 overflow: 当内容溢出时，溢出的内容该如何显示。 取值： visity(显示)， auto(多余部分可通过滚动条查看)， hidden（截取掉多余的部分） cursor光标类型 功能：网页中光标的类型 取值: help、wait、pointer(手形光标)等。 ","date":"2016-04-03","objectID":"/posts/css%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F/:0:2","tags":["css","入门"],"title":"CSS语法格式","uri":"/posts/css%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F/"},{"categories":["css","入门"],"content":"常用标签属性 css伪类选择器 超链接加样式 一个超链接有四个状态: 正常状态(:link): 鼠标放上之前连接的样式。 放上状态(:hover): 鼠标放到链接上时的样式。 激活状态(:active): 按住鼠标左键不松开的样式，这个状态特殊短暂。 访问过的状态(:visited): 按下鼠标左键，并弹起之后。 在开发中，会使用一下写法，来给链接加上不同的效果: a:link,a:visited,{color:#666;text-decoration:none} //默认和已访问时 a:hover{color:#999;text-decoration:underline;} css列表属性 list-style: 列表样式，取值：none去掉项目符号或编号前面的各种符号 。ul ,li css 表格属性 border-collapse: 表格边框线合并,取值: collapse. css边框属性:每个元素都可以加边框线 格式: border-left: 粗细 线性 线的颜色 border-left: 1px solid red 线性: none(无线),solid（实线）,dashed(虚线),dotte(点状线) border-left: 左边框线 border-right: 右边框线 border-bottom: 下边框线 border-top: 上边框线 border: 同时给四个边加边框。 CSS 外边距: 边框线往外的距离 margin-left: 左边线往外的距离。 margin-right: 右边线往外的距离。 margin-top: 上边线往外的距离。 margin-bottom: 下边线往外的距离。 简写式: margin: 10px //四个外边距分别为10px margin: 10px 20px //上下外边距为10px。左右外边距为20px margin: 5px 10px 15px; //上外边距5px,左右外边距10px,下外边距15px。 margin: 5px 10px 15px 20px //顺序一定是\"上右下左\" css 背景属性 background-color: 背景颜色。 background-image: 背景图片地址。如：background-image:url(images/bg.gif) background-repeat: 背景平铺方式，取值: no-repeat(不平铺) repeat-x(水平方向) repeat-y(垂直方向) background-position: 背景定位 中文: background-position: 水平方向定位 垂直方向定位 英文: background-position: left|center|right top|center|bottom 固定值: background-position: 50px 50px 百分比: background-position: 50% 50% //水平居中，垂直居中 混合定位: background-position: left 10px; //背景靠左边齐，距离容器顶端10px 简写方式 background: 背景色 背景图 平铺方式 定位方式； ","date":"2016-04-03","objectID":"/posts/css%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F/:0:3","tags":["css","入门"],"title":"CSS语法格式","uri":"/posts/css%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F/"},{"categories":["css","入门"],"content":"CSS浮动和清除 float: 让元素浮动,取值: left(左浮动)、 right(右浮动) clear: 清除浮动, 取值: left(清除左浮动)、 right(清除右浮动)、 both(同时清除上面的左右浮动) 1 css浮动 浮动的元素，将向左或向右浮动，浮动到包围元素的边上，或上一个浮动元素的边上为止。 浮动的元素，不在占空间了，并且，浮动元素的层级要高于普通元素。 浮动的元素，一定是块元素。不管他原来是什么元素。 如果浮动的元素没有指定宽高的话，浮动后它将尽可能的变窄。因此，浮动元素一般要定宽和高。 一行中的多个元素要浮动一起浮动！ 浮动的功能：可以实现将多个块元素并且列版。 ？如何让包围元素，包住包围元素？ 在浮动元素的下边，使用清除浮动操作。 clear:both; 2 CSS清除浮动 css清除浮动的功能有两个 可以包围元素从视觉上包住浮动元素 清除之下的其他元素将恢复默认排版。 有浮动就必须要与清除。 如果包围元素指定了高度了。那么可以不适用清除功能。 CSS属性继承：外层元素的样式，会被内层元素进行继承。多个外层元素的样式，最终会\"叠加\"到内层元素上。 什么样的css属性能被继承？？ css文本属性都会被继承： color、font-size、font-family.font-style、font-weight、text-align、text-decoration、text-indent、letter-spacing、line-height 提示\u003cbody\u003e中的css属性。会被所有元素继承。 ","date":"2016-04-03","objectID":"/posts/css%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F/:0:4","tags":["css","入门"],"title":"CSS语法格式","uri":"/posts/css%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F/"},{"categories":["css","入门"],"content":"CSS 定位 默认为文档流—从上而下。 定位方式：position 取值：static、fixed、relative、absolute static：静态定位(默认状态，不定位) Fixed：固定定位 relative：相对定位 absolute：绝对定位 定位方式，要与定位属性配合使用 定位坐标: 指定定位的元素,偏移目标元素多远的距离。 Left: 定位元素，距离目标元素左边的距离 Top: 定位元素，距离目标元素上边的距离 Right: 定位元素，距离目标元素右边的距离 Bottom: 定位元素，距离目标元素下边的距离 1 固定定位 position:fixed 固定定位，是相对于浏览器窗口来进行的定位。 固定定位，不占空间，层级要高于普通元素。他不会随着网页的滚动而滚动。 如果不指定定位坐标的话，固定元素的位置在原地不动。 固定定位元素，一定是\"块元素\" 2 相对定位 position:relative 相对定位, 是相对于\"原来的自己\"进行定位 相对定位, 依然占空间,层级高于普通元素。 如果不指定定位坐标的话，相对定位元素的位置在原地不动。 相对定位原来是块元素还是块元素，如果原来是行内元素还是行内元素。 提示 相对定位和绝对定位，一般情况下是配合使用的。 3 绝对定位 position:absolute 相对于祖先定位元素(相对定位，决定定位)，来进行的定位 如果他的父元素没有进行任何定位的话，再往上找定位元素 如果一直找到\u003cbody\u003e都没有找到定位元素的话,那就相对于\u003cbody\u003e来进行定位。网页定位 绝对定位元素,不占空间,层级要高于普通元素。 如果不指定定位坐标的话,绝对定位元素的位置在原地不动。 绝对定位，转换为块元素 定位可以设置层叠之间顺序 z-index: //值越大越靠近前排 ","date":"2016-04-03","objectID":"/posts/css%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F/:0:5","tags":["css","入门"],"title":"CSS语法格式","uri":"/posts/css%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F/"},{"categories":["css","入门"],"content":"HTML引入CSS的方法 1 嵌入式 通过\u003cstyle\u003e标记，来引入css样式。 语法格式: \u003cstyle type=\"text/css\"\u003e\u003c/style\u003e 提示: \u003cstyle\u003e中CSS样式，只能给当前网页来使用。同一个网页中,\u003cstyle\u003e标记可以出现出现。 2 外联式 通多\u003clink\u003e标记，来如因一个外部的CSS文件(.css)，这样的话，可以实现公共的CSS代码被多个页面共享。 \u003clink rel=\"stylesheet\" type=\"text/css\" href=\"css/public.css\"/\u003e \u003clink\u003e标记的常用属性 rel: 也就是引入的是什么类型的文件。取值:stylesheet type: 内容类型。 href: 引入的CSS文件地址。 提示:\u003clink\u003e标记放在\u003chead\u003e标记中。 同一个网页，可以使用多个\u003clink\u003e来链入多个外部样式文件。 3 行内式(主要用于JS控制元素的样式) 每一个HTML标记,都有一些公共的属性: class、id、title、style。 HTML标记中style属性的值，与CSS中样式一模一样。 ","date":"2016-04-03","objectID":"/posts/css%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F/:0:6","tags":["css","入门"],"title":"CSS语法格式","uri":"/posts/css%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F/"},{"categories":["css","入门"],"content":"盒子模型 我们可以把每一个HTML标记，都看成一个盒子 盒子都有哪些特征：内容的高度，内容的宽度，边框线，内填充，外边距。 上下外边距合并问题：上下两个块元素,如果每一个都指定了四个外边距， 那么上下外边距合并后会取较大的外边距。 同一个class属性, 可以指定多个类名样式,多个类样式之间用空格隔开。 场景: 当两个块元素具有相同的特性，但是还有部分不一样的时候使分开处理。 ","date":"2016-04-03","objectID":"/posts/css%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F/:0:7","tags":["css","入门"],"title":"CSS语法格式","uri":"/posts/css%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F/"},{"categories":["css","入门"],"content":"浏览器兼容性简介 一个网页在不同的浏览器下， 显示的效果可能不一致, 这所谓\"不兼容\" 兼容性调试, 主要调试IE8，IE7，IE6，firefox。 IE6 浏览器的调试工具: IETESTer 兼容性从以下撒个方面来讲解 全局CSS设置 常用兼容性技巧 CSS HACK 常用的兼容性调试技巧 1 实现所有浏览器主页居中 Firefox 下主页居中代码： .box{margin: 0px auto} IE5.5 下主页居中代码: body{text-align:center} 2 单行文本上下居中 h1{ height: 30px; line-height:30px} 3 左右margin会加倍(IE6) 解决的方案: 使用 display:inline; //将其转为行内元素，避免此问题 注意: 排版的时候能使用padding解决的，坚决不用margin。如果实在想用的话，就使用其中一边。 ","date":"2016-04-03","objectID":"/posts/css%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F/:0:8","tags":["css","入门"],"title":"CSS语法格式","uri":"/posts/css%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F/"},{"categories":["css","入门"],"content":"全局CSS设置 1 清除所有标记的内外边距 body、ul、li、a、img、p、input{margin:0; padding:0} 2 去除项目符号或编号前面的符号 ul、ol、li{list-style: none;} 3 全局连接效果 a:link,a:visited{color:#444; text-decoration:none} a:hover{color:red} 4 网页中所有的文字大小颜色 body{font-size: 12px; font-family:宋体; color:#ccc;} 5 去除图片的连接边框线 img{border:0} 6 全局的类样式 .floatL{float:left;} .floatR{float:right;} .clear{clear:both;} .blank10{ height:10px; clear:both;} .red{ color:red} .blue{color:red} CSS HACK 针对不同浏览器，书写不同的CSS代码的过程，成为\"CSS HACK\" 也就是说: 写一个CSS代码，让IE6识别，其他浏览器不识别。 以下这些符号实在CSS属性的前面加的。用于分辨不同的浏览器版本。 \"*\"IE6和IE7都识别。 如: .box{*background-color:red;} \"-\" 只有IE6识别。如 .box{_background-color:green;} CSS HACK 不是W3C的标准，因此,尽量少用。 ","date":"2016-04-03","objectID":"/posts/css%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F/:0:9","tags":["css","入门"],"title":"CSS语法格式","uri":"/posts/css%E8%AF%AD%E6%B3%95%E6%A0%BC%E5%BC%8F/"},{"categories":["markdown"],"content":" ","date":"2016-03-24","objectID":"/posts/markdown-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","tags":["markdown"],"title":"markdown 简单使用","uri":"/posts/markdown-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"},{"categories":["markdown"],"content":"自学小笔记 声明标题 使用#开始声明标题 后续添加title的内容。 例如：# this is big title # or ### this is small title # #的数量为字体大小，最大字号为一个#号，最多不得超过6个。 字体样式 suzeyu 默认 suzeyu 斜体 —-\u003e *suzeyu* suzeyu 加粗 —-\u003e **suzeyu** suzeyu 删除线 —-\u003e ~~suzeyu~~ 列表样式 无序 使用 +, -,* 可以创建无序列表 例如 red yellow blue - red - yellow - blue 有序 使用 1., 数字加上点 例如 first second third 1. first 2. second 3. third 代码区块 行首四个空格或者一个制表符可进入代码区域 分割线 任意一种都可以 --- *** 超链接 加载图片 添加一个超链接 点我跳转github [ name ](http://xxx.xx.xx) 添加一个图片 ![alt text](image/demo.png) ","date":"2016-03-24","objectID":"/posts/markdown-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/:0:0","tags":["markdown"],"title":"markdown 简单使用","uri":"/posts/markdown-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"},{"categories":["markdown"],"content":"表格 first second third 1 2 3 4 5 6 7 8 9 code: | first | second | third | | ------| ------ | ----- | |1|2|3| |4|5|6| |7|8|9| ","date":"2016-03-24","objectID":"/posts/markdown-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/:0:1","tags":["markdown"],"title":"markdown 简单使用","uri":"/posts/markdown-%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"},{"categories":null,"content":" 阅读《Android 编程实战》一书的抄书笔记 –\u003e 第三,四章 ","date":"0001-01-01","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9803-%E7%BB%84%E4%BB%B6-%E6%B8%85%E5%8D%95-%E8%B5%84%E6%BA%90%E5%92%8Cui%E9%97%B2%E8%81%8A/:0:0","tags":["android","笔记"],"title":"《Android 编程实战》03-组件 清单 资源和UI闲聊","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9803-%E7%BB%84%E4%BB%B6-%E6%B8%85%E5%8D%95-%E8%B5%84%E6%BA%90%E5%92%8Cui%E9%97%B2%E8%81%8A/"},{"categories":null,"content":"应用程序清单 AndroidManifest是一个定义各种组件以及应用程序各个方向的XML文件. 该清单是所有Android的核心. ","date":"0001-01-01","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9803-%E7%BB%84%E4%BB%B6-%E6%B8%85%E5%8D%95-%E8%B5%84%E6%BA%90%E5%92%8Cui%E9%97%B2%E8%81%8A/:1:0","tags":["android","笔记"],"title":"《Android 编程实战》03-组件 清单 资源和UI闲聊","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9803-%E7%BB%84%E4%BB%B6-%E6%B8%85%E5%8D%95-%E8%B5%84%E6%BA%90%E5%92%8Cui%E9%97%B2%E8%81%8A/"},{"categories":null,"content":"manifest元素 AndroidManifest.xml文件的根节点元素是manifest. 应用程序的包名和唯一识别符都定义在该节点. 还可以在该节点中定义Linux用户ID和名称(应用程序将运行在该ID下). 应用的版本, APK的安装位置. \u003cmanifest xmlns:android=\"http://schemas.android.com/apk/res/android\" package=\"com.test.printertestdemo\" android:sharedUserId=\"com.szysky.userid\" android:sharedUserLabel=\"@string/user_name\" android:installLocation=\"auto\" android:versionCode=\"6\" android:versionName=\"2.0\" \u003e \u003c/manifest\u003e 这是一个比较完整的配置. sharedUserId和sharedUserLabel是Linux用户ID和名称. 应用程序将会运行在上面. 默认情况下, 这些都是系统分配的. 如果为使用证书发布的多个应用设置同样的值时, 开发者就可以访问相同的数据, 并有可能可以共享这些应用的进程(下面说道). 多个应用共享同一个进程可以节省应用程序使用的RAM总量. 但当其中一个应用出现运行时错误, 那所有共享相同进程的其他应用也会崩溃. 使用installLocation属性来控制应用程序的安装位置. 即可以在设备的内部存储器(data分区)安装应用程序, 也可以在外部存储装置(SD卡)安装. 需要注意: 只能通过这个属性控制APK的安装位置. 应用程序数据仍然安全地存储在内部存储器中. ","date":"0001-01-01","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9803-%E7%BB%84%E4%BB%B6-%E6%B8%85%E5%8D%95-%E8%B5%84%E6%BA%90%E5%92%8Cui%E9%97%B2%E8%81%8A/:1:1","tags":["android","笔记"],"title":"《Android 编程实战》03-组件 清单 资源和UI闲聊","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9803-%E7%BB%84%E4%BB%B6-%E6%B8%85%E5%8D%95-%E8%B5%84%E6%BA%90%E5%92%8Cui%E9%97%B2%E8%81%8A/"},{"categories":null,"content":"user-feature 这个属性元素\u003cuser-feature\u003e可以让Google Play去过滤应用在哪台设备可见. 比如应用需要一个打电话的功能, 但是当前设备只支持wifi的平板电脑. 或者说一个Android电视是不支持触屏控制, 但是应用需要这个硬件特性的支持. 就可以通过这个属性设置. 例如: \u003cuser-feature android:name=\"android.hardware.microphone\"\u003e \u003c!--需要电话功能支持--\u003e \u003cuser-feature android:name=\"android.hardware.telephony\"\u003e \u003c!--支持多点触控的触摸屏--\u003e \u003cuser-feature android:name=\"android.hardware.touchscreen.multitouch.jazzhand\"\u003e ","date":"0001-01-01","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9803-%E7%BB%84%E4%BB%B6-%E6%B8%85%E5%8D%95-%E8%B5%84%E6%BA%90%E5%92%8Cui%E9%97%B2%E8%81%8A/:1:2","tags":["android","笔记"],"title":"《Android 编程实战》03-组件 清单 资源和UI闲聊","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9803-%E7%BB%84%E4%BB%B6-%E6%B8%85%E5%8D%95-%E8%B5%84%E6%BA%90%E5%92%8Cui%E9%97%B2%E8%81%8A/"},{"categories":null,"content":"application 使用自定义的Application必须要做的就是在清单文件中指定\u003capplication\u003e中的name属性到自定义的application. 列举一下属性: label, description: 可以让用户在设置页面中看到关于应用的更多详细的描述. android:backupAgent: 这是Google提供的一个备份服务, 需要实现自己的备份代理的类,并使用此属性指向此类. android:largeHeap: 可以让系统知道需要更多的内存. 但是, 除非特别需要, 否则不要这么做. 因为这样做会浪费系统资源,而且系统会更快的终止应用程序. android:process: 当多应用程序共享一个用户ID, 并且process属性设置为一个值的时候, 可以强制这些应用共享同一个进程. (所以如果需要使多应用使用一个进程, 那么所有的应用必须共享同一个用户ID并同一个证书签名和相同的process) android:theme: 属相设置整个应用的主题. ","date":"0001-01-01","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9803-%E7%BB%84%E4%BB%B6-%E6%B8%85%E5%8D%95-%E8%B5%84%E6%BA%90%E5%92%8Cui%E9%97%B2%E8%81%8A/:1:3","tags":["android","笔记"],"title":"《Android 编程实战》03-组件 清单 资源和UI闲聊","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9803-%E7%BB%84%E4%BB%B6-%E6%B8%85%E5%8D%95-%E8%B5%84%E6%BA%90%E5%92%8Cui%E9%97%B2%E8%81%8A/"},{"categories":null,"content":"组件元素和属性 每个标准组件(activity, service, broadcastReceiver, contentProvider)在清单文件都有自己的节点元素, AS创建的默认属性通常能满足大部分情况. 下面看一下其他的属相把 android:enabled = \"false\" 我们所定义的所有组件默认都是可用的. 当把enable设置为false的时候, 可以修改默认行为, 这将阻止组件接收Intent. 禁用的Activity不会显示在应用程序启动器中; 禁用的Service不会响应startService()调用; 禁用的BroadcastReceiver不会监听BroadcastIntent; 禁用的ContentProvider不会响应ContentResolver. 代码中同样可以设置: PackageManager pm = getPackageManager(); // 启用一个activity pm.setComponentEnabledSetting(new ComponentName(this, MainActivity.class), PackageManager.COMPONENT_ENABLED_STATE_ENABLED, PackageManager.DONT_KILL_APP); // 禁用一个activity pm.setComponentEnabledSetting(new ComponentName(this, MainActivity.class), PackageManager.COMPONENT_ENABLED_STATE_DISABLED, PackageManager.DONT_KILL_APP); 有时候出于安全的原因, 我们不希望把某个组件暴露给系统的其他应用使用, 这时可以通过android:exported=\"false\", 这会有效地把对外可被调用属性关闭. 如果你想设置一个组件供其他应用使用, 但又想提供某个安全级别, 则可以定义权限, 要做到这一点, 那么调用者应该在清单文件中添加使用权限(user-permission), 然后在提供者应用注册一个权限(permission). ","date":"0001-01-01","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9803-%E7%BB%84%E4%BB%B6-%E6%B8%85%E5%8D%95-%E8%B5%84%E6%BA%90%E5%92%8Cui%E9%97%B2%E8%81%8A/:1:4","tags":["android","笔记"],"title":"《Android 编程实战》03-组件 清单 资源和UI闲聊","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9803-%E7%BB%84%E4%BB%B6-%E6%B8%85%E5%8D%95-%E8%B5%84%E6%BA%90%E5%92%8Cui%E9%97%B2%E8%81%8A/"},{"categories":null,"content":"Intent过滤 在Android中所有的组件都是通过Intent访问的, Intent抽象地描述了要执行的动作. Intent会被发送给Activity, Service, BroadcastReceiver. 一旦发送, Android系统的Intent将决定将Intent分发给哪个组件. Intent要确认的第一件事情就是分辨出隐式还是显示. 显示Intent包含有关包和组件的名称信息, 他们可以立即分发, 因为只能匹配到一个组件. 此方法通常应用于程序内部的通信. 隐式Intent的取决于三个因素: action, 数据的URI和类型, 以及类别. 注意: extras和flags对Intent区分没有影响 action是最主要的, 通常也是唯一应该重点关注的. Android有许多预定义的action, 开发者也可以定义自己的action. 开发者定义自己的action时, 通常在前面加上自己的包名, 这样不同应用之间action定义的冲突也就基本不存在了. data并没有实际的数据, 只是包含了URI和MIME类型, 使用Activity打开只包含特定类型文件会非常有用. category和Activity最相关. 所有通过startActivity()发送的隐式Intent都至少定义了一个category(android.intent.category,DEFAULT), 所以除非Activity的Intent-filter也包含这个category. 否则就不会通过Intent的匹配. 比较例外的是图标启动器的intent-filter \u003cactivity android:name=\".PrinterTestDemoAct\" android:label=\"@string/app_name\"\u003e \u003cintent-filter\u003e \u003caction android:name=\"android.intent.action.MAIN\" /\u003e \u003ccategory android:name=\"android.intent.category.LAUNCHER\" /\u003e \u003c/intent-filter\u003e \u003cintent-filter\u003e \u003caction android:name=\"android.intent.action.VIEW\"/\u003e \u003ccategory android:name=\"android.intent.category.DEFAULT\"/\u003e \u003cdata android:mimeType=\"video/*\"/\u003e \u003c/intent-filter\u003e \u003c/activity\u003e 如上清单配置: 有两个intent-filter, 第一个是用于桌面图标启动应用; 第二个是用于打开video开头的MIME类型文件. 第一个intent-filter不需要category.DEFAULT. 因为它将由启动器程序管理. 第二个intent-filter是我们经常使用startActivity()方法会匹配到的, 所以其中的category应该设置default, 无论被打开视频文件是本地还是网络, 只要MIME类型以Video开头就行. ","date":"0001-01-01","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9803-%E7%BB%84%E4%BB%B6-%E6%B8%85%E5%8D%95-%E8%B5%84%E6%BA%90%E5%92%8Cui%E9%97%B2%E8%81%8A/:1:5","tags":["android","笔记"],"title":"《Android 编程实战》03-组件 清单 资源和UI闲聊","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9803-%E7%BB%84%E4%BB%B6-%E6%B8%85%E5%8D%95-%E8%B5%84%E6%BA%90%E5%92%8Cui%E9%97%B2%E8%81%8A/"},{"categories":null,"content":"resources 和 assets 开发中除了实现业务逻辑的代码, 还有就是一些像XML布局,图标,文本值等这样的内容, 这些静态内容存储在APK文件的resources或者assets目录中. 所有的组员都属于一个特定的类型(比如layout, drawable等), 而assets是简单地存储在应用内的通用文件. 大多数非代码的内容都以资源的形式呈现, 因为他们紧密集成在Android API中. 从开发的角度来看, Android中的资源特性是平台最强大的功能之一, 它允许开发者根据屏幕尺寸, 定位参数, 设备能力等来提供多个版本的资源. 最常见的解决方案是通过在不同的文件中提供多个版本的文本字符串来支持多语言, 或者通过提供不同的布局文件和不同大小的图标来支持各种屏幕的尺寸. 在应用中定义资源要遵循的几个规则 一定要在应用中为每种类型的资源都提供一个默认值, 就是在没有任何限定符的资源目录中提供默认的图片, 图标, 文本字符串和布局. 确保当所有特定资源文件都无法匹配设备, 可以加载默认的资源而不会出现崩溃. 避免硬编码, 例如字符串和值. 虽然可能会需要做一些额外工作也不算太累, 相比与之后当需要改变整个应用中的所有字体, 外边距, 内边距, 增加字符串本地化的时候. 修改起来这简直就是轻而易举的简单. 通过提供限定符来过滤资源. 例如, 如果想为高密度像素的设备提供一套高分辨率的图标, 可以通过drawable-xxxhdpi目录内存储 ","date":"0001-01-01","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9803-%E7%BB%84%E4%BB%B6-%E6%B8%85%E5%8D%95-%E8%B5%84%E6%BA%90%E5%92%8Cui%E9%97%B2%E8%81%8A/:2:0","tags":["android","笔记"],"title":"《Android 编程实战》03-组件 清单 资源和UI闲聊","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9803-%E7%BB%84%E4%BB%B6-%E6%B8%85%E5%8D%95-%E8%B5%84%E6%BA%90%E5%92%8Cui%E9%97%B2%E8%81%8A/"},{"categories":null,"content":"高级String资源 通常, 应用中的所有字符串都应该放在string资源中. 这样比在java代码中相比, 可以消除一下问题, 特别是当涉及格式化字符串和本地化时. 比如: 在string.xml声明 \u003cstring name=\"personal_message\"\u003eHi %s !\u003c/string\u003e \u003cstring-array name=\"default_categories\"\u003e \u003citem\u003eWork!\u003c/item\u003e \u003citem\u003epersonal\u003c/item\u003e \u003c/string-array\u003e 在java中使用 String oneStr = getString(R.string.personal_message, \"suzeyu\"); String[] stringArray = getResources().getStringArray(R.array.default_categories); 第一个在获取string资源的时候, 传入了一个字符串参数, 并在%s处进行插入处理. ","date":"0001-01-01","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9803-%E7%BB%84%E4%BB%B6-%E6%B8%85%E5%8D%95-%E8%B5%84%E6%BA%90%E5%92%8Cui%E9%97%B2%E8%81%8A/:2:1","tags":["android","笔记"],"title":"《Android 编程实战》03-组件 清单 资源和UI闲聊","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9803-%E7%BB%84%E4%BB%B6-%E6%B8%85%E5%8D%95-%E8%B5%84%E6%BA%90%E5%92%8Cui%E9%97%B2%E8%81%8A/"},{"categories":null,"content":"本地化 要做到本地化的支持, 把默认字符串资源复制到一个适当语言和地区限定符的新目录中, 然后开始翻译文本. 如果要翻译一种语言的资源文件到另一种语言, 你可以通过使用谷歌翻译工具Google Translator ToolKit, 这是谷歌的一个服务, 允许上传一个文件, 然后将字符串自动翻译为指定的语言. ","date":"0001-01-01","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9803-%E7%BB%84%E4%BB%B6-%E6%B8%85%E5%8D%95-%E8%B5%84%E6%BA%90%E5%92%8Cui%E9%97%B2%E8%81%8A/:2:2","tags":["android","笔记"],"title":"《Android 编程实战》03-组件 清单 资源和UI闲聊","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9803-%E7%BB%84%E4%BB%B6-%E6%B8%85%E5%8D%95-%E8%B5%84%E6%BA%90%E5%92%8Cui%E9%97%B2%E8%81%8A/"},{"categories":null,"content":"使用assets 如果有一些较大的资源文件可以考虑放到assets和raw目录下. 考虑这样一种场景, 如果有一个游戏有许多的音效, 那么就可以在assets文件夹内创建一个soundfx目录, 接下来把所有的音频文件都放入此子目录中. (assets目录支持子文件夹) 如下代码显示了如何使用SoundPool和AssetManager来加载assets/soundfx目录内的所有音频文件. 并且最后关闭打开的文件, 防止内存泄漏. public HashMap\u003cString, Integer\u003e loadSoundEffects(SoundPool soundPool) throws IOException{ // 获取assets资源管理者 AssetManager assets = getAssets(); String[] soundEffectFiles = assets.list(\"soundfx\"); HashMap\u003cString, Integer\u003e soundEffectMap = new HashMap\u003cString, Integer\u003e(); for (String soundEffectFile: soundEffectFiles) { AssetFileDescriptor fileDescriptor = assets.openFd(\"soundfx/\" + soundEffectFile); int id = soundPool.load(fileDescriptor, 1); soundEffectMap.put(soundEffectFile, id); fileDescriptor.close(); } return soundEffectMap; } ","date":"0001-01-01","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9803-%E7%BB%84%E4%BB%B6-%E6%B8%85%E5%8D%95-%E8%B5%84%E6%BA%90%E5%92%8Cui%E9%97%B2%E8%81%8A/:2:3","tags":["android","笔记"],"title":"《Android 编程实战》03-组件 清单 资源和UI闲聊","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9803-%E7%BB%84%E4%BB%B6-%E6%B8%85%E5%8D%95-%E8%B5%84%E6%BA%90%E5%92%8Cui%E9%97%B2%E8%81%8A/"},{"categories":null,"content":"UI的一些小知识 ","date":"0001-01-01","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9803-%E7%BB%84%E4%BB%B6-%E6%B8%85%E5%8D%95-%E8%B5%84%E6%BA%90%E5%92%8Cui%E9%97%B2%E8%81%8A/:3:0","tags":["android","笔记"],"title":"《Android 编程实战》03-组件 清单 资源和UI闲聊","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9803-%E7%BB%84%E4%BB%B6-%E6%B8%85%E5%8D%95-%E8%B5%84%E6%BA%90%E5%92%8Cui%E9%97%B2%E8%81%8A/"},{"categories":null,"content":"文本 **字体:**人脑利用图像识别来分辨不同的字母汉字, 所以逻辑上来说, 应该使用很容易辨认的字体, 而高度装饰字体只适用于标识(logo)等其他场合. **文本布局:**例如报纸中的布局分成若干个专栏, 人们更偏向于稍微适中, 比较短的文本阅读. 所以切记不要让你的文本布局显示一行很长很长的文字. 尽量可以保持一行在45~72个字符. android中的大小单位 dp (density-independent) 控制控件大小 sp 基于dp产生, 主要用于文字大小 pt (points, 磅) px (pixel, 像素) mm (millimeter, 毫米) in (inch, 英寸) **推荐尺寸:**一个按钮一个比较好的大小值为48dp转换之后相当于9毫米, 这个尺寸可以让用户手指在触摸屏上轻松的交互. **图标大小:**针对之前说的48dp,当不同分辨密度下相对应的为 48像素(MDPI), 72像素(HDPI), 96像素(XHDPI), 以及144像素(XXHDPI). 这就是所谓的2:3:4:6. 对应的DPI分别指~160, ~240, ~320, ~480. 如果将位图作为图标使用, 那么就应该使用dp而不是像素为单位. 一个正常的图标, 如主屏幕上的启动图标, 应该为48dp*48dp, 而操作栏(action bar)的图标为32dp*32dp, 通知栏的图标24dp*24dp **字体的大小:**谷歌创建的Roboto字体被用于所有标准的Android程序. 不同的字体的尺寸即使一样, 实际看起来可能也会不同, 主要是因为他们的x-height不同, x-height即为当前字体小写字母x的高度. 经常使用的x-height较大的字体有Arial和Verdana 谷歌为Android字体定义了四个标准大小: micro 极小, 12sp small 小, 14sp medium 中, 18sp large 大, 22sp 典型透视:当我们需要凭借记忆画一个物体时, 大多数人会从一个略高于它的角度来描述它, 这就叫做典型透视. **人脸识别:**人类擅长人脸识别, 许多人可以轻松地从一堆人中挑选出自己的朋友. 实际上相对于识别物体, 我们能更快识别人脸. 此外, 我们对文字的理解远远慢于识别人脸. 不要让用户思考! 用户不应该花大量时间来研究如何使用应用程序. 开发者应该让第一次看到应用程序UI的用户无需置疑下一步该如何操作; 视觉线索是指一个物体向用户发出的如何与之交互的信息. 人们对文字的理解慢于对简单图标的理解. ","date":"0001-01-01","objectID":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9803-%E7%BB%84%E4%BB%B6-%E6%B8%85%E5%8D%95-%E8%B5%84%E6%BA%90%E5%92%8Cui%E9%97%B2%E8%81%8A/:3:1","tags":["android","笔记"],"title":"《Android 编程实战》03-组件 清单 资源和UI闲聊","uri":"/posts/android-%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%9803-%E7%BB%84%E4%BB%B6-%E6%B8%85%E5%8D%95-%E8%B5%84%E6%BA%90%E5%92%8Cui%E9%97%B2%E8%81%8A/"}]